====== KEY IMPLEMENTATIONS ======
Generated on: 2025年07月 7日 16:45:09


//===== File: ./benchmark/src/poly-benchmark-1k.cpp =====


//===== File: ./benchmark/src/serialize-ckks.cpp =====
            Serial::Serialize(cc, s, SerType::BINARY);
            Serial::Deserialize(cc, s, SerType::BINARY);
            Serial::Serialize(kp.publicKey, s, SerType::BINARY);
            Serial::Deserialize(kpnew.publicKey, s, SerType::BINARY);
            Serial::Serialize(kp.secretKey, s, SerType::BINARY);
            Serial::Deserialize(kpnew.secretKey, s, SerType::BINARY);
            Serial::Serialize(ciphertext, s, SerType::BINARY);
            Serial::Deserialize(newC, s, SerType::BINARY);
            Serial::Serialize(ciphertextL2D2, s2, SerType::BINARY);
            Serial::Deserialize(newCL2D2, s2, SerType::BINARY);


//===== File: ./benchmark/src/VectorMath.cpp =====


//===== File: ./src/binfhe/lib/binfhe-base-scheme.cpp =====


//===== File: ./src/binfhe/lib/binfhe-constants-impl.cpp =====


//===== File: ./src/binfhe/lib/binfhecontext.cpp =====


//===== File: ./src/binfhe/lib/lwe-pke.cpp =====
                             std::floor(0.5 + v.ConvertToDouble() * q.ConvertToDouble() / Q.ConvertToDouble())))


//===== File: ./src/binfhe/lib/rgsw-acc.cpp =====


//===== File: ./src/binfhe/lib/rgsw-acc-cggi.cpp =====


//===== File: ./src/binfhe/lib/rgsw-acc-dm.cpp =====


//===== File: ./src/binfhe/lib/rgsw-acc-lmkcdey.cpp =====


//===== File: ./src/binfhe/lib/rgsw-cryptoparameters.cpp =====


//===== File: ./src/core/extras/dft.cpp =====
    DiscreteFourierTransform::PreComputeTable(128);


//===== File: ./src/core/extras/math.cpp =====


//===== File: ./src/core/extras/ntt1.cpp =====


//===== File: ./src/core/extras/ntt2.cpp =====


//===== File: ./src/core/lib/lattice/constants-lattice-impl.cpp =====


//===== File: ./src/core/lib/lattice/lattice.cpp =====


//===== File: ./src/core/lib/lattice/stdlatticeparms.cpp =====


//===== File: ./src/core/lib/lattice/trapdoor-dcrtpoly.cpp =====
        LatticeGaussSampUtility<NativePoly>::GaussSampGqArbBase(perturbedSyndrome.GetElementAtIndex(u), c, kRes, qu,
                LatticeGaussSampUtility<NativePoly>::GaussSampGqArbBase(perturbedSyndrome(i, j).GetElementAtIndex(u), c,


//===== File: ./src/core/lib/lattice/trapdoor-poly.cpp =====
    LatticeGaussSampUtility<Poly>::GaussSampGqArbBase(perturbedSyndrome, c, k, modulus, base, dgg, &zHatBBI);
    LatticeGaussSampUtility<NativePoly>::GaussSampGqArbBase(perturbedSyndrome, c, k, modulus, base, dgg, &zHatBBI);
            LatticeGaussSampUtility<Poly>::GaussSampGqArbBase(perturbedSyndrome(i, j), c, k, modulus, base, dgg,
            LatticeGaussSampUtility<NativePoly>::GaussSampGqArbBase(perturbedSyndrome(i, j), c, k, modulus, base, dgg,


//===== File: ./src/core/lib/math/chebyshev.cpp =====


//===== File: ./src/core/lib/math/dftransform.cpp =====
DiscreteFourierTransform::PrecomputedValues::PrecomputedValues(uint32_t m, uint32_t nh) {


//===== File: ./src/core/lib/math/discretegaussiangeneratorgeneric.cpp =====
BaseSampler::BaseSampler(double mean, double std, BitGenerator* generator, BaseSamplerType type = PEIKERT)
DiscreteGaussianGeneratorGeneric::DiscreteGaussianGeneratorGeneric(BaseSampler** samplers, const double std,


//===== File: ./src/core/lib/math/distributiongenerator.cpp =====


//===== File: ./src/core/lib/math/hal/bigintdyn/be4-math-impl.cpp =====


//===== File: ./src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp =====
mubintvec<ubint_el_t>::mubintvec(usint length, const ubint_el_t& modulus,
mubintvec<ubint_el_t>::mubintvec(usint length, const ubint_el_t& modulus, std::initializer_list<uint64_t> rhs) noexcept
mubintvec<ubint_el_t>::mubintvec(const std::vector<std::string>& s, const ubint_el_t& modulus) noexcept
mubintvec<ubint_el_t>::mubintvec(const std::vector<std::string>& s, const std::string& modulus) noexcept
    std::copy(rhs.m_data.begin(), rhs.m_data.end(), m_data.begin());


//===== File: ./src/core/lib/math/hal/bigintdyn/ubintdyn.cpp =====
        std::swap(A, B);
        std::swap(sizeA, sizeB);
        std::swap(A, B);
        std::swap(sizeA, sizeB);
    ubint<limb_t>::NormalizeLimbs();
    ubint<limb_t>::NormalizeLimbs();
        std::swap(A, B);
        std::swap(aSize, bSize);
        ubint<limb_t>::ModEq(modulus);
        ubint<limb_t>::ModEq(modulus);
        std::swap(A, B);
        std::swap(aSize, bSize);
    ubint<limb_t>::NormalizeLimbs();


//===== File: ./src/core/lib/math/hal/bigintfxd/be2-math-impl.cpp =====


//===== File: ./src/core/lib/math/hal/bigintfxd/mubintvecfxd.cpp =====
BigVectorFixedT<IntegerType>::BigVectorFixedT() {
BigVectorFixedT<IntegerType>::BigVectorFixedT(usint length, const IntegerType& modulus) {
BigVectorFixedT<IntegerType>::BigVectorFixedT(const BigVectorFixedT& bigVector) {
BigVectorFixedT<IntegerType>::BigVectorFixedT(BigVectorFixedT&& bigVector) {
BigVectorFixedT<IntegerType>::BigVectorFixedT(usint length, const IntegerType& modulus,
BigVectorFixedT<IntegerType>::BigVectorFixedT(usint length, const IntegerType& modulus,


//===== File: ./src/core/lib/math/hal/bigintfxd/ubintfxd.cpp =====


//===== File: ./src/core/lib/math/hal/bigintntl/be6-math-impl.cpp =====


//===== File: ./src/core/lib/math/hal/bigintntl/mubintvecntl.cpp =====
myVecP<myT>::myVecP(const myVecP<myT>& a) : Vec<myT>(INIT_SIZE, a.length()) {
myVecP<myT>::myVecP(myVecP<myT>&& a) : Vec<myT>(INIT_SIZE, a.length()) {
myVecP<myT>::myVecP(const long n, const myT& q) : Vec<myT>(INIT_SIZE, n) {  // NOLINT
myVecP<myT>::myVecP(const long n, const myT& q, std::initializer_list<uint64_t> rhs)  // NOLINT
myVecP<myT>::myVecP(const long n, const myT& q, std::initializer_list<std::string> rhs)  // NOLINT
myVecP<myT>::myVecP(const myVecP<myT>& a, const myT& q) : Vec<myT>(a) {
myVecP<myT>::myVecP(size_t n, const std::string& sq) : Vec<myT>(INIT_SIZE, n) {
myVecP<myT>::myVecP(const myVecP<myT>& a, const std::string& sq) : Vec<myT>(a) {
myVecP<myT>::myVecP(size_t n, uint64_t q) : Vec<myT>(INIT_SIZE, n) {
myVecP<myT>::myVecP(const myVecP<myT>& a, const uint64_t q) : Vec<myT>(a) {
myVecP<myT>::myVecP(std::vector<std::string>& s) {
myVecP<myT>::myVecP(std::vector<std::string>& s, const myT& q) {
myVecP<myT>::myVecP(std::vector<std::string>& s, const char* sq) {
myVecP<myT>::myVecP(std::vector<std::string>& s, const uint64_t q) {
        NTL_NAMESPACE::clear(x[i]);
    NTL_NAMESPACE::clear(x.m_modulus);


//===== File: ./src/core/lib/math/hal/bigintntl/ubintntl.cpp =====
myZZ::myZZ() : ZZ() {
myZZ::myZZ(const NTL::ZZ& val) : ZZ(val) {
myZZ::myZZ(NTL::ZZ&& val) : ZZ() {
myZZ::myZZ(const std::string& strval) : ZZ(conv<ZZ>(strval.c_str())) {
myZZ::myZZ(uint64_t d) : ZZ(0) {
myZZ::myZZ(uint128_t d) : myZZ((uint64_t)d) {}
    std::reverse(v.begin(), v.end());
        std::reverse(bits.begin(), bits.end());


//===== File: ./src/core/lib/math/hal/intnat/benative-math-impl.cpp =====


//===== File: ./src/core/lib/math/hal/intnat/mubintvecnat.cpp =====
NativeVectorT<IntegerType>::NativeVectorT(usint length, const IntegerType& modulus,
NativeVectorT<IntegerType>::NativeVectorT(usint length, const IntegerType& modulus,


//===== File: ./src/core/lib/math/matrix.cpp =====


//===== File: ./src/core/lib/math/nbtheory2.cpp =====


//===== File: ./src/core/lib/utils/blockAllocator/blockAllocator.cpp =====
Allocator::Allocator(size_t size, size_t objects, char* memory, const char* name)


//===== File: ./src/core/lib/utils/blockAllocator/xallocator.cpp =====
XallocInitDestroy::XallocInitDestroy() {
        std::memcpy(newMem, oldMem, (oldSize < size) ? oldSize : size);


//===== File: ./src/core/lib/utils/debug.cpp =====


//===== File: ./src/core/lib/utils/demangle.cpp =====
            std::free(ptr);
            std::free(output_buffer);
        std::free(output_buffer);


//===== File: ./src/core/lib/utils/get-call-stack.cpp =====


//===== File: ./src/core/lib/utils/hashutil.cpp =====


//===== File: ./src/core/lib/utils/inttypes.cpp =====


//===== File: ./src/core/lib/utils/memory.cpp =====


//===== File: ./src/core/lib/utils/openfhebase64.cpp =====


//===== File: ./src/core/lib/utils/parallel.cpp =====


//===== File: ./src/core/lib/utils/prng/blake2engine.cpp =====
    lbcrypto::secure_memset(m_seed.data(), 0, bytes_to_clear);
    lbcrypto::secure_memset(rdseed.data(), 0, bytes_to_clear);
    lbcrypto::secure_memset(seed.data(), 0, bytes_to_clear);


//===== File: ./src/core/lib/utils/utilities.cpp =====


//===== File: ./src/pke/extras/bfv-encode-vs-ptxt-ctxt-benchmark.cpp.cpp =====


//===== File: ./src/pke/extras/bfv-mult-bug.cpp =====


//===== File: ./src/pke/extras/ckks-bootstrap.cpp =====
        CryptoContextFactory<DCRTPoly>::genCryptoContextCKKS(
        CryptoContextFactory<DCRTPoly>::genCryptoContextCKKS(


//===== File: ./src/pke/extras/ckks-bootstrapping-precision.cpp =====


//===== File: ./src/pke/extras/run-bfvrns.cpp =====


//===== File: ./src/pke/extras/run-bfvrns-behz.cpp =====


//===== File: ./src/pke/extras/scheme-switching-timing.cpp =====
    std::transform(x.begin(), x.end(), xInt.begin(), [&](const double& elem) {
    std::setprecision(logQ_ccLWE + 10);


//===== File: ./src/pke/lib/ciphertext-impl.cpp =====


//===== File: ./src/pke/lib/constants-impl.cpp =====


//===== File: ./src/pke/lib/cryptocontext.cpp =====
    CryptoContextImpl<Element>::InsertEvalAutomorphismKey(evalKeys, privateKey->GetKeyTag());
    CryptoContextImpl<Element>::InsertEvalAutomorphismKey(evalKeys, privateKey->GetKeyTag());
    CryptoContextImpl<Element>::InsertEvalAutomorphismKey(evalKeys, privateKey->GetKeyTag());
CryptoContextImpl<Element>::GetAllEvalAutomorphismKeys() {
        CryptoContextImpl<Element>::GetEvalAutomorphismKeyMapPtr(keyID);
CryptoContextImpl<Element>::GetAllEvalSumKeys() {
    CryptoContextImpl<Element>::ClearEvalAutomorphismKeys();
    CryptoContextImpl<Element>::ClearEvalAutomorphismKeys(id);
    CryptoContextImpl<Element>::ClearEvalAutomorphismKeys(cc);
    CryptoContextImpl<Element>::InsertEvalAutomorphismKey(evalKeys, privateKey->GetKeyTag());
    std::set_difference(newValues.begin(), newValues.end(), oldValues.begin(), oldValues.end(),
                        std::inserter(newUniqueValues, newUniqueValues.begin()));


//===== File: ./src/pke/lib/cryptocontextfactory.cpp =====
                PackedEncoding::SetParams(cc->GetCyclotomicOrder(), cc->GetEncodingParams());
        PackedEncoding::SetParams(cc->GetCyclotomicOrder(), cc->GetEncodingParams());


//===== File: ./src/pke/lib/cryptoobject-impl.cpp =====


//===== File: ./src/pke/lib/encoding/ckkspackedencoding.cpp =====
        DiscreteFourierTransform::FFTSpecialInv(inverse, ringDim * 2);
        DiscreteFourierTransform::FFTSpecialInv(inverse, ringDim * 2);//iDFT（iFFT）
                DiscreteFourierTransform::FFTSpecial(inverse, ringDim * 2);//FFT变回去？
        DiscreteFourierTransform::FFTSpecial(realValues, GetElementRingDimension() * 2);


//===== File: ./src/pke/lib/encoding/coefpackedencoding.cpp =====


//===== File: ./src/pke/lib/encoding/encodingparams.cpp =====


//===== File: ./src/pke/lib/encoding/packedencoding.cpp =====
                              std::to_string(i) + " that is > plaintext modulus " + std::to_string(mod));
                              std::to_string(i) + " that is > plaintext modulus " + std::to_string(mod));


//===== File: ./src/pke/lib/encoding/stringencoding.cpp =====


//===== File: ./src/pke/lib/globals-impl.cpp =====


//===== File: ./src/pke/lib/key/evalkey.cpp =====


//===== File: ./src/pke/lib/key/evalkeyrelin.cpp =====


//===== File: ./src/pke/lib/key/privatekey.cpp =====


//===== File: ./src/pke/lib/key/publickey.cpp =====


//===== File: ./src/pke/lib/keyswitch/keyswitch-base.cpp =====


//===== File: ./src/pke/lib/keyswitch/keyswitch-bv.cpp =====


//===== File: ./src/pke/lib/keyswitch/keyswitch-hybrid.cpp =====


//===== File: ./src/pke/lib/scheme/bfvrns/bfvrns-cryptoparameters.cpp =====
    CryptoParametersRNS::PrecomputeCRTTables(ksTech, scalTech, encTech, multTech, numPartQ, auxBits, extraBits);


//===== File: ./src/pke/lib/scheme/bfvrns/bfvrns-leveledshe.cpp =====


//===== File: ./src/pke/lib/scheme/bfvrns/bfvrns-multiparty.cpp =====


//===== File: ./src/pke/lib/scheme/bfvrns/bfvrns-parametergeneration.cpp =====
                StdLatticeParm::FindRingDim(distType, stdLevel, static_cast<uint32_t>(std::ceil(logq))));
                      std::to_string(n) + ".");


//===== File: ./src/pke/lib/scheme/bfvrns/bfvrns-pke.cpp =====


//===== File: ./src/pke/lib/scheme/bfvrns/bfvrns-scheme.cpp =====


//===== File: ./src/pke/lib/scheme/bgvrns/bgvrns-cryptoparameters.cpp =====
    CryptoParametersRNS::PrecomputeCRTTables(ksTech, scalTech, encTech, multTech, numPartQ, auxBits, extraBits);


//===== File: ./src/pke/lib/scheme/bgvrns/bgvrns-leveledshe.cpp =====


//===== File: ./src/pke/lib/scheme/bgvrns/bgvrns-multiparty.cpp =====


//===== File: ./src/pke/lib/scheme/bgvrns/bgvrns-parametergeneration.cpp =====
            CryptoParametersRNS::EstimateLogP(numPartQ, firstModSize, dcrtBits, extraModSize, numPrimes, auxBits, true);
                   std::find(extraModuli.begin(), extraModuli.end(), extraModulus) != extraModuli.end()) {
                       std::make_move_iterator(extraModuli.end()));
                      std::make_move_iterator(extraRoots.end()));


//===== File: ./src/pke/lib/scheme/bgvrns/bgvrns-pke.cpp =====


//===== File: ./src/pke/lib/scheme/bgvrns/bgvrns-scheme.cpp =====


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-advancedshe.cpp =====


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-cryptoparameters.cpp =====
    CryptoParametersRNS::PrecomputeCRTTables(ksTech, scalTech, encTech, multTech, numPartQ, auxBits, extraBits);


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-fhe.cpp =====
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
                      std::to_string(m_correctionFactor) + "].");
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup and then EvalBootstrapKeyGen to proceed"));
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup to proceed"));
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup to proceed"));
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup to proceed"));
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup to proceed"));
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup to proceed"));
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalBootstrapSetup to proceed"));
                             std::string(" slots were not generated") +


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-leveledshe.cpp =====


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-multiparty.cpp =====
        std::ceil(std::log2(ciphertext->GetElements()[0].GetAllElements()[0].GetParams()->GetModulus().ConvertToInt()));


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-parametergeneration.cpp =====


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-pke.cpp =====


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-scheme.cpp =====


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp =====
    DiscreteFourierTransform::FFTSpecialInv(inverse, N * 2);
            DiscreteFourierTransform::FFTSpecial(inverse, N * 2);
    DiscreteFourierTransform::FFTSpecialInv(inverse, N * 2);
            DiscreteFourierTransform::FFTSpecial(inverse, N * 2);
                std::transform(vec.begin(), vec.end(), vec.begin(),
                std::transform(diag.begin(), diag.end(), diag.begin(),
                                    std::make_move_iterator(tmp.end()));
                    std::transform(diag.begin(), diag.end(), diag.begin(),
                    std::transform(diag.begin(), diag.end(), diag.begin(),
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalCKKSToFHEWPrecompute to proceed"));
        std::iota(ind.begin(), ind.end(), 0);
        std::iota(ind.begin(), ind.end(), 0);
        std::iota(ind.begin(), ind.end(), 0);
        std::iota(ind.begin(), ind.end(), 0);


//===== File: ./src/pke/lib/scheme/ckksrns/ckksrns-utils.cpp =====
    std::fill(mlist.begin(), mlist.begin() + 2, 1);            // n in [1,2], m = 1
    std::fill(mlist.begin() + 2, mlist.begin() + 11, 2);       // n in [3,11], m = 2
    std::fill(mlist.begin() + 11, mlist.begin() + 13, 3);      // n in [12,13], m = 3
    std::fill(mlist.begin() + 13, mlist.begin() + 17, 2);      // n in [14,17], m = 2
    std::fill(mlist.begin() + 17, mlist.begin() + 55, 3);      // n in [18,55], m = 3
    std::fill(mlist.begin() + 55, mlist.begin() + 59, 4);      // n in [56,59], m = 4
    std::fill(mlist.begin() + 59, mlist.begin() + 76, 3);      // n in [60,76], m = 3
    std::fill(mlist.begin() + 76, mlist.begin() + 239, 4);     // n in [77,239], m = 4
    std::fill(mlist.begin() + 239, mlist.begin() + 247, 5);    // n in [240,247], m = 5
    std::fill(mlist.begin() + 247, mlist.begin() + 284, 4);    // n in [248,284], m = 4
    std::fill(mlist.begin() + 284, mlist.begin() + 991, 5);    // n in [285,991], m = 5
    std::fill(mlist.begin() + 991, mlist.begin() + 1007, 6);   // n in [992,1007], m = 6
    std::fill(mlist.begin() + 1007, mlist.begin() + 1083, 5);  // n in [1008,1083], m = 5
    std::fill(mlist.begin() + 1083, mlist.begin() + 2015, 6);  // n in [1084,2015], m = 6
    std::fill(mlist.begin() + 2015, mlist.begin() + 2031, 7);  // n in [2016,2031], m = 7
    std::fill(mlist.begin() + 2031, mlist.end(), 6);           // n in [2032,2204], m = 6
    std::fill(depthTable.begin(),        depthTable.begin() + 5,     3);  // degree in [0,4], depth = 3 - the Paterson-Stockmeyer algorithm is not used when degree < 5
    std::fill(depthTable.begin() + 5,    depthTable.begin() + 6,     4);  // degree in [5],         depth = 4
    std::fill(depthTable.begin() + 6,    depthTable.begin() + 14,    5);  // degree in [6,13],      depth = 5
    std::fill(depthTable.begin() + 14,   depthTable.begin() + 28,    6);  // degree in [14,27],     depth = 6


//===== File: ./src/pke/lib/scheme/ckksrns/schemeswitching-data-serializer.cpp =====


//===== File: ./src/pke/lib/scheme/gen-cryptocontext-params-impl.cpp =====
Params::Params(const std::vector<std::string>& vals) {
                           std::to_string(getAllParamsDataMembers().size()) + " != " + std::to_string(vals.size()));


//===== File: ./src/pke/lib/scheme/gen-cryptocontext-params-validation.cpp =====
                             std::to_string(parameters.GetMultiplicativeDepth()) +


//===== File: ./src/pke/lib/scheme/scheme-id-impl.cpp =====


//===== File: ./src/pke/lib/scheme/scheme-swch-params.cpp =====


//===== File: ./src/pke/lib/schemebase/base-advancedshe.cpp =====


//===== File: ./src/pke/lib/schemebase/base-cryptoparameters.cpp =====


//===== File: ./src/pke/lib/schemebase/base-fhe.cpp =====


//===== File: ./src/pke/lib/schemebase/base-leveledshe.cpp =====
                             std::to_string(numTowers1) + "] and for ciphertext2 [" + std::to_string(numTowers2) +
                             std::to_string(numTowersCtxt) + "] and for plaintext[" + std::to_string(numTowersPtxt) +


//===== File: ./src/pke/lib/schemebase/base-multiparty.cpp =====


//===== File: ./src/pke/lib/schemebase/base-parametergeneration.cpp =====


//===== File: ./src/pke/lib/schemebase/base-pke.cpp =====


//===== File: ./src/pke/lib/schemebase/base-pre.cpp =====


//===== File: ./src/pke/lib/schemebase/base-scheme.cpp =====


//===== File: ./src/pke/lib/schemebase/rlwe-cryptoparameters-impl.cpp =====


//===== File: ./src/pke/lib/schemerns/rns-cryptoparameters.cpp =====
    DiscreteFourierTransform::Initialize(n * 2, n / 2);


//===== File: ./src/pke/lib/schemerns/rns-leveledshe.cpp =====


//===== File: ./src/pke/lib/schemerns/rns-multiparty.cpp =====


//===== File: ./src/pke/lib/schemerns/rns-pke.cpp =====


//===== File: ./third-party/cereal/sandbox/performance.cpp =====


//===== File: ./third-party/cereal/sandbox/sandbox.cpp =====
           cereal::make_nvp( name2, o_double2 ),
           cereal::make_nvp( name3, o_vecbool3 ),
           cereal::make_nvp( name4, o_int4 ),
           cereal::make_nvp( name5, o_int5 ),
           cereal::make_nvp( name6, o_int6 ),
           cereal::make_nvp( name7, o_un7 ) );
           cereal::make_nvp( name2, i_double2 ),
           cereal::make_nvp( name4, i_int4 ),
           cereal::make_nvp( name3, i_vecbool3 ),
           cereal::make_nvp( name1, i_int1 ),
           cereal::make_nvp( name5, i_int5 ),
    std::remove("out.txt");
    std::remove("endian.out");


//===== File: ./third-party/cereal/sandbox/sandbox_json.cpp =====
        cereal::JSONOutputArchive::Options(2, cereal::JSONOutputArchive::Options::IndentChar::space, 2) );
        cereal::make_nvp( "2", 2 ),
        cereal::make_nvp( "4", 4 ),
        cereal::make_nvp( "5", 5 ) );
         cereal::make_nvp( "2", 2 ),
         cereal::make_nvp( "4", 4 ),
         cereal::make_nvp( "5", 5 ) );


//===== File: ./third-party/cereal/sandbox/sandbox_rtti.cpp =====


//===== File: ./third-party/cereal/sandbox/sandbox_shared_lib/base.cpp =====


//===== File: ./third-party/cereal/sandbox/sandbox_shared_lib/derived.cpp =====


//===== File: ./third-party/cereal/sandbox/sandbox_vs.cpp =====


//===== File: ./third-party/google-benchmark/cmake/gnu_posix_regex.cpp =====


//===== File: ./third-party/google-benchmark/cmake/posix_regex.cpp =====


//===== File: ./third-party/google-benchmark/cmake/std_regex.cpp =====


//===== File: ./third-party/google-benchmark/cmake/steady_clock.cpp =====


//===== File: ./third-party/google-benchmark/cmake/thread_safety_attributes.cpp =====
