====== CORE HEADERS AND INTERFACES ======
Generated on: 2025年07月 7日 16:44:45


//========================================
//===== File: ./benchmark/src/poly-benchmark.h =====
//========================================

static void DCRTArguments(benchmark::internal::Benchmark* b) {
    for (uint32_t t : tow_args) {
        b->ArgName("towers")->Arg(t);
    }

static void GeneratePolys(uint32_t order, uint32_t bits, std::shared_ptr<std::vector<NativePoly>>& polyArrayEval,
                          std::shared_ptr<std::vector<NativePoly>>& polyArrayCoef) {
    auto p    = std::make_shared<ILNativeParams>(order, bits);
    auto eval = std::make_shared<std::vector<NativePoly>>();

static void GenerateDCRTPolys(uint32_t order, uint32_t bits,
                              std::map<uint32_t, std::shared_ptr<std::vector<DCRTPoly>>>& polyArrayEval,
                              std::map<uint32_t, std::shared_ptr<std::vector<DCRTPoly>>>& polyArrayCoef) {
    polyArrayEval.clear();


//========================================
//===== File: ./src/binfhe/include/binfhe-base-params.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Class that stores all parameters for the RingGSW scheme used in
 */
class BinFHECryptoParams : public Serializable {
public:
    BinFHECryptoParams() = default;

    /**

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("lweparams", m_LWEParams));
        ar(::cereal::make_nvp("rgswparams", m_RGSWParams));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +

    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    // shared pointer to an instance of LWECryptoParams
    std::shared_ptr<LWECryptoParams> m_LWEParams{nullptr};



//========================================
//===== File: ./src/binfhe/include/binfhe-base-scheme.h =====
//========================================

namespace lbcrypto {

// The struct for storing bootstrapping keys
typedef struct {
    // refreshing key
    RingGSWACCKey BSkey;
    // switching key
 */
class BinFHEScheme {
public:
    BinFHEScheme() = default;

    explicit BinFHEScheme(BINFHE_METHOD method) {
        if (method == AP)
            ACCscheme = std::make_shared<RingGSWAccumulatorDM>();
        else if (method == GINX)

private:
    /**
   * Core bootstrapping operation
   *
   */
    template <typename Func>
    RLWECiphertext BootstrapFuncCore(const std::shared_ptr<BinFHECryptoParams>& params, ConstRingGSWACCKey& ek,
                                     ConstLWECiphertext& ct, const Func f, const NativeInteger& fmod) const;

   */
    template <typename Func>
    LWECiphertext BootstrapFunc(const std::shared_ptr<BinFHECryptoParams>& params, const RingGSWBTKey& EK,
                                ConstLWECiphertext& ct, const Func f, const NativeInteger& fmod) const;

protected:
    std::shared_ptr<LWEEncryptionScheme> LWEscheme{std::make_shared<LWEEncryptionScheme>()};
    std::shared_ptr<RingGSWAccumulator> ACCscheme{nullptr};

   */
    static uint32_t checkInputFunction(const std::vector<NativeInteger>& lut, NativeInteger mod) {
        size_t mid{lut.size() / 2};
        if (lut[0] == (mod - lut[mid])) {
            for (size_t i = 1; i < mid; ++i)


//========================================
//===== File: ./src/binfhe/include/binfhe-constants.h =====
//========================================

namespace lbcrypto {

using LWEPlaintext        = int64_t;
using LWEPlaintextModulus = uint64_t;
// clang-format off
enum BINFHE_PARAMSET {
//  NAME,                 // Description                                                     : Approximate Probability of Failure
    TOY,                  // no security                                                     : 2^(-360)
    MEDIUM,               // 108 bits of security for classical and 100 bits for quantum     : 2^(-70)
 */
enum BINFHE_OUTPUT {
    INVALID_OUTPUT = 0,
    FRESH,         // a fresh encryption (deprecated)
    BOOTSTRAPPED,  // a freshly encrypted ciphertext is bootstrapped (deprecated)
 */
enum BINFHE_METHOD {
    INVALID_METHOD = 0,
    AP,       // Ducas-Micciancio variant
    GINX,     // Chillotti-Gama-Georgieva-Izabachene variant
 */
enum BINGATE { OR, AND, NOR, NAND, XOR, XNOR, MAJORITY, AND3, OR3, AND4, OR4, XOR_FAST, XNOR_FAST, CMUX };
std::ostream& operator<<(std::ostream& s, BINGATE f);

/**
 */
enum KEYGEN_MODE {
    SYM_ENCRYPT = 0,  // symmetric (secret) key encryption
    PUB_ENCRYPT,      // public key encryption
};


//========================================
//===== File: ./src/binfhe/include/binfhecontext.h =====
//========================================

namespace lbcrypto {

// TODO: reorder to optimize struct size/alignment
struct BinFHEContextParams {
    // for intermediate prime, modulus for RingGSW / RLWE used in bootstrapping
    usint numberBits;
    usint cyclOrder;
 */
class BinFHEContext : public Serializable {
public:
    BinFHEContext() = default;

    /**

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("params", m_params));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }


private:
    // Shared pointer to Ring GSW + LWE parameters
    std::shared_ptr<BinFHECryptoParams> m_params{nullptr};



//========================================
//===== File: ./src/binfhe/include/binfhecontext-ser.h =====
//========================================


//========================================
//===== File: ./src/binfhe/include/lwe-ciphertext.h =====
//========================================

namespace lbcrypto {
/**
 * @brief Class that stores a LWE scheme ciphertext; composed of a vector "a"
 * and integer "b"
 */
class LWECiphertextImpl : public Serializable {
public:
    LWECiphertextImpl() = default;

    LWECiphertextImpl(const NativeVector& a, const NativeInteger& b) : m_a(a), m_b(b) {}

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("a", m_a));
        ar(::cereal::make_nvp("b", m_b));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    NativeVector m_a{};
    NativeInteger m_b{};
    NativeInteger m_p = 4;  // pt modulus


//========================================
//===== File: ./src/binfhe/include/lwe-ciphertext-fwd.h =====
//========================================

namespace lbcrypto {

class LWECiphertextImpl;

using LWECiphertext      = std::shared_ptr<LWECiphertextImpl>;
using ConstLWECiphertext = const std::shared_ptr<const LWECiphertextImpl>;


//========================================
//===== File: ./src/binfhe/include/lwe-cryptoparameters.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Class that stores all parameters for the LWE scheme
 */
class LWECryptoParams : public Serializable {
public:
    LWECryptoParams() = default;

    /**
   */
    explicit LWECryptoParams(uint32_t n, uint32_t N, const NativeInteger& q, const NativeInteger& Q,
                             const NativeInteger& q_KS, double std, uint32_t baseKS,
                             SecretKeyDist keyDist = UNIFORM_TERNARY)
        : m_q(q), m_Q(Q), m_qKS(q_KS), m_n(n), m_N(N), m_baseKS(baseKS), m_keyDist(keyDist) {

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("n", m_n));
        ar(::cereal::make_nvp("N", m_N));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    // modulus for the additive LWE scheme
    NativeInteger m_q{};
    // modulus for the RingGSW/RingLWE scheme


//========================================
//===== File: ./src/binfhe/include/lwe-keypair.h =====
//========================================

namespace lbcrypto {
/**
 * @brief Class that stores the LWE scheme secret key, public key pair; ((A, b), s)
 */
class LWEKeyPairImpl {
public:
    LWEPublicKey publicKey{nullptr};
    LWEPrivateKey secretKey{nullptr};



//========================================
//===== File: ./src/binfhe/include/lwe-keypair-fwd.h =====
//========================================

namespace lbcrypto {

class LWEKeyPairImpl;

using LWEKeyPair      = std::shared_ptr<LWEKeyPairImpl>;
using ConstLWEKeyPair = const std::shared_ptr<const LWEKeyPairImpl>;


//========================================
//===== File: ./src/binfhe/include/lwe-keyswitchkey.h =====
//========================================

namespace lbcrypto {
/**
 * @brief Class that stores the LWE scheme switching key
 */
class LWESwitchingKeyImpl : public Serializable {
public:
    LWESwitchingKeyImpl() = default;

    LWESwitchingKeyImpl(const std::vector<std::vector<std::vector<NativeVector>>>& keyA,

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("a", m_keyA));
        ar(::cereal::make_nvp("b", m_keyB));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    std::vector<std::vector<std::vector<NativeVector>>> m_keyA;
    std::vector<std::vector<std::vector<NativeInteger>>> m_keyB;
};


//========================================
//===== File: ./src/binfhe/include/lwe-keyswitchkey-fwd.h =====
//========================================

namespace lbcrypto {

class LWESwitchingKeyImpl;

using LWESwitchingKey      = std::shared_ptr<LWESwitchingKeyImpl>;
using ConstLWESwitchingKey = const std::shared_ptr<const LWESwitchingKeyImpl>;


//========================================
//===== File: ./src/binfhe/include/lwe-pke.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Additive public-key LWE scheme
 */
class LWEEncryptionScheme {
    NativeInteger RoundqQ(const NativeInteger& v, const NativeInteger& q, const NativeInteger& Q) const;

public:
    LWEEncryptionScheme() = default;

    /**


//========================================
//===== File: ./src/binfhe/include/lwe-privatekey.h =====
//========================================

namespace lbcrypto {
/**
 * @brief Class that stores the LWE scheme secret key; contains a vector
 */
class LWEPrivateKeyImpl : public Serializable {
public:
    LWEPrivateKeyImpl() = default;

    explicit LWEPrivateKeyImpl(const NativeVector& s) : m_s(s) {}

    LWEPrivateKeyImpl(const LWEPrivateKeyImpl& rhs) : m_s(rhs.m_s) {}


    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("s", m_s));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    NativeVector m_s{};
};



//========================================
//===== File: ./src/binfhe/include/lwe-privatekey-fwd.h =====
//========================================

namespace lbcrypto {

class LWEPrivateKeyImpl;

using LWEPrivateKey      = std::shared_ptr<LWEPrivateKeyImpl>;
using ConstLWEPrivateKey = const std::shared_ptr<const LWEPrivateKeyImpl>;


//========================================
//===== File: ./src/binfhe/include/lwe-publickey.h =====
//========================================

namespace lbcrypto {
/**
 * @brief Class that stores the LWE scheme public key; contains a vector
 */
class LWEPublicKeyImpl : public Serializable {
public:
    LWEPublicKeyImpl() = default;

    LWEPublicKeyImpl(const std::vector<NativeVector>& A, const NativeVector& v) : m_A(A), m_v(v) {}

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("A", m_A));
        ar(::cereal::make_nvp("v", m_v));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    std::vector<NativeVector> m_A;
    NativeVector m_v;
};


//========================================
//===== File: ./src/binfhe/include/lwe-publickey-fwd.h =====
//========================================

namespace lbcrypto {

class LWEPublicKeyImpl;

using LWEPublicKey      = std::shared_ptr<LWEPublicKeyImpl>;
using ConstLWEPublicKey = const std::shared_ptr<const LWEPublicKeyImpl>;


//========================================
//===== File: ./src/binfhe/include/rgsw-acc.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Ring GSW accumulator schemes described in
 */
class RingGSWAccumulator {
public:
    RingGSWAccumulator() = default;

    /**
   */
    virtual RingGSWACCKey KeyGenAcc(const std::shared_ptr<RingGSWCryptoParams>& params, const NativePoly& skNTT,
                                    ConstLWEPrivateKey& LWEsk) const {
        OPENFHE_THROW("KeyGenACC operation not supported");
    }
   */
    virtual void EvalAcc(const std::shared_ptr<RingGSWCryptoParams>& params, ConstRingGSWACCKey& ek,
                         RLWECiphertext& acc, const NativeVector& a) const {
        OPENFHE_THROW("ACC operation not supported");
    }


//========================================
//===== File: ./src/binfhe/include/rgsw-acc-cggi.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Ring GSW accumulator schemes described in
 */
class RingGSWAccumulatorCGGI final : public RingGSWAccumulator {
public:
    RingGSWAccumulatorCGGI() = default;

    /**

private:
    /**
   * Key generation for internal Ring GSW as described in https://eprint.iacr.org/2020/086
   *


//========================================
//===== File: ./src/binfhe/include/rgsw-acc-dm.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Ring GSW accumulator schemes described in
 */
class RingGSWAccumulatorDM final : public RingGSWAccumulator {
public:
    RingGSWAccumulatorDM() = default;

    /**

private:
    /**
   * DM Key generation for internal Ring GSW as described in https://eprint.iacr.org/2014/816
   *


//========================================
//===== File: ./src/binfhe/include/rgsw-acckey.h =====
//========================================

namespace lbcrypto {

class RingGSWACCKeyImpl;
using RingGSWACCKey      = std::shared_ptr<RingGSWACCKeyImpl>;
using ConstRingGSWACCKey = const std::shared_ptr<const RingGSWACCKeyImpl>;

 */
class RingGSWACCKeyImpl : public Serializable {
public:
    RingGSWACCKeyImpl() = default;

    RingGSWACCKeyImpl(uint32_t dim1, uint32_t dim2, uint32_t dim3) : m_key(dim1, dim2_t(dim2, dim3_t(dim3))) {}

    explicit RingGSWACCKeyImpl(const std::vector<std::vector<std::vector<RingGSWEvalKey>>>& key) : m_key(key) {}

    RingGSWACCKeyImpl(const RingGSWACCKeyImpl& rhs) : m_key(rhs.m_key) {}


    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("k", m_key));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    using dim3_t = std::vector<RingGSWEvalKey>;
    using dim2_t = std::vector<dim3_t>;
    using dim1_t = std::vector<dim2_t>;


//========================================
//===== File: ./src/binfhe/include/rgsw-acc-lmkcdey.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Ring GSW accumulator schemes described in
 */
class RingGSWAccumulatorLMKCDEY final : public RingGSWAccumulator {
public:
    RingGSWAccumulatorLMKCDEY() = default;

    /**

private:
    /**
   * LMKCDEY Key generation for internal Ring GSW as described in https://eprint.iacr.org/2022/198
   *


//========================================
//===== File: ./src/binfhe/include/rgsw-cryptoparameters.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Class that stores all parameters for the RingGSW scheme used in
 */
class RingGSWCryptoParams : public Serializable {
public:
    RingGSWCryptoParams() = default;

    /**
   */
    explicit RingGSWCryptoParams(uint32_t N, NativeInteger Q, NativeInteger q, uint32_t baseG, uint32_t baseR,
                                 BINFHE_METHOD method, double std, SecretKeyDist keyDist = UNIFORM_TERNARY,
                                 bool signEval = false, uint32_t numAutoKeys = 10)
        : m_Q(Q),

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("bN", m_N));
        ar(::cereal::make_nvp("bQ", m_Q));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

            m_digitsG =
                static_cast<uint32_t>(std::ceil(log(m_Q.ConvertToDouble()) / log(static_cast<double>(m_baseG))));
        }
    }

private:
    // modulus for the RingGSW/RingLWE scheme
    NativeInteger m_Q{};



//========================================
//===== File: ./src/binfhe/include/rgsw-evalkey.h =====
//========================================

namespace lbcrypto {

class RingGSWEvalKeyImpl;
using RingGSWEvalKey      = std::shared_ptr<RingGSWEvalKeyImpl>;
using ConstRingGSWEvalKey = const std::shared_ptr<const RingGSWEvalKeyImpl>;

 */
class RingGSWEvalKeyImpl : public Serializable {
public:
    RingGSWEvalKeyImpl() = default;

    RingGSWEvalKeyImpl(uint32_t rowSize, uint32_t colSize) noexcept

    explicit RingGSWEvalKeyImpl(const std::vector<std::vector<NativePoly>>& elements) : m_elements(elements) {}

    RingGSWEvalKeyImpl(const RingGSWEvalKeyImpl& rhs) : m_elements(rhs.m_elements) {}


    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("elements", m_elements));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    std::vector<std::vector<NativePoly>> m_elements;
};



//========================================
//===== File: ./src/binfhe/include/rlwe-ciphertext.h =====
//========================================

namespace lbcrypto {

class RLWECiphertextImpl;
using RLWECiphertext      = std::shared_ptr<RLWECiphertextImpl>;
using ConstRLWECiphertext = const std::shared_ptr<const RLWECiphertextImpl>;

 */
class RLWECiphertextImpl : public Serializable {
public:
    RLWECiphertextImpl() = default;

    explicit RLWECiphertextImpl(const std::vector<NativePoly>& elements) : m_elements(elements) {}

    explicit RLWECiphertextImpl(std::vector<NativePoly>&& elements) noexcept : m_elements(std::move(elements)) {}

    RLWECiphertextImpl(const RLWECiphertextImpl& rhs) : m_elements(rhs.m_elements) {}


    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("elements", m_elements));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    std::vector<NativePoly> m_elements;
};



//========================================
//===== File: ./src/core/include/lattice/constants-lattice.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Lists all modes for RLWE schemes, such as BGV and BFV, and for LWE schemes, such as DM and TFHE
 */
enum SecretKeyDist {
    GAUSSIAN        = 0,
    UNIFORM_TERNARY = 1,  // Default value, all schemes support this key distribution
    SPARSE_TERNARY  = 2,


//========================================
//===== File: ./src/core/include/lattice/dgsampling.h =====
//========================================

namespace lbcrypto {

// Statistical error in Gaussian sampling
// corresponds to statistical error of 2^(-80)
 */
template <class Element>
class LatticeGaussSampUtility {
public:
    /**
   * Gaussian sampling from lattice for gagdet matrix G, syndrome u, and
   * arbitrary modulus q Discrete sampling variant As described in Figure 2 of
   */
    static void GaussSampGq(const Element& u, double stddev, size_t k, const typename Element::Integer& q, int64_t base,
                            typename Element::DggType& dgg, Matrix<int64_t>* z);

    /**
   */
    static void GaussSampGqArbBase(const Element& u, double stddev, size_t k, const typename Element::Integer& q,
                                   int64_t base, typename Element::DggType& dgg, Matrix<int64_t>* z);

    /**
   */
    static void ZSampleSigma2x2(const Field2n& a, const Field2n& b, const Field2n& d, const Matrix<Field2n>& c,
                                const typename Element::DggType& dgg, std::shared_ptr<Matrix<int64_t>> p);

    /**
   */
    static void SampleMat(const Matrix<Field2n>& A, const Matrix<Field2n>& B, const Matrix<Field2n>& D,
                          const Matrix<Field2n>& C, const typename Element::DggType& dgg,
                          std::shared_ptr<Matrix<int64_t>> p);

   */
    static std::shared_ptr<Matrix<int64_t>> ZSampleF(const Field2n& f, const Field2n& c,
                                                     const typename Element::DggType& dgg, size_t n);

private:
    // subroutine used by GaussSampGq
    // Discrete sampling variant
    // As described in Figure 2 of https://eprint.iacr.org/2017/308.pdf
    static void Perturb(double sigma, size_t k, size_t n, const std::vector<double>& l, const std::vector<double>& h,
                        int64_t base, typename Element::DggType& dgg, std::vector<int64_t>* p);

    // subroutine used by GaussSampGqArbBase
    // As described in Algorithm 3 of https://eprint.iacr.org/2017/844.pdf
    static void PerturbFloat(double sigma, size_t k, size_t n, const std::vector<double>& l,
                             const std::vector<double>& h, int64_t base, typename Element::DggType& dgg,
                             std::vector<double>* p);

    // As described in Algorithm 3 of https://eprint.iacr.org/2017/844.pdf
    static void SampleC(const Matrix<double>& c, size_t k, size_t n, double sigma, typename Element::DggType& dgg,
                        Matrix<double>* a, std::vector<int64_t>* z);

    // subroutine earlier used by ZSampleF
    // https://eprint.iacr.org/2017/844.pdf
    static Matrix<int32_t> Permute(Matrix<int32_t>* p);

    // subroutine used by ZSampleF
    // Algorithm utilizes the same inverse permutation algorithm as discussed in
    // https://eprint.iacr.org/2017/844.pdf
    static void InversePermute(std::shared_ptr<Matrix<int64_t>> p);
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/lattice/dgsampling-impl.h =====
//========================================

namespace lbcrypto {

// Gaussian sampling from lattice for gagdet matrix G, syndrome u, and arbitrary
// modulus q Discrete sampling variant As described in Figure 2 of

template <class Element>
void LatticeGaussSampUtility<Element>::GaussSampGq(const Element& syndrome, double stddev, size_t k,
                                                   const typename Element::Integer& q, int64_t base,
                                                   typename Element::DggType& dgg, Matrix<int64_t>* z) {

template <class Element>
void LatticeGaussSampUtility<Element>::GaussSampGqArbBase(const Element& syndrome, double stddev, size_t k,
                                                          const typename Element::Integer& q, int64_t base,
                                                          typename Element::DggType& dgg, Matrix<int64_t>* z) {

template <class Element>
void LatticeGaussSampUtility<Element>::Perturb(double sigma, size_t k, size_t n, const std::vector<double>& l,
                                               const std::vector<double>& h, int64_t base,
                                               typename Element::DggType& dgg, std::vector<int64_t>* p) {

template <class Element>
void LatticeGaussSampUtility<Element>::PerturbFloat(double sigma, size_t k, size_t n, const std::vector<double>& l,
                                                    const std::vector<double>& h, int64_t base,
                                                    typename Element::DggType& dgg, std::vector<double>* p) {

template <class Element>
void LatticeGaussSampUtility<Element>::SampleC(const Matrix<double>& c, size_t k, size_t n, double sigma,
                                               typename Element::DggType& dgg, Matrix<double>* a,
                                               std::vector<int64_t>* z) {
// field elements in Format::COEFFICIENT format
template <class Element>
void LatticeGaussSampUtility<Element>::ZSampleSigma2x2(const Field2n& a, const Field2n& b, const Field2n& d,
                                                       const Matrix<Field2n>& c, const typename Element::DggType& dgg,
                                                       std::shared_ptr<Matrix<int64_t>> q) {

template <class Element>
void LatticeGaussSampUtility<Element>::SampleMat(const Matrix<Field2n>& A, const Matrix<Field2n>& B,
                                                 const Matrix<Field2n>& D, const Matrix<Field2n>& C,
                                                 const typename Element::DggType& dgg,
// representation c is in Format::COEFFICIENT representation
template <class Element>
std::shared_ptr<Matrix<int64_t>> LatticeGaussSampUtility<Element>::ZSampleF(const Field2n& f, const Field2n& c,
                                                                            const typename Element::DggType& dgg,
                                                                            size_t n) {
// https://eprint.iacr.org/2017/844.pdf
template <class Element>
Matrix<int32_t> LatticeGaussSampUtility<Element>::Permute(Matrix<int32_t>* p) {
    int evenPtr = 0;
    int oddPtr  = p->GetRows() / 2;
// https://eprint.iacr.org/2017/844.pdf
template <class Element>
void LatticeGaussSampUtility<Element>::InversePermute(std::shared_ptr<Matrix<int64_t>> p) {
    // a vector of int64_t is used for intermediate storage because it is faster
    // than a Matrix of unique pointers to int64_t


//========================================
//===== File: ./src/core/include/lattice/field2n.h =====
//========================================

namespace lbcrypto {
/**
 * @class Field2n
 * @brief A class to represent field elements with power-of-2 dimension.
 */
class Field2n : public std::vector<std::complex<double>>, public Serializable {
private:
    // Format of the field element
    Format format{Format::COEFFICIENT};

public:
    /**
   * @brief Default Constructor
   */

    explicit Field2n(Format f) : format(f) {}

    /**
   * @brief Constructor for field element
   */
    explicit Field2n(const Poly& element);

    /**
   * @brief Constructor from ring element
   */
    explicit Field2n(const NativePoly& element);

    /**
   * @brief Constructor from DCRTPoly ring element
   */
    explicit Field2n(const DCRTPoly& element);

    /**
   * @brief Constructor from a ring element matrix
   */
    explicit Field2n(const Matrix<int64_t>& element);

    /**
   * @brief Method for getting the format/representation of the element

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<std::vector<std::complex<double>>>(this));
        ar(::cereal::make_nvp("f", format));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/core/include/lattice/field2n-impl.h =====
//========================================

namespace lbcrypto {

// Constructor from ring element
Field2n::Field2n(const Poly& element) : format(Format::COEFFICIENT) {
            this->std::vector<std::complex<double>>::push_back(
                static_cast<double>(static_cast<int64_t>(-1 * (element.GetModulus() - element[i]).ConvertToInt())));
        else
            this->std::vector<std::complex<double>>::push_back(
                static_cast<double>(static_cast<int64_t>(element[i].ConvertToInt())));
    }
}

            this->std::vector<std::complex<double>>::push_back(
                static_cast<double>(static_cast<int64_t>(-1 * (element.GetModulus() - element[i]).ConvertToInt())));
        else
            this->std::vector<std::complex<double>>::push_back(
                static_cast<double>(static_cast<int64_t>(element[i].ConvertToInt())));
    }
}

            this->std::vector<std::complex<double>>::push_back(
                static_cast<double>(static_cast<int64_t>(-1 * (element.GetModulus() - element[i]).ConvertToInt())));
        else
            this->std::vector<std::complex<double>>::push_back(
                static_cast<double>(static_cast<int64_t>(element[i].ConvertToInt())));
    }
}



//========================================
//===== File: ./src/core/include/lattice/hal/dcrtpoly-interface.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Ideal lattice for the double-CRT interface representation.

template <typename DerivedType, typename BigVecType, typename LilVecType,
          template <typename LVT> typename RNSContainerType>
class DCRTPolyInterface : public ILElement<DerivedType, BigVecType> {
public:
    using BigIntType    = typename BigVecType::Integer;
    using Params        = ILDCRTParams<BigIntType>;
    using LilIntType    = typename LilVecType::Integer;
   */
    static std::function<DerivedType()> Allocator(const std::shared_ptr<Params>& params, Format format) {
        return [=]() {
            return DerivedType(params, format, true);
        };
   */
    static std::function<DerivedType()> MakeDiscreteGaussianCoefficientAllocator(const std::shared_ptr<Params>& params,
                                                                                 Format resultFormat, double stddev) {
        return [=]() {
            DggType dgg(stddev);
   */
    static std::function<DerivedType()> MakeDiscreteUniformAllocator(const std::shared_ptr<Params>& params,
                                                                     Format format) {
        return [=]() {
            DugType dug;
   */
    virtual DerivedType Negate() const = 0;

    DerivedType& operator+=(const BigIntType& rhs) override = 0;
    virtual DerivedType& operator+=(const LilIntType& rhs)  = 0;

    /**
   * @brief Performs a subtraction operation and returns the result.
    DerivedType& operator-=(const BigIntType& rhs) override = 0;
    virtual DerivedType& operator-=(const LilIntType& rhs)  = 0;

    /**
   * @brief Performs a multiplication operation and returns the result.
    DerivedType& operator*=(const BigIntType& rhs) override = 0;
    virtual DerivedType& operator*=(const LilIntType& rhs)  = 0;

    /**
   * @brief Performs a multiplication operation and returns the result.
   */
    virtual void SetValuesToZero() = 0;

    /**
   * @brief Sets values with a different modulus
   */
    virtual void SetValuesModSwitch(const DerivedType& element, const NativeInteger& modulus) = 0;

    /**
   * @brief Adds "1" to every entry in every tower.
   */
    virtual void DropLastElement() = 0;

    /**
   * @brief Drops the last i elements in the double-CRT representation.
   */
    virtual void DropLastElements(size_t i) = 0;

    /**
   * @brief Drops the last element in the double-CRT representation and scales
   */
    virtual void DropLastElementAndScale(const std::vector<NativeInteger>& QlQlInvModqlDivqlModq,
                                         const std::vector<NativeInteger>& qlInvModq) = 0;

    /**
   */
    virtual void ModReduce(const NativeInteger& t, const std::vector<NativeInteger>& tModqPrecon,
                           const NativeInteger& negtInvModq, const NativeInteger& negtInvModqPrecon,
                           const std::vector<NativeInteger>& qlInvModq,
                           const std::vector<NativeInteger>& qlInvModqPrecon) = 0;
   */
    virtual PolyLargeType CRTInterpolate() const = 0;

    virtual TowerType DecryptionCRTInterpolate(PlaintextModulus ptm) const = 0;

    /**
   * @brief If the values are small enough this is used for efficiency
   */
    virtual TowerType ToNativePoly() const = 0;

    /**
   * @brief Interpolates the DCRTPoly to a Poly based on the Chinese Remainder
   */
    virtual PolyLargeType CRTInterpolateIndex(usint i) const = 0;

    /**
   * @brief Computes and returns the product of primes in the current moduli
   */
    virtual BigIntType GetWorkingModulus() const = 0;

    /**
   * @brief Returns the element parameters for DCRTPoly elements in an extended
   */
    virtual std::shared_ptr<Params> GetExtendedCRTBasis(const std::shared_ptr<Params>& paramsP) const = 0;

    virtual void TimesQovert(const std::shared_ptr<Params>& paramsQ, const std::vector<NativeInteger>& tInvModq,
                             const NativeInteger& t, const NativeInteger& NegQModt,
                             const NativeInteger& NegQModtPrecon) = 0;

   */
    virtual DerivedType ApproxSwitchCRTBasis(const std::shared_ptr<Params>& paramsQ,
                                             const std::shared_ptr<Params>& paramsP,
                                             const std::vector<NativeInteger>& QHatInvModq,
                                             const std::vector<NativeInteger>& QHatInvModqPrecon,
   */
    virtual void ApproxModUp(const std::shared_ptr<Params>& paramsQ, const std::shared_ptr<Params>& paramsP,
                             const std::shared_ptr<Params>& paramsQP, const std::vector<NativeInteger>& QHatInvModq,
                             const std::vector<NativeInteger>& QHatInvModqPrecon,
                             const std::vector<std::vector<NativeInteger>>& QHatModp,
   */
    virtual DerivedType ApproxModDown(
        const std::shared_ptr<Params>& paramsQ, const std::shared_ptr<Params>& paramsP,
        const std::vector<NativeInteger>& PInvModq, const std::vector<NativeInteger>& PInvModqPrecon,
        const std::vector<NativeInteger>& PHatInvModp, const std::vector<NativeInteger>& PHatInvModpPrecon,
   */
    virtual DerivedType SwitchCRTBasis(const std::shared_ptr<Params>& paramsP,
                                       const std::vector<NativeInteger>& QHatInvModq,
                                       const std::vector<NativeInteger>& QHatInvModqPrecon,
                                       const std::vector<std::vector<NativeInteger>>& QHatModp,
   */
    virtual void ExpandCRTBasis(const std::shared_ptr<Params>& paramsQP, const std::shared_ptr<Params>& paramsP,
                                const std::vector<NativeInteger>& QHatInvModq,
                                const std::vector<NativeInteger>& QHatInvModqPrecon,
                                const std::vector<std::vector<NativeInteger>>& QHatModp,
   */
    virtual void ExpandCRTBasisReverseOrder(const std::shared_ptr<Params>& paramsQP,
                                            const std::shared_ptr<Params>& paramsP,
                                            const std::vector<NativeInteger>& QHatInvModq,
                                            const std::vector<NativeInteger>& QHatInvModqPrecon,

    struct CRTBasisExtensionPrecomputations {
        // TODO (dsuponit) and (pascoec): make the data members private to enforce their constantness and add getters.
        std::shared_ptr<Params> paramsQlPl;
        std::shared_ptr<Params> paramsPl;
    };
    typedef struct CRTBasisExtensionPrecomputations CRTBasisExtensionPrecomputations;

    virtual void FastExpandCRTBasisPloverQ(const CRTBasisExtensionPrecomputations& precomputed) = 0;

    virtual void ExpandCRTBasisQlHat(const std::shared_ptr<Params>& paramsQ,
                                     const std::vector<NativeInteger>& QlHatModq,
                                     const std::vector<NativeInteger>& QlHatModqPrecon, const usint sizeQ) = 0;

   */
    virtual TowerType ScaleAndRound(const NativeInteger& t, const std::vector<NativeInteger>& tQHatInvModqDivqModt,
                                    const std::vector<NativeInteger>& tQHatInvModqDivqModtPrecon,
                                    const std::vector<NativeInteger>& tQHatInvModqBDivqModt,
                                    const std::vector<NativeInteger>& tQHatInvModqBDivqModtPrecon,
   */
    virtual DerivedType ApproxScaleAndRound(const std::shared_ptr<Params>& paramsP,
                                            const std::vector<std::vector<NativeInteger>>& tPSHatInvModsDivsModp,
                                            const std::vector<DoubleNativeInt>& modpBarretMu) const = 0;

   */
    virtual DerivedType ScaleAndRound(const std::shared_ptr<Params>& paramsOutput,
                                      const std::vector<std::vector<NativeInteger>>& tOSHatInvModsDivsModo,
                                      const std::vector<double>& tOSHatInvModsDivsFrac,
                                      const std::vector<DoubleNativeInt>& modoBarretMu) const = 0;
   */
    virtual TowerType ScaleAndRound(const std::vector<NativeInteger>& moduliQ, const NativeInteger& t,
                                    const NativeInteger& tgamma, const std::vector<NativeInteger>& tgammaQHatModq,
                                    const std::vector<NativeInteger>& tgammaQHatModqPrecon,
                                    const std::vector<NativeInteger>& negInvqModtgamma,
   */
    virtual void ScaleAndRoundPOverQ(const std::shared_ptr<Params>& paramsQ,
                                     const std::vector<NativeInteger>& pInvModq) = 0;

    /**
   */
    virtual void FastBaseConvqToBskMontgomery(
        const std::shared_ptr<Params>& paramsQBsk, const std::vector<NativeInteger>& moduliQ,
        const std::vector<NativeInteger>& moduliBsk, const std::vector<DoubleNativeInt>& modbskBarrettMu,
        const std::vector<NativeInteger>& mtildeQHatInvModq, const std::vector<NativeInteger>& mtildeQHatInvModqPrecon,
   */
    virtual void FastRNSFloorq(
        const NativeInteger& t, const std::vector<NativeInteger>& moduliQ, const std::vector<NativeInteger>& moduliBsk,
        const std::vector<DoubleNativeInt>& modbskBarrettMu, const std::vector<NativeInteger>& tQHatInvModq,
        const std::vector<NativeInteger>& tQHatInvModqPrecon, const std::vector<std::vector<NativeInteger>>& QHatModbsk,
   */
    virtual void FastBaseConvSK(
        const std::shared_ptr<Params>& paramsQ, const std::vector<DoubleNativeInt>& modqBarrettMu,
        const std::vector<NativeInteger>& moduliBsk, const std::vector<DoubleNativeInt>& modbskBarrettMu,
        const std::vector<NativeInteger>& BHatInvModb, const std::vector<NativeInteger>& BHatInvModbPrecon,
   */
    virtual void OverrideFormat(const Format f) = 0;

    /**
   * @brief Switch modulus and adjust the values
   */
    virtual void SwitchModulusAtIndex(size_t index, const BigIntType& modulus, const BigIntType& rootOfUnity) = 0;

    /**
   * @brief Determines if inverse exists

protected:
    /**
   * @brief ostream operator
   * @param os the input preceding output stream


//========================================
//===== File: ./src/core/include/lattice/hal/default/dcrtpoly.h =====
//========================================

namespace lbcrypto {

template <typename VecType>
class DCRTPolyImpl final : public DCRTPolyInterface<DCRTPolyImpl<VecType>, VecType, NativeVector, PolyImpl> {
public:
    using Vector                = VecType;
    using Integer               = typename VecType::Integer;
    using Params                = ILDCRTParams<Integer>;

    explicit DCRTPolyImpl(const std::vector<PolyType>& elements);

    DCRTPolyImpl(const std::shared_ptr<Params>& params, Format format = Format::EVALUATION,
                 bool initializeElementToZero = false) noexcept

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("v", m_vectors));
        ar(::cereal::make_nvp("f", m_format));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +

    static const std::string GetElementName() {
        return "DCRTPolyImpl";
    }


    static uint32_t SerializedVersion() {
        return 1;
    }


protected:
    std::shared_ptr<Params> m_params{std::make_shared<DCRTPolyImpl::Params>()};
    Format m_format{Format::EVALUATION};
    std::vector<PolyType> m_vectors;


//========================================
//===== File: ./src/core/include/lattice/hal/default/dcrtpoly-impl.h =====
//========================================

namespace lbcrypto {

template <typename VecType>
DCRTPolyImpl<VecType>::DCRTPolyImpl(const PolyLargeType& rhs,
                                    const std::shared_ptr<DCRTPolyImpl::Params>& params) noexcept
    : DCRTPolyImpl<VecType>::DCRTPolyImpl(params, rhs.GetFormat(), true) {

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator=(const PolyLargeType& rhs) noexcept {
    m_vectors.clear();
    m_vectors.reserve(m_params->GetParams().size());

template <typename VecType>
DCRTPolyImpl<VecType>::DCRTPolyImpl(const PolyType& rhs, const std::shared_ptr<DCRTPolyImpl::Params>& params) noexcept
    : m_params{params}, m_format{rhs.GetFormat()}, m_vectors(params->GetParams().size(), rhs) {
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator=(const PolyType& rhs) noexcept {
    m_vectors.clear();
    m_vectors.reserve(m_params->GetParams().size());
 * The params and format for the DCRTPolyImpl will be derived from the towers */
template <typename VecType>
DCRTPolyImpl<VecType>::DCRTPolyImpl(const std::vector<DCRTPolyImpl::PolyType>& towers)
    : m_params{nullptr}, m_format{towers[0].GetFormat()}, m_vectors(towers) {
    std::vector<std::shared_ptr<ILNativeParams>> parms;
 * random numbers. The algorithm to populate the towers can be seen below. */
template <typename VecType>
DCRTPolyImpl<VecType>::DCRTPolyImpl(const DggType& dgg, const std::shared_ptr<DCRTPolyImpl::Params>& dcrtParams,
                                    Format format)
    : m_params{dcrtParams}, m_format{format} {

template <typename VecType>
DCRTPolyImpl<VecType>::DCRTPolyImpl(DugType& dug, const std::shared_ptr<Params>& dcrtParams, Format format)
    : m_params{dcrtParams}, m_format{format} {
    m_vectors.reserve(m_params->GetParams().size());

template <typename VecType>
DCRTPolyImpl<VecType>::DCRTPolyImpl(const BugType& bug, const std::shared_ptr<Params>& dcrtParams, Format format)
    : m_params{dcrtParams}, m_format{format} {
    m_vectors.reserve(m_params->GetParams().size());

template <typename VecType>
DCRTPolyImpl<VecType>::DCRTPolyImpl(const TugType& tug, const std::shared_ptr<Params>& dcrtParams, Format format,
                                    uint32_t h)
    : m_params{dcrtParams}, m_format{format} {
                iltvs[j] = static_cast<NativeInteger::Integer>(p->GetModulus().ConvertToInt()) -
                           static_cast<NativeInteger::Integer>(k);
            }
            else {
                iltvs[j] = static_cast<NativeInteger::Integer>(k);

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::CloneWithNoise(const DiscreteGaussianGeneratorImpl<VecType>& dgg,
                                                            Format format) const {
    DCRTPolyImpl res(m_params, m_format);

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::CloneTowers(uint32_t startTower, uint32_t endTower) const {
    auto cycorder = m_params->GetCyclotomicOrder();
    auto params   = std::make_shared<Params>(cycorder, m_params->GetParamPartition(startTower, endTower));

template <typename VecType>
std::vector<DCRTPolyImpl<VecType>> DCRTPolyImpl<VecType>::BaseDecompose(usint baseBits, bool evalModeAnswer) const {
    auto bdV(CRTInterpolate().BaseDecompose(baseBits, false));
    std::vector<DCRTPolyImpl<VecType>> result;

template <typename VecType>
std::vector<DCRTPolyImpl<VecType>> DCRTPolyImpl<VecType>::CRTDecompose(uint32_t baseBits) const {
    DCRTPolyImpl<VecType> cp(*this);
    cp.SwitchFormat();

template <typename VecType>
std::vector<DCRTPolyImpl<VecType>> DCRTPolyImpl<VecType>::PowersOfBase(usint baseBits) const {
    // prepare for the calculations by gathering a big integer version of each of the little moduli
    std::vector<Integer> mods;

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::AutomorphismTransform(uint32_t i) const {
    DCRTPolyImpl<VecType> result;
    result.m_params = m_params;

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::AutomorphismTransform(uint32_t i, const std::vector<uint32_t>& vec) const {
    DCRTPolyImpl<VecType> result;
    result.m_params = m_params;

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::MultiplicativeInverse() const {
    DCRTPolyImpl<VecType> tmp(m_params, m_format);
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Negate() const {
    DCRTPolyImpl<VecType> tmp(m_params, m_format);
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::operator-() const {
    return DCRTPolyImpl<VecType>(m_params, m_format, true) -= *this;
}

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Minus(const DCRTPolyImpl& rhs) const {
    if (m_vectors.size() != rhs.m_vectors.size())
        OPENFHE_THROW("tower size mismatch; cannot subtract");

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator+=(const DCRTPolyImpl& rhs) {
    size_t size{m_vectors.size()};
#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator+=(const Integer& rhs) {
    NativeInteger val{rhs};
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator+=(const NativeInteger& rhs) {
    size_t size{m_vectors.size()};
#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator-=(const DCRTPolyImpl& rhs) {
    size_t size{m_vectors.size()};
#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator-=(const Integer& rhs) {
    NativeInteger val{rhs};
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator-=(const NativeInteger& rhs) {
    size_t size{m_vectors.size()};
#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))

template <typename VecType>
bool DCRTPolyImpl<VecType>::operator==(const DCRTPolyImpl& rhs) const {
    return ((m_format == rhs.m_format) && (m_params->GetCyclotomicOrder() == rhs.m_params->GetCyclotomicOrder()) &&
            (m_params->GetModulus() == rhs.m_params->GetModulus()) && (m_vectors.size() == rhs.m_vectors.size()) &&

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator=(std::initializer_list<uint64_t> rhs) noexcept {
    static constexpr DCRTPolyImpl::PolyType::Integer ZERO(0);
    const size_t llen = rhs.size();
    const size_t vlen = m_params->GetRingDimension();
    for (auto& v : m_vectors) {

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator=(std::initializer_list<std::string> rhs) noexcept {
    static constexpr DCRTPolyImpl::PolyType::Integer ZERO(0);
    const size_t llen = rhs.size();
    const size_t vlen = m_params->GetRingDimension();
    for (auto& v : m_vectors) {
// Used only inside a Matrix object; so an allocator already initializes the values
template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator=(uint64_t val) noexcept {
    for (auto& v : m_vectors)
        v = val;
// Used only inside a Matrix object; so an allocator already initializes the values
template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator=(const std::vector<int64_t>& val) noexcept {
    for (auto& v : m_vectors) {
        if (v.IsEmpty()) {
// Used only inside a Matrix object; so an allocator already initializes the values
template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator=(const std::vector<int32_t>& val) noexcept {
    for (auto& v : m_vectors) {
        if (v.IsEmpty()) {

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Plus(const Integer& rhs) const {
    NativeInteger val{rhs};
    DCRTPolyImpl<VecType> tmp(m_params, m_format);

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Plus(const std::vector<Integer>& crtElement) const {
    DCRTPolyImpl<VecType> tmp(m_params, m_format);
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Minus(const Integer& rhs) const {
    NativeInteger val{rhs};
    DCRTPolyImpl<VecType> tmp(m_params, m_format);

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Minus(const std::vector<Integer>& crtElement) const {
    DCRTPolyImpl<VecType> tmp(m_params, m_format);
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Times(const Integer& rhs) const {
    NativeInteger val{rhs};
    DCRTPolyImpl<VecType> tmp(m_params, m_format);

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Times(NativeInteger::SignedNativeInt rhs) const {
    DCRTPolyImpl<VecType> tmp(m_params, m_format);
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Times(const std::vector<Integer>& crtElement) const {
    DCRTPolyImpl<VecType> tmp(m_params, m_format);
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::Times(const std::vector<NativeInteger>& rhs) const {
    if (m_vectors.size() != rhs.size())
        OPENFHE_THROW("tower size mismatch; cannot multiply");

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::TimesNoCheck(const std::vector<NativeInteger>& rhs) const {
    size_t vecSize = m_vectors.size() < rhs.size() ? m_vectors.size() : rhs.size();
    DCRTPolyImpl<VecType> tmp(m_params, m_format);

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator*=(const Integer& rhs) {
    NativeInteger val{rhs};
    size_t size{m_vectors.size()};

template <typename VecType>
DCRTPolyImpl<VecType>& DCRTPolyImpl<VecType>::operator*=(const NativeInteger& rhs) {
    size_t size{m_vectors.size()};
#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))

template <typename VecType>
void DCRTPolyImpl<VecType>::SetValuesToZero() {
    size_t size{m_vectors.size()};
    for (size_t i = 0; i < size; ++i)

template <typename VecType>
void DCRTPolyImpl<VecType>::SetValuesModSwitch(const DCRTPolyImpl& element, const NativeInteger& modulus) {
    size_t N(m_params->GetRingDimension());
    if (N != element.GetRingDimension())

template <typename VecType>
void DCRTPolyImpl<VecType>::AddILElementOne() {
    if (m_format != Format::EVALUATION)
        OPENFHE_THROW(std::string(__func__) + ": only available in COEFFICIENT format.");

template <typename VecType>
bool DCRTPolyImpl<VecType>::IsEmpty() const {
    for (auto& v : m_vectors) {
        if (!v.IsEmpty())

template <typename VecType>
void DCRTPolyImpl<VecType>::DropLastElement() {
    if (m_vectors.size() == 0)
        OPENFHE_THROW(std::string(__func__) + ": Input has no elements to drop.");

template <typename VecType>
void DCRTPolyImpl<VecType>::DropLastElements(size_t i) {
    if (m_vectors.size() <= i)
        OPENFHE_THROW(std::string(__func__) + ": Too few towers in input.");
// used for CKKS rescaling
template <typename VecType>
void DCRTPolyImpl<VecType>::DropLastElementAndScale(const std::vector<NativeInteger>& QlQlInvModqlDivqlModq,
                                                    const std::vector<NativeInteger>& qlInvModq) {
    auto lastPoly(m_vectors.back());
*/
template <typename VecType>
void DCRTPolyImpl<VecType>::ModReduce(const NativeInteger& t, const std::vector<NativeInteger>& tModqPrecon,
                                      const NativeInteger& negtInvModq, const NativeInteger& negtInvModqPrecon,
                                      const std::vector<NativeInteger>& qlInvModq,
 */
template <typename VecType>
typename DCRTPolyImpl<VecType>::PolyLargeType DCRTPolyImpl<VecType>::CRTInterpolate() const {
    if (m_format != Format::COEFFICIENT)
        OPENFHE_THROW(std::string(__func__) + ": Only available in COEFFICIENT format.");
 */
template <typename VecType>
typename DCRTPolyImpl<VecType>::PolyLargeType DCRTPolyImpl<VecType>::CRTInterpolateIndex(usint i) const {
    if (m_format != Format::COEFFICIENT)
        OPENFHE_THROW(std::string(__func__) + ": Only available in COEFFICIENT format.");

template <typename VecType>
typename DCRTPolyImpl<VecType>::PolyType DCRTPolyImpl<VecType>::DecryptionCRTInterpolate(PlaintextModulus ptm) const {
    return this->CRTInterpolate().DecryptionCRTInterpolate(ptm);
}

template <typename VecType>
typename DCRTPolyImpl<VecType>::PolyType DCRTPolyImpl<VecType>::ToNativePoly() const {
    return this->CRTInterpolate().ToNativePoly();
}

template <typename VecType>
typename VecType::Integer DCRTPolyImpl<VecType>::GetWorkingModulus() const {
    typename VecType::Integer modulusQ = 1;
    for (const auto& p : m_params->GetParams())

template <typename VecType>
std::shared_ptr<typename DCRTPolyImpl<VecType>::Params> DCRTPolyImpl<VecType>::GetExtendedCRTBasis(
    const std::shared_ptr<Params>& paramsP) const {
    size_t sizeQ  = m_vectors.size();

template <typename VecType>
void DCRTPolyImpl<VecType>::TimesQovert(const std::shared_ptr<Params>& paramsQ,
                                        const std::vector<NativeInteger>& tInvModq, const NativeInteger& t,
                                        const NativeInteger& NegQModt, const NativeInteger& NegQModtPrecon) {

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ApproxSwitchCRTBasis(
    const std::shared_ptr<Params>& paramsQ, const std::shared_ptr<Params>& paramsP,
    const std::vector<NativeInteger>& QHatInvModq, const std::vector<NativeInteger>& QHatInvModqPrecon,

template <typename VecType>
void DCRTPolyImpl<VecType>::ApproxModUp(const std::shared_ptr<Params>& paramsQ, const std::shared_ptr<Params>& paramsP,
                                        const std::shared_ptr<Params>& paramsQP,
                                        const std::vector<NativeInteger>& QHatInvModq,

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ApproxModDown(
    const std::shared_ptr<Params>& paramsQ, const std::shared_ptr<Params>& paramsP,
    const std::vector<NativeInteger>& PInvModq, const std::vector<NativeInteger>& PInvModqPrecon,

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::SwitchCRTBasis(const std::shared_ptr<Params>& paramsP,
                                                            const std::vector<NativeInteger>& QHatInvModq,
                                                            const std::vector<NativeInteger>& QHatInvModqPrecon,

template <typename VecType>
void DCRTPolyImpl<VecType>::ExpandCRTBasis(
    const std::shared_ptr<Params>& paramsQP, const std::shared_ptr<Params>& paramsP,
    const std::vector<NativeInteger>& QHatInvModq, const std::vector<NativeInteger>& QHatInvModqPrecon,

template <typename VecType>
void DCRTPolyImpl<VecType>::ExpandCRTBasisReverseOrder(
    const std::shared_ptr<Params>& paramsQP, const std::shared_ptr<Params>& paramsP,
    const std::vector<NativeInteger>& QHatInvModq, const std::vector<NativeInteger>& QHatInvModqPrecon,
// TODO: revisit after issue #237 is resolved
template <typename VecType>
void DCRTPolyImpl<VecType>::FastExpandCRTBasisPloverQ(const Precomputations& precomputed) {
#if defined(HAVE_INT128) && NATIVEINT == 64
    auto partPl =

template <typename VecType>
void DCRTPolyImpl<VecType>::ExpandCRTBasisQlHat(const std::shared_ptr<Params>& paramsQ,
                                                const std::vector<NativeInteger>& QlHatModq,
                                                const std::vector<NativeInteger>& QlHatModqPrecon, const usint sizeQ) {

template <typename VecType>
typename DCRTPolyImpl<VecType>::PolyType DCRTPolyImpl<VecType>::ScaleAndRound(
    const NativeInteger& t, const std::vector<NativeInteger>& tQHatInvModqDivqModt,
    const std::vector<NativeInteger>& tQHatInvModqDivqModtPrecon,

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ApproxScaleAndRound(
    const std::shared_ptr<Params>& paramsP, const std::vector<std::vector<NativeInteger>>& tPSHatInvModsDivsModp,
    const std::vector<DoubleNativeInt>& modpBarretMu) const {

template <typename VecType>
DCRTPolyImpl<VecType> DCRTPolyImpl<VecType>::ScaleAndRound(
    const std::shared_ptr<Params>& paramsOutput, const std::vector<std::vector<NativeInteger>>& tOSHatInvModsDivsModo,
    const std::vector<double>& tOSHatInvModsDivsFrac, const std::vector<DoubleNativeInt>& modoBarretMu) const {

template <typename VecType>
typename DCRTPolyImpl<VecType>::PolyType DCRTPolyImpl<VecType>::ScaleAndRound(
    const std::vector<NativeInteger>& moduliQ, const NativeInteger& t, const NativeInteger& tgamma,
    const std::vector<NativeInteger>& tgammaQHatModq, const std::vector<NativeInteger>& tgammaQHatModqPrecon,

template <typename VecType>
void DCRTPolyImpl<VecType>::ScaleAndRoundPOverQ(const std::shared_ptr<Params>& paramsQ,
                                                const std::vector<NativeInteger>& pInvModq) {
    m_params = paramsQ;
// Output: dcrtpoly in base QBsk = {B U msk}
template <typename VecType>
void DCRTPolyImpl<VecType>::FastBaseConvqToBskMontgomery(
    const std::shared_ptr<Params>& paramsQBsk, const std::vector<NativeInteger>& moduliQ,
    const std::vector<NativeInteger>& moduliBsk, const std::vector<DoubleNativeInt>& modbskBarrettMu,
// Output: approximateFloor(t/q*poly) in basis Bsk
template <typename VecType>
void DCRTPolyImpl<VecType>::FastRNSFloorq(
    const NativeInteger& t, const std::vector<NativeInteger>& moduliQ, const std::vector<NativeInteger>& moduliBsk,
    const std::vector<DoubleNativeInt>& modbskBarrettMu, const std::vector<NativeInteger>& tQHatInvModq,
// Output: poly in basis q
template <typename VecType>
void DCRTPolyImpl<VecType>::FastBaseConvSK(
    const std::shared_ptr<Params>& paramsQ, const std::vector<DoubleNativeInt>& modqBarrettMu,
    const std::vector<NativeInteger>& moduliBsk, const std::vector<DoubleNativeInt>& modbskBarrettMu,

template <typename VecType>
void DCRTPolyImpl<VecType>::SwitchFormat() {
    m_format = (m_format == Format::COEFFICIENT) ? Format::EVALUATION : Format::COEFFICIENT;
    size_t size{m_vectors.size()};

template <typename VecType>
void DCRTPolyImpl<VecType>::SwitchModulusAtIndex(size_t index, const Integer& modulus, const Integer& rootOfUnity) {
    if (index >= m_vectors.size()) {
        std::string errMsg;

template <typename VecType>
bool DCRTPolyImpl<VecType>::InverseExists() const {
    for (const auto& v : m_vectors) {
        if (!v.InverseExists())

template <typename VecType>
std::ostream& operator<<(std::ostream& os, const DCRTPolyImpl<VecType>& p) {
    // TODO(gryan): Standardize this printing so it is like other poly's
    os << "---START PRINT DOUBLE CRT-- WITH SIZE" << p.m_vectors.size() << std::endl;


//========================================
//===== File: ./src/core/include/lattice/hal/default/ildcrtparams.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Parameters for array of ideal lattices (used for Double-CRT).
 */
template <typename IntType>
class ILDCRTParams final : public ElemParams<IntType> {
public:
    using Integer        = IntType;
    using ILNativeParams = ILParamsImpl<NativeInteger>;

   */
    explicit ILDCRTParams(uint32_t corder = 0, uint32_t depth = 1, uint32_t bits = MAX_MODULUS_SIZE)
        : ElemParams<IntType>(corder, 0) {
        if (corder == 0)
            return;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<ElemParams<IntType>>(this));
        ar(::cereal::make_nvp("p", m_params));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    std::ostream& doprint(std::ostream& out) const override {
        out << "ILDCRTParams ";
        ElemParams<IntType>::doprint(out);


//========================================
//===== File: ./src/core/include/lattice/hal/default/ilparams.h =====
//========================================

namespace lbcrypto {

/**
 * @class ILParamsImpl
 */
template <typename IntType>
class ILParamsImpl final : public ElemParams<IntType> {
public:
    using Integer = IntType;

    constexpr ILParamsImpl() : ElemParams<IntType>() {}
   */
    explicit ILParamsImpl(uint32_t order, uint32_t bits = MAX_MODULUS_SIZE)
        : ILParamsImpl<IntType>(order, LastPrime<IntType>(bits, order)) {}

    explicit ILParamsImpl(uint32_t order, const IntType& modulus)
        : ElemParams<IntType>(order, modulus, RootOfUnity<IntType>(order, modulus)) {}

    ILParamsImpl(uint32_t order, const IntType& modulus, const IntType& rootOfUnity)

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<ElemParams<IntType>>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion())
            OPENFHE_THROW("serialized object version " + std::to_string(version) +

    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    std::ostream& doprint(std::ostream& out) const override {
        out << "ILParams ";
        ElemParams<IntType>::doprint(out);


//========================================
//===== File: ./src/core/include/lattice/hal/default/poly.h =====
//========================================

namespace lbcrypto {

/**
 * @class PolyImpl
 */
template <typename VecType>
class PolyImpl final : public PolyInterface<PolyImpl<VecType>, VecType, PolyImpl> {
public:
    using Vector            = VecType;
    using Integer           = typename VecType::Integer;
    using Params            = ILParamsImpl<Integer>;

    template <typename T = VecType>
    PolyImpl(const PolyNative& rhs, Format format,
             typename std::enable_if_t<std::is_same_v<T, NativeVector>, bool> = true)
        : m_format{rhs.m_format},

    template <typename T = VecType>
    PolyImpl(const PolyNative& rhs, Format format,
             typename std::enable_if_t<!std::is_same_v<T, NativeVector>, bool> = true)
        : m_format{rhs.GetFormat()} {

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("v", m_values));
        ar(::cereal::make_nvp("f", m_format));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +

    static const std::string GetElementName() {
        return "PolyImpl";
    }


    static uint32_t SerializedVersion() {
        return 1;
    }

protected:
    Format m_format{Format::EVALUATION};
    std::shared_ptr<Params> m_params{nullptr};
    std::unique_ptr<VecType> m_values{nullptr};


//========================================
//===== File: ./src/core/include/lattice/hal/default/poly-impl.h =====
//========================================

namespace lbcrypto {

template <typename VecType>
PolyImpl<VecType>::PolyImpl(const DggType& dgg, const std::shared_ptr<PolyImpl::Params>& params, Format format)
    : m_format{Format::COEFFICIENT},
      m_params{params},

template <typename VecType>
PolyImpl<VecType>::PolyImpl(DugType& dug, const std::shared_ptr<PolyImpl::Params>& params, Format format)
    : m_format{format},
      m_params{params},

template <typename VecType>
PolyImpl<VecType>::PolyImpl(const BugType& bug, const std::shared_ptr<PolyImpl::Params>& params, Format format)
    : m_format{Format::COEFFICIENT},
      m_params{params},

template <typename VecType>
PolyImpl<VecType>::PolyImpl(const TugType& tug, const std::shared_ptr<PolyImpl::Params>& params, Format format,
                            uint32_t h)
    : m_format{Format::COEFFICIENT},

template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator=(const PolyImpl& rhs) noexcept {
    m_format = rhs.m_format;
    m_params = rhs.m_params;
// assumes that elements in rhs less than modulus?
template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator=(std::initializer_list<uint64_t> rhs) {
    static const Integer ZERO(0);
    const size_t llen = rhs.size();
    const size_t vlen = m_params->GetRingDimension();
    if (!m_values) {
// TODO: template with enable_if int64_t/int32_t
template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator=(const std::vector<int64_t>& rhs) {
    static const Integer ZERO(0);
    m_format = Format::COEFFICIENT;
    const size_t llen{rhs.size()};
    const size_t vlen{m_params->GetRingDimension()};

template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator=(const std::vector<int32_t>& rhs) {
    static const Integer ZERO(0);
    m_format = Format::COEFFICIENT;
    const size_t llen{rhs.size()};
    const size_t vlen{m_params->GetRingDimension()};

template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator=(std::initializer_list<std::string> rhs) {
    const size_t vlen = m_params->GetRingDimension();
    if (!m_values) {

template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator=(uint64_t val) {
    m_format = Format::EVALUATION;
    if (!m_values) {

template <typename VecType>
void PolyImpl<VecType>::SetValues(const VecType& values, Format format) {
    if (m_params->GetRootOfUnity() == Integer(0))
        OPENFHE_THROW("Polynomial has a 0 root of unity");

template <typename VecType>
void PolyImpl<VecType>::SetValues(VecType&& values, Format format) {
    if (m_params->GetRootOfUnity() == Integer(0))
        OPENFHE_THROW("Polynomial has a 0 root of unity");

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::Plus(const typename VecType::Integer& element) const {
    PolyImpl<VecType> tmp(m_params, m_format);
    if (m_format == Format::COEFFICIENT)

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::Minus(const typename VecType::Integer& element) const {
    PolyImpl<VecType> tmp(m_params, m_format);
    tmp.SetValues((*m_values).ModSub(element), m_format);

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::Times(const typename VecType::Integer& element) const {
    PolyImpl<VecType> tmp(m_params, m_format);
    tmp.SetValues((*m_values).ModMul(element), m_format);

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::Times(NativeInteger::SignedNativeInt element) const {
    PolyImpl<VecType> tmp(m_params, m_format);
    Integer q{m_params->GetModulus()};

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::Minus(const PolyImpl& rhs) const {
    PolyImpl<VecType> tmp(m_params, m_format);
    tmp.SetValues((*m_values).ModSub(*rhs.m_values), m_format);

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::MultiplyAndRound(const typename VecType::Integer& p,
                                                      const typename VecType::Integer& q) const {
    PolyImpl<VecType> tmp(m_params, m_format);

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::DivideAndRound(const typename VecType::Integer& q) const {
    PolyImpl<VecType> tmp(m_params, m_format);
    tmp.SetValues((*m_values).DivideAndRound(q), m_format);
// TODO: this will return vec of 0s for BigIntegers
template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::Negate() const {
    //  UnitTestBFVrnsCRTOperations.cpp line 316 throws with this uncommented
    //    if (m_format != Format::EVALUATION)

template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator+=(const PolyImpl& element) {
    if (!m_values)
        m_values = std::make_unique<VecType>(m_params->GetRingDimension(), m_params->GetModulus());

template <typename VecType>
PolyImpl<VecType>& PolyImpl<VecType>::operator-=(const PolyImpl& element) {
    if (!m_values)
        m_values = std::make_unique<VecType>(m_params->GetRingDimension(), m_params->GetModulus());

template <typename VecType>
void PolyImpl<VecType>::AddILElementOne() {
    static const Integer ONE(1);
    usint vlen{m_params->GetRingDimension()};
    const auto& m{m_params->GetModulus()};
    for (usint i = 0; i < vlen; ++i)

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::AutomorphismTransform(uint32_t k) const {
    uint32_t n{m_params->GetRingDimension()};
    uint32_t m{m_params->GetCyclotomicOrder()};

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::AutomorphismTransform(uint32_t k, const std::vector<uint32_t>& precomp) const {
    if ((m_format != Format::EVALUATION) || (m_params->GetRingDimension() != (m_params->GetCyclotomicOrder() >> 1)))
        OPENFHE_THROW("Automorphism Poly Format not EVALUATION or not power-of-two");

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::MultiplicativeInverse() const {
    PolyImpl<VecType> tmp(m_params, m_format);
    tmp.SetValues((*m_values).ModInverse(), m_format);

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::ModByTwo() const {
    PolyImpl<VecType> tmp(m_params, m_format);
    tmp.SetValues((*m_values).ModByTwo(), m_format);

template <typename VecType>
PolyImpl<VecType> PolyImpl<VecType>::Mod(const Integer& modulus) const {
    PolyImpl<VecType> tmp(m_params, m_format);
    tmp.SetValues((*m_values).Mod(modulus), m_format);

template <typename VecType>
void PolyImpl<VecType>::SwitchModulus(const Integer& modulus, const Integer& rootOfUnity, const Integer& modulusArb,
                                      const Integer& rootOfUnityArb) {
    if (m_values != nullptr) {

template <typename VecType>
void PolyImpl<VecType>::SwitchFormat() {
    const auto& co{m_params->GetCyclotomicOrder()};
    const auto& rd{m_params->GetRingDimension()};

template <typename VecType>
void PolyImpl<VecType>::ArbitrarySwitchFormat() {
    if (m_values == nullptr)
        OPENFHE_THROW("Poly switch format to empty values");

template <typename VecType>
std::ostream& operator<<(std::ostream& os, const PolyImpl<VecType>& p) {
    if (p.m_values != nullptr) {
        os << *(p.m_values);

template <typename VecType>
void PolyImpl<VecType>::MakeSparse(uint32_t wFactor) {
    static const Integer ZERO(0);
    if (m_values != nullptr) {
        uint32_t vlen{m_params->GetRingDimension()};
        for (uint32_t i = 0; i < vlen; ++i) {

template <typename VecType>
bool PolyImpl<VecType>::InverseExists() const {
    static const Integer ZERO(0);
    usint vlen{m_params->GetRingDimension()};
    for (usint i = 0; i < vlen; ++i) {
        if ((*m_values)[i] == ZERO)

template <typename VecType>
double PolyImpl<VecType>::Norm() const {
    usint vlen{m_params->GetRingDimension()};
    const auto& q{m_params->GetModulus()};
// TODO: optimize this
template <typename VecType>
std::vector<PolyImpl<VecType>> PolyImpl<VecType>::BaseDecompose(usint baseBits, bool evalModeAnswer) const {
    usint nBits = m_params->GetModulus().GetLengthForBase(2);


template <typename VecType>
std::vector<PolyImpl<VecType>> PolyImpl<VecType>::PowersOfBase(usint baseBits) const {
    static const Integer TWO(2);
    const auto& m{m_params->GetModulus()};
    usint nBits{m.GetLengthForBase(2)};
    usint nWindows{nBits / baseBits};

template <typename VecType>
typename PolyImpl<VecType>::PolyNative PolyImpl<VecType>::DecryptionCRTInterpolate(PlaintextModulus ptm) const {
    const PolyImpl<VecType> smaller(PolyImpl<VecType>::Mod(ptm));
    usint vlen{m_params->GetRingDimension()};

template <>
inline PolyImpl<NativeVector> PolyImpl<NativeVector>::ToNativePoly() const {
    return *this;
}


//========================================
//===== File: ./src/core/include/lattice/hal/elemparams.h =====
//========================================

namespace lbcrypto {

/**
 * @class ElemParams
 */
template <typename IntegerType>
class ElemParams : public Serializable {
public:
    constexpr ElemParams() = default;
    virtual ~ElemParams()  = default;

    /**
   * @brief Simple constructor method that takes as input root of unity, big
   */
    virtual bool operator==(const ElemParams<IntegerType>& other) const {
        return m_ringDimension == other.m_ringDimension && m_cyclotomicOrder == other.m_cyclotomicOrder &&
               m_ciphertextModulus == other.m_ciphertextModulus && m_rootOfUnity == other.m_rootOfUnity &&
               m_bigCiphertextModulus == other.m_bigCiphertextModulus && m_bigRootOfUnity == other.m_bigRootOfUnity;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("co", m_cyclotomicOrder));
        ar(::cereal::make_nvp("rd", m_ringDimension));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion())
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

protected:
    uint32_t m_ringDimension{0};
    uint32_t m_cyclotomicOrder{0};
    IntegerType m_ciphertextModulus{0};
   */
    virtual std::ostream& doprint(std::ostream& out) const {
        out << "[m=" << m_cyclotomicOrder << " n=" << m_ringDimension << " q=" << m_ciphertextModulus
            << " ru=" << m_rootOfUnity << " bigq=" << m_bigCiphertextModulus << " bigru=" << m_bigRootOfUnity << "]";
        return out;


//========================================
//===== File: ./src/core/include/lattice/hal/lat-backend.h =====
//========================================

namespace lbcrypto {

using ILNativeParams = ILParamsImpl<NativeInteger>;
using ILParams       = ILParamsImpl<BigInteger>;


//========================================
//===== File: ./src/core/include/lattice/hal/poly-interface.h =====
//========================================

namespace lbcrypto {

template <typename DerivedType, typename VecType, template <typename LVT> typename ContainerType>
class PolyInterface : public ILElement<DerivedType, VecType> {
public:
    using Vector     = VecType;
    using Integer    = typename VecType::Integer;
    using Params     = ILParamsImpl<Integer>;
   */
    virtual DerivedType Negate() const = 0;

    /**
   * @brief Unary minus on a element.
   */
    virtual void OverrideFormat(const Format f) = 0;

    /**
   * @brief Make DCRTPoly Sparse. Sets every index of each tower not equal to
   */
    virtual void SetValues(const VecType& values, Format format) = 0;
    virtual void SetValues(VecType&& values, Format format)      = 0;

    /**
   * @brief Sets all values of element to zero.
   */
    virtual void SetValuesToZero() = 0;
    virtual void SetValuesToMax()  = 0;

    /**
   * @brief Interpolates the DCRTPoly to an Poly based on the Chinese Remainder

    virtual PolyNative DecryptionCRTInterpolate(PlaintextModulus ptm) const = 0;

    /**
   * @brief If the values are small enough this is used for efficiency
   */
    virtual PolyNative ToNativePoly() const = 0;

    DerivedType Clone() const final {
        return DerivedType(this->GetDerived());

protected:
    /**
   * @brief ostream operator
   * @param os the input preceding output stream


//========================================
//===== File: ./src/core/include/lattice/ilelement.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Interface for ideal lattices
 */
template <typename Element, typename VecType>
class ILElement : public Serializable {
    using IntType = typename VecType::Integer;

public:
    /**
   * @brief Clone the object by making a copy of it and returning the copy
   * @return new Element
   */
    virtual Element Clone() const = 0;

    /**
   * @brief Clone the object, but have it contain nothing
   */
    virtual Element CloneEmpty() const = 0;

    /**
   * @brief Clones the element's parameters, leaves vector initialized to 0
   */
    virtual Element CloneParametersOnly() const = 0;

    /**
   * @brief Clones the element with parameters and with noise for the vector
   */
    virtual Element CloneWithNoise(const DiscreteGaussianGeneratorImpl<VecType>& dgg, Format format) const = 0;

    /**
   * @brief Standard destructor
   */
    virtual ~ILElement() = default;

    // Assignment operators
    /**
   */
    virtual const Element& operator=(const Element& rhs) = 0;
    /**
   * @brief Assignment operator that copies elements.
   * @param rhs
   */
    virtual const Element& operator=(Element&& rhs) = 0;
    /**
   * @brief Assignment operator that copies elements.
   * @param rhs
   */
    virtual const Element& operator=(std::initializer_list<uint64_t> rhs) = 0;

    // GETTERS
    /**
   */
    virtual Format GetFormat() const = 0;

    /**
   * @brief Get the length of the element.
   */
    virtual usint GetLength() const = 0;

    /**
   * @brief Get modulus of the element
   */
    virtual const IntType& GetModulus() const = 0;

    /**
   * @brief Get the values for the element
   */
    virtual const VecType& GetValues() const = 0;

    /**
   * @brief Get the cyclotomic order
   */
    virtual usint GetCyclotomicOrder() const = 0;

    /**
   * @brief Gets the Value in the Element that is At Index and returns it.
   */
    virtual IntType& at(usint i) {
        OPENFHE_THROW("at() not implemented");
    }
    virtual const IntType& at(usint i) const {
        OPENFHE_THROW("const at() not implemented");
    }
    virtual IntType& operator[](usint i) {
        OPENFHE_THROW("[] not implemented");
    }
    virtual const IntType& operator[](usint i) const {
        OPENFHE_THROW("const [] not implemented");
    }

   */
    virtual Element operator-() const = 0;

    /**
   * @brief Scalar addition - add an element to the first index only.
   */
    virtual Element Plus(const IntType& element) const = 0;

    /**
   * @brief Scalar subtraction - subtract an element frp, all entries.
   */
    virtual Element Minus(const IntType& element) const = 0;

    /**
   * @brief Scalar multiplication - multiply all entries.
   */
    virtual Element Times(const IntType& element) const = 0;

    /**
   * @brief Scalar multiplication - mulltiply by a signed integer
   */
    virtual Element Times(NativeInteger::SignedNativeInt element) const = 0;

    /**
   * @brief Performs an addition operation and returns the result.
   */
    virtual Element Plus(const Element& element) const = 0;

    /**
   * @brief Performs a subtraction operation and returns the result.
   */
    virtual Element Minus(const Element& element) const = 0;

    /**
   * @brief Performs a multiplication operation and returns the result.
   */
    virtual Element Times(const Element& element) const = 0;

    // overloaded op= operators
    /**
   */
    virtual const Element& operator+=(const IntType& element) = 0;

    /**
   * @brief Performs -= operation with a BigInteger and returns the result.
   */
    virtual const Element& operator-=(const IntType& element) = 0;

    /**
   * @brief Performs *= operation with a BigInteger and returns the result.
   */
    virtual const Element& operator*=(const IntType& element) = 0;

    /**
   * @brief Performs an addition operation and returns the result.
   */
    virtual const Element& operator+=(const Element& element) = 0;

    /**
   * @brief Performs an subtraction operation and returns the result.
   */
    virtual const Element& operator-=(const Element& element) = 0;

    /**
   * @brief Performs an multiplication operation and returns the result.
   */
    virtual const Element& operator*=(const Element& element) = 0;

    /**
   * @brief Equality operator.  Compares values of element to be compared to.
   */
    virtual bool operator==(const Element& element) const = 0;

    /**
   * @brief Inequality operator.  Compares values of element to be compared to.
   */
    virtual void AddILElementOne() = 0;

    /**
   * @brief Performs an automorphism transform operation and returns the result.
   */
    virtual Element AutomorphismTransform(uint32_t i) const = 0;

    /**
   * @brief Performs an automorphism transform operation using precomputed bit
   */
    virtual Element AutomorphismTransform(uint32_t i, const std::vector<uint32_t>& vec) const = 0;

    /**
   * @brief Transpose the ring element using the automorphism operation
   */
    virtual Element Transpose() const = 0;

    /**
   * @brief Write the element as \f$ \sum\limits{i=0}^{\lfloor {\log q/base}
   */
    virtual std::vector<Element> BaseDecompose(usint baseBits, bool evalModeAnswer) const = 0;

    /**
   * @brief Scalar division followed by rounding operation - operation on all
   */
    virtual Element DivideAndRound(const IntType& q) const = 0;

    /**
   * @brief Determines if inverse exists
   */
    virtual bool InverseExists() const = 0;

    /**
   * @brief Returns the infinity norm, basically the largest value in the ring
   */
    virtual double Norm() const = 0;

    /**
   * @brief Returns true if the vector is empty/ m_values==nullptr
   */
    virtual bool IsEmpty() const = 0;

    /**
   * @brief Make the element Sparse for SHE KeyGen operations.
   */
    virtual void MakeSparse(uint32_t wFactor) = 0;

    /**
   * @brief Calculate Element mod 2
   */
    virtual Element ModByTwo() const = 0;

    /**
   * @brief Calculate and return the Multiplicative Inverse of the element
   */
    virtual Element MultiplicativeInverse() const = 0;

    /**
   * @brief Scalar multiplication followed by division and rounding operation -
   */
    virtual Element MultiplyAndRound(const IntType& p, const IntType& q) const = 0;

    /**
   * @brief Calculate a vector of elements by raising the base element to
   */
    virtual std::vector<Element> PowersOfBase(usint baseBits) const = 0;

    /**
   * @brief Mod - perform a modulus operation.
   */
    virtual Element Mod(const IntType& modulus) const = 0;

    /**
   * @brief Switch modulus and adjust the values
   */
    virtual void SwitchModulus(const IntType& modulus, const IntType& rootOfUnity, const IntType& modulusArb,
                               const IntType& rootOfUnityArb) = 0;

    /**
   */
    virtual void SwitchFormat() = 0;

    /**
   * @brief Sets the format/representation of the element.


//========================================
//===== File: ./src/core/include/lattice/lat-hal.h =====
//========================================


//========================================
//===== File: ./src/core/include/lattice/matrix-lattice-impl.h =====
//========================================

namespace lbcrypto {

template <typename Element>
Matrix<typename Element::Integer> Rotate(Matrix<Element> const& inMat) {
    Matrix<Element> mat(inMat);
    mat.SetFormat(Format::COEFFICIENT);
 */
template <typename Element>
Matrix<typename Element::Vector> RotateVecResult(Matrix<Element> const& inMat) {
    Matrix<Element> mat(inMat);
    mat.SetFormat(Format::COEFFICIENT);

template <typename Element>
void Matrix<Element>::SetFormat(Format format) {
    if (data[0][0].GetFormat() != format)
        this->SwitchFormat();

template <typename Element>
void Matrix<Element>::SwitchFormat() {
    if (rows == 1) {
        // TODO: figure out why this is causing a segfault with GCC10
//  Convert from Z_q to [-q/2, q/2]
template <typename T>
Matrix<int32_t> ConvertToInt32(const Matrix<T>& input, const T& modulus) {
    size_t rows = input.GetRows();
    size_t cols = input.GetCols();

template <typename V>
Matrix<int32_t> ConvertToInt32(const Matrix<V>& input, const typename V::Integer& modulus) {
    size_t rows = input.GetRows();
    size_t cols = input.GetCols();


//========================================
//===== File: ./src/core/include/lattice/stdlatticeparms.h =====
//========================================

namespace lbcrypto {

// this is the representation of the standard lattice parameters defined in the
// Homomorphic Encryption Standard, as defined by

enum DistributionType {
    HEStd_uniform,
    HEStd_error,
    HEStd_ternary,

enum SecurityLevel {
    HEStd_128_classic,
    HEStd_192_classic,
    HEStd_256_classic,

class StdLatticeParm {
    DistributionType distType;
    usint ringDim;
    SecurityLevel minSecLev;
    // SecurityLevel enum is == the second index
    static std::map<usint, StdLatticeParm*> byRing[3][6];
    static std::map<usint, StdLatticeParm*> byLogQ[3][6];

    static std::vector<StdLatticeParm> StandardLatticeParmSets;
    static bool initialized;

public:
    StdLatticeParm(DistributionType distType, usint ringDim, SecurityLevel minSecLev, usint maxLogQ)
        : distType(distType), ringDim(ringDim), minSecLev(minSecLev), maxLogQ(maxLogQ) {}

    static void initializeLookups() {
        for (size_t i = 0; i < StandardLatticeParmSets.size(); i++) {
            StdLatticeParm& s                                                              = StandardLatticeParmSets[i];
            byRing[static_cast<int>(s.distType)][static_cast<int>(s.minSecLev)][s.ringDim] = &s;

    static usint FindMaxQ(DistributionType distType, SecurityLevel minSecLev, usint ringDim) {
        int distTypeIdx  = static_cast<int>(distType);
        int minSecLevIdx = static_cast<int>(minSecLev);
        if (!initialized)

    static usint FindRingDim(DistributionType distType, SecurityLevel minSecLev, usint curLogQ) {
        if (!initialized)
            initializeLookups();
        usint prev = 0;


//========================================
//===== File: ./src/core/include/lattice/trapdoor.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Class to store a lattice trapdoor pair generated using construction 1
 */
template <class Element>
class RLWETrapdoorPair {
public:
    // matrix of noise polynomials
    Matrix<Element> m_r;
    // matrix

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(CEREAL_NVP(m_r));
        ar(CEREAL_NVP(m_e));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(CEREAL_NVP(m_r));
        ar(CEREAL_NVP(m_e));
 */
template <class Element>
class RLWETrapdoorUtility {
    using ParmType = typename Element::Params;
    using DggType  = typename Element::DggType;
    using IntType  = typename Element::Integer;

public:
    /**
   * Trapdoor generation method as described in Algorithm 1 of
   * https://eprint.iacr.org/2017/844.pdf
   */
    static std::pair<Matrix<Element>, RLWETrapdoorPair<Element>> TrapdoorGen(std::shared_ptr<ParmType> params,
                                                                             double stddev, int64_t base = 2,
                                                                             bool bal = false);

   */
    static std::pair<Matrix<Element>, RLWETrapdoorPair<Element>> TrapdoorGenSquareMat(std::shared_ptr<ParmType> params,
                                                                                      double stddev, size_t dimension,
                                                                                      int64_t base = 2,
                                                                                      bool bal     = false);
   */
    static Matrix<Element> GaussSamp(size_t n, size_t k, const Matrix<Element>& A, const RLWETrapdoorPair<Element>& T,
                                     const Element& u, DggType& dgg, DggType& dggLargeSigma, int64_t base = 2);

    /**
   */
    static Matrix<Element> GaussSampSquareMat(size_t n, size_t k, const Matrix<Element>& A,
                                              const RLWETrapdoorPair<Element>& T, const Matrix<Element>& U,
                                              DggType& dgg, DggType& dggLargeSigma, int64_t base = 2);

   */
    static Matrix<Element> GaussSampOnline(size_t n, size_t k, const Matrix<Element>& A,
                                           const RLWETrapdoorPair<Element>& T, const Element& u, DggType& dgg,
                                           const std::shared_ptr<Matrix<Element>> perturbationVector, int64_t base = 2);

   */
    static std::shared_ptr<Matrix<Element>> GaussSampOffline(size_t n, size_t k, const RLWETrapdoorPair<Element>& T,
                                                             DggType& dgg, DggType& dggLargeSigma, int64_t base = 2);

    /**
   */
    static void ZSampleSigmaP(size_t n, double s, double sigma, const RLWETrapdoorPair<Element>& Tprime,
                              const DggType& dgg, const DggType& dggLargeSigma,
                              std::shared_ptr<Matrix<Element>> perturbationVector) {
        OPENFHE_DEBUG_FLAG(false);
   */
    static void SamplePertSquareMat(size_t n, double s, double sigma, const RLWETrapdoorPair<Element>& Tprime,
                                    const DggType& dgg, const DggType& dggLargeSigma,
                                    std::shared_ptr<Matrix<Element>> perturbationVector) {
        Matrix<Element> R = Tprime.m_r;


//========================================
//===== File: ./src/core/include/lattice/trapdoor-impl.h =====
//========================================

namespace lbcrypto {

// On-line stage of pre-image sampling (includes only G-sampling)

template <class Element>
Matrix<Element> RLWETrapdoorUtility<Element>::GaussSampOnline(size_t n, size_t k, const Matrix<Element>& A,
                                                              const RLWETrapdoorPair<Element>& T, const Element& u,
                                                              DggType& dgg, const std::shared_ptr<Matrix<Element>> pHat,

template <class Element>
std::shared_ptr<Matrix<Element>> RLWETrapdoorUtility<Element>::GaussSampOffline(size_t n, size_t k,
                                                                                const RLWETrapdoorPair<Element>& T,
                                                                                DggType& dgg, DggType& dggLargeSigma,

template <>
inline void RLWETrapdoorUtility<DCRTPoly>::ZSampleSigmaP(size_t n, double s, double sigma,
                                                         const RLWETrapdoorPair<DCRTPoly>& Tprime,
                                                         const DCRTPoly::DggType& dgg,


//========================================
//===== File: ./src/core/include/lattice/trapdoorparameters.h =====
//========================================

namespace lbcrypto {
/*
 *@brief Virtual templated class for trapdoor parameters
 *@tparam Element ring element
 */
template <class Element>
class TrapdoorParams {
    using ParmType = typename Element::Params;
    using DggType  = typename Element::DggType;

public:
    /*
   *@brief Default destructor
   */
    virtual ~TrapdoorParams() = default;
    /*
   *@brief Default constructor
   */

protected:
    double m_stddev;
    std::shared_ptr<ParmType> m_elemparams;
    DggType m_dgg;
 */
template <class Element>
class RLWETrapdoorParams : public TrapdoorParams<Element> {
    using ParmType = typename Element::Params;
    using DggType  = typename Element::DggType;

public:
    /*
   *@brief Default destructor
   */

protected:
    int64_t m_base;
    size_t m_k;
    bool m_bal;
 */
template <class Element>
class PerturbationVector {
public:
    /*
   *@brief Default constructor
   */
   */
    explicit PerturbationVector(std::shared_ptr<Matrix<Element>>& pvector) : m_pvector(pvector) {}
    /*
   *@brief Mutator for perturbation vector
   *@param pvector Vector containing ring elements

private:
    // Perturbation vector represented as a vector of ring elements
    std::shared_ptr<Matrix<Element>> m_pvector;
};


//========================================
//===== File: ./src/core/include/math/binaryuniformgenerator.h =====
//========================================

namespace lbcrypto {

/**
 * @brief A generator of the Binary Uniform Distribution.
 */
template <typename VecType>
class BinaryUniformGeneratorImpl {
public:
    /**
   * @brief Basic constructor for Binary Uniform Generator.
   */

private:
    static std::bernoulli_distribution m_distribution;
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/math/binaryuniformgenerator-impl.h =====
//========================================

namespace lbcrypto {

template <typename VecType>
std::bernoulli_distribution BinaryUniformGeneratorImpl<VecType>::m_distribution = std::bernoulli_distribution(0.5);

template <typename VecType>
typename VecType::Integer BinaryUniformGeneratorImpl<VecType>::GenerateInteger() const {
    return m_distribution(PseudoRandomNumberGenerator::GetPRNG()) ? 1 : 0;
}

template <typename VecType>
VecType BinaryUniformGeneratorImpl<VecType>::GenerateVector(const usint size,
                                                            const typename VecType::Integer& modulus) const {
    VecType v(size, modulus);


//========================================
//===== File: ./src/core/include/math/chebyshev.h =====
//========================================
 */
namespace lbcrypto {

// move to cryptocontext?

 */
struct NewtonEnhancedResult {
    double maxError;
    double avgError;
    double maxRelativeError;


//========================================
//===== File: ./src/core/include/math/dftransform.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Discrete Fourier Transform FFT implementation.
 */
class DiscreteFourierTransform {
public:
    /**
   * Virtual FFT forward transform.
   *
   */
    static std::vector<std::complex<double>> FFTForwardTransform(std::vector<std::complex<double>>& A);

    /**
   * Virtual FFT inverse transform.
   */
    static std::vector<std::complex<double>> FFTInverseTransform(std::vector<std::complex<double>>& A);

    /**
   * Virtual forward transform.
   */
    static std::vector<std::complex<double>> ForwardTransform(std::vector<std::complex<double>> A);

    /**
   * Virtual inverse transform.
   */
    static std::vector<std::complex<double>> InverseTransform(std::vector<std::complex<double>> A);

    /**
   * In-place FFT-like algorithm used in CKKS encoding. For more details,
   */
    static void FFTSpecialInv(std::vector<std::complex<double>>& vals, uint32_t cyclOrder);

    /**
   * In-place FFT-like algorithm used in CKKS decoding. For more details,
   */
    static void FFTSpecial(std::vector<std::complex<double>>& vals, uint32_t cyclOrder);

    /**
   * Reset cached values for the transform to empty.
   */
    static void Reset();

    static void PreComputeTable(uint32_t s);

    static void Initialize(uint32_t m, uint32_t nh);

private:
    static std::complex<double>* rootOfUnityTable;

    // structure to keep values precomputed by Initialize() for every cyclotomic order value
    struct PrecomputedValues {
        // cyclotomic order
        uint32_t m_M;
        uint32_t m_Nh;
    // precomputedValues: key - cyclotomic order, data - values precomputed for the given cyclotomic order
    static std::unordered_map<uint32_t, PrecomputedValues> precomputedValues;

    static void BitReverse(std::vector<std::complex<double>>& vals);
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/math/discretegaussiangenerator.h =====
//========================================

namespace lbcrypto {

constexpr double KARNEY_THRESHOLD = 300.0;

 */
template <typename VecType>
class DiscreteGaussianGeneratorImpl {
public:
    /**
   * @brief         Basic constructor for specifying distribution parameter and
   * modulus.
   */
    explicit DiscreteGaussianGeneratorImpl(double std = 1.0);

    /**
   * @brief Destructor
   */
    static int64_t GenerateIntegerKarney(double mean, double stddev);

private:
    // Gyana to add precomputation methods and data members
    // all parameters are set as int because it is assumed that they are used for
    // generating "small" polynomials only

    static double UnnormalizedGaussianPDF(const double& mean, const double& sigma, int32_t x) {
        return pow(M_E, -pow(x - mean, 2) / (2. * sigma * sigma));
    }

    static double UnnormalizedGaussianPDFOptimized(const double& mean, const double& sigmaFactor, int32_t x) {
        return pow(M_E, sigmaFactor * (x - mean) * (x - mean));
    }

   */
    static bool AlgorithmP(PRNG& g, int32_t n);
    /**
   * @brief Subroutine used by Karney's Method to generate an integer with
   * probability exp(-k/2)(1 - exp(-1/2)).
   */
    static int32_t AlgorithmG(PRNG& g);
    /**
   * @brief Generates a Bernoulli random value H which is true with probability
   * exp(-1/2).
   */
    static bool AlgorithmH(PRNG& g);
    /**
   * @brief Generates a Bernoulli random value H which is true with probability
   * exp(-1/2). Uses double precision.
   */
    static bool AlgorithmHDouble(PRNG& g);
    /**
   * @brief Bernoulli trial with probability exp(-x(2k + x)/(2k + 2)).
   * @param g Mersenne Twister Engine used for uniform deviates
   */
    static bool AlgorithmB(PRNG& g, int32_t k, double x);
    /**
   * @brief Bernoulli trial with probability exp(-x(2k + x)/(2k + 2)). Uses
   * double precision.
   */
    static bool AlgorithmBDouble(PRNG& g, int32_t k, double x);
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/math/discretegaussiangeneratorgeneric.h =====
//========================================

namespace lbcrypto {

enum BaseSamplerType { KNUTH_YAO = 0, PEIKERT = 1 };

class DiscreteGaussianGeneratorGeneric;
class BaseSampler;
class SamplerCombiner;
class BitGenerator;

/*
 * @brief Class implementation to generate random bit. This is created for
 */
class BitGenerator {
public:
    BitGenerator()  = default;
    ~BitGenerator() = default;
    /*

private:
    uint32_t m_sequence{0};
    uint32_t m_counter{0};
};
 */
class BaseSampler {
public:
    /*
   * @brief Constructor
   * @param mean Mean of the distribution
   */
    virtual int64_t GenerateInteger();
    /*
   * @brief Destroyer for the base sampler
   */
    virtual ~BaseSampler() = default;
    /*
   * @brief Method for generating a random bit from the bit generator within
   * @return A random bit

private:
    // all parameters are set as int because it is assumed that they are used for
    // generating "small" polynomials only
    double b_a;
 */
class SamplerCombiner final : public BaseSampler {
public:
    /**
   * @brief Constructor
   * @param s1 Pointer to the first sampler to be combined

private:
    // Samplers to be combined
    BaseSampler *sampler1, *sampler2;
    // Coefficients that are used for combining
 */
class DiscreteGaussianGeneratorGeneric {
public:
    /**
   * @brief Basic constructor which does the precomputations.
   * @param samplers Array containing the base samplers

private:
    /**
   * @brief Subroutine used by Sample C
   * @param center Center of the distribution


//========================================
//===== File: ./src/core/include/math/discretegaussiangenerator-impl.h =====
//========================================

namespace lbcrypto {

template <typename VecType>
DiscreteGaussianGeneratorImpl<VecType>::DiscreteGaussianGeneratorImpl(double std) {
    SetStd(std);
}

template <typename VecType>
bool DiscreteGaussianGeneratorImpl<VecType>::IsInitialized() const {
    return m_std > 1.000000001;
}

template <typename VecType>
void DiscreteGaussianGeneratorImpl<VecType>::SetStd(double std) {
    if (std::log2(m_std) > 59) {
        //    if (lbcrypto::GetMSB(static_cast<uint64_t>(std)) > 59) {

template <typename VecType>
double DiscreteGaussianGeneratorImpl<VecType>::GetStd() const {
    return m_std;
}

template <typename VecType>
void DiscreteGaussianGeneratorImpl<VecType>::Initialize() {
    // usually the bound of m_std * M is used, where M = 12 .. 40
    // we use M = std::sqrt(-2. * std::log(5e-32)) = 12.0061 here,

template <typename VecType>
int32_t DiscreteGaussianGeneratorImpl<VecType>::GenerateInt() const {
    // we need to use the binary uniform generator rather than regular continuous
    // distribution; see DG14 for details

template <typename VecType>
std::shared_ptr<int64_t> DiscreteGaussianGeneratorImpl<VecType>::GenerateIntVector(uint32_t size) const {
    std::shared_ptr<int64_t> ans(new int64_t[size], std::default_delete<int64_t[]>());


template <typename VecType>
uint32_t DiscreteGaussianGeneratorImpl<VecType>::FindInVector(const std::vector<double>& S, double search) const {
    // STL binary search implementation
    auto lower = std::lower_bound(S.begin(), S.end(), search);

template <typename VecType>
typename VecType::Integer DiscreteGaussianGeneratorImpl<VecType>::GenerateInteger(
    const typename VecType::Integer& modulus) const {
    double seed = std::uniform_real_distribution<double>(0.0, 1.0)(PseudoRandomNumberGenerator::GetPRNG()) - 0.5;

template <typename VecType>
VecType DiscreteGaussianGeneratorImpl<VecType>::GenerateVector(const uint32_t size,
                                                               const typename VecType::Integer& modulus) const {
    auto result = GenerateIntVector(size);

template <typename VecType>
typename VecType::Integer DiscreteGaussianGeneratorImpl<VecType>::GenerateInteger(
    double mean, double stddev, size_t n, const typename VecType::Integer& modulus) const {
    double t = std::log2(n) * stddev;

template <typename VecType>
int32_t DiscreteGaussianGeneratorImpl<VecType>::GenerateInteger(double mean, double stddev, size_t n) const {
    if (std::isinf(mean))
        OPENFHE_THROW("DiscreteGaussianGeneratorImpl called with mean == +-inf");

template <typename VecType>
int64_t DiscreteGaussianGeneratorImpl<VecType>::GenerateIntegerKarney(double mean, double stddev) {
    std::uniform_int_distribution<int64_t> uniform_sign(0, 1);
    std::uniform_int_distribution<int64_t> uniform_j(0, std::ceil(stddev) - 1);

template <typename VecType>
bool DiscreteGaussianGeneratorImpl<VecType>::AlgorithmP(PRNG& g, int n) {
    while (n-- && AlgorithmH(g)) {
    }

template <typename VecType>
int32_t DiscreteGaussianGeneratorImpl<VecType>::AlgorithmG(PRNG& g) {
    int n = 0;
    while (AlgorithmH(g))
// enough precision is encountered, call the double-precision algorithm
template <typename VecType>
bool DiscreteGaussianGeneratorImpl<VecType>::AlgorithmH(PRNG& g) {
    std::uniform_real_distribution<float> dist(0, 1);
    float h_a, h_b;

template <typename VecType>
bool DiscreteGaussianGeneratorImpl<VecType>::AlgorithmHDouble(PRNG& g) {
    std::uniform_real_distribution<double> dist(0, 1);
    double h_a, h_b;

template <typename VecType>
bool DiscreteGaussianGeneratorImpl<VecType>::AlgorithmB(PRNG& g, int32_t k, double x) {
    std::uniform_real_distribution<float> dist(0.0, 1.0);


template <typename VecType>
bool DiscreteGaussianGeneratorImpl<VecType>::AlgorithmBDouble(PRNG& g, int32_t k, double x) {
    std::uniform_real_distribution<double> dist(0.0, 1.0);



//========================================
//===== File: ./src/core/include/math/discreteuniformgenerator.h =====
//========================================

namespace lbcrypto {

constexpr uint32_t DUG_CHUNK_MIN{0};
constexpr uint32_t DUG_CHUNK_WIDTH{std::numeric_limits<uint32_t>::digits};
 */
template <typename VecType>
class DiscreteUniformGeneratorImpl {
public:
    DiscreteUniformGeneratorImpl()  = default;
    ~DiscreteUniformGeneratorImpl() = default;
    explicit DiscreteUniformGeneratorImpl(const typename VecType::Integer& modulus);

    /**
   * @brief         Sets the modulus. Overrides parent function

private:
    typename VecType::Integer m_modulus{};
    uint32_t m_chunksPerValue{};
    uint32_t m_shiftChunk{};


//========================================
//===== File: ./src/core/include/math/discreteuniformgenerator-impl.h =====
//========================================

namespace lbcrypto {

template <typename VecType>
DiscreteUniformGeneratorImpl<VecType>::DiscreteUniformGeneratorImpl(const typename VecType::Integer& modulus) {
    this->SetModulus(modulus);
}

template <typename VecType>
void DiscreteUniformGeneratorImpl<VecType>::SetModulus(const typename VecType::Integer& modulus) {
    m_modulus = modulus;


template <typename VecType>
typename VecType::Integer DiscreteUniformGeneratorImpl<VecType>::GenerateInteger() const {
    if (m_modulus == typename VecType::Integer(0))
        OPENFHE_THROW("0 modulus?");

template <typename VecType>
VecType DiscreteUniformGeneratorImpl<VecType>::GenerateVector(const uint32_t size) const {
    VecType v(size, m_modulus);
    for (uint32_t i = 0; i < size; ++i)

template <typename VecType>
VecType DiscreteUniformGeneratorImpl<VecType>::GenerateVector(const uint32_t size,
                                                              const typename VecType::Integer& modulus) {
    this->SetModulus(modulus);


//========================================
//===== File: ./src/core/include/math/distrgen.h =====
//========================================


//========================================
//===== File: ./src/core/include/math/distributiongenerator.h =====
//========================================

namespace lbcrypto {

/**
 * @brief PseudoRandomNumberGenerator provides the PRNG capability to all random distribution generators in OpenFHE.

class PseudoRandomNumberGenerator {
public:
    /**
    * @brief InitPRNGEngine() initializes the PRNG generator
    * @param libPath a string with the absolute path to an external PRNG library ("/path/to/libprng.so").
    */
    static void InitPRNGEngine(const std::string& libPath = std::string());

    /**
     * @brief Returns a reference to the PRNG engine
     */
    static PRNG& GetPRNG();

private:
    using GenPRNGEngineFuncPtr = PRNG* (*)();

#if defined(WITH_OPENMP)
    // shared pointer to a thread-specific PRNG engine
    static std::shared_ptr<PRNG> m_prng;
    #if !defined(FIXED_SEED)
        // avoid contention on m_prng: local copies of m_prng are created for each thread
        #pragma omp threadprivate(m_prng)
    // pointer to the function generating PRNG
    static GenPRNGEngineFuncPtr genPRNGEngine;
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/math/hal/basicint.h =====
//========================================


//========================================
//===== File: ./src/core/include/math/hal/bigintbackend.h =====
//========================================
 */
namespace bigintbackend {

/*! Define the underlying default math implementation being used by defining
 * MATHBACKEND */


//========================================
//===== File: ./src/core/include/math/hal/bigintdyn/backenddyn.h =====
//========================================


//========================================
//===== File: ./src/core/include/math/hal/bigintdyn/mubintvecdyn.h =====
//========================================
 */
namespace bigintdyn {

template <class ubint_el_t>
class mubintvec;

/** Define the mapping for modulo Big Integer Vector */
using xmubintvec = mubintvec<BigInteger>;

template <class ubint_el_t>
class mubintvec final : public lbcrypto::BigVectorInterface<mubintvec<ubint_el_t>, ubint_el_t>,
                        public lbcrypto::Serializable {
public:
    mubintvec() = default;

    static mubintvec Single(const ubint_el_t& val, const ubint_el_t& modulus) {
        mubintvec vec(1, modulus);
        vec.m_data[0] = val;
        return vec;
   */
    explicit mubintvec(usint length) noexcept : m_data(length) {}

    /**
   * Basic constructor for specifying the length and modulus of the vector.
   */
    explicit mubintvec(usint length, const std::string& modulus)
        : m_modulus(modulus), m_modulus_state{State::INITIALIZED}, m_data(length) {}

    /**
   */
    explicit mubintvec(usint length, const ubint_el_t& modulus, std::initializer_list<std::string> rhs) noexcept;

    /**
   * Basic constructor for specifying the length of the vector with
   */
    explicit mubintvec(usint length, const ubint_el_t& modulus, std::initializer_list<uint64_t> rhs) noexcept;

    // constructor specifying the mubintvec as a vector of strings and modulus
    explicit mubintvec(const std::vector<std::string>& s, const ubint_el_t& modulus) noexcept;

    // constructor specifying the mubintvec as a vector of strings and modulus
    explicit mubintvec(const std::vector<std::string>& s, const std::string& modulus) noexcept;

    /**
   * Assignment operator

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("d", m_data));
        ar(::cereal::make_nvp("m", m_modulus));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +

    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    enum State { GARBAGE, INITIALIZED };

    ubint_el_t m_modulus{};



//========================================
//===== File: ./src/core/include/math/hal/bigintdyn/transformdyn.h =====
//========================================
 */
namespace bigintdyn {

/**
 * @brief Number Theoretic Transform implementation
 */
template <typename VecType>
class NumberTheoreticTransformDyn {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform in the ring Z_q[X]/(X^n-1).
   *
 */
template <typename VecType>
class ChineseRemainderTransformFTTDyn final : public lbcrypto::ChineseRemainderTransformFTTInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Copies \p element into \p result and calls NumberTheoreticTransform::ForwardTransformToBitReverseInPlace()
   *
    /// For inverse FTT, we also need #m_cycloOrderInversePreconTableByModulus (this is to use an N-size NTT for FTT instead of 2N-size NTT).
    static std::map<IntType, VecType> m_cycloOrderInverseTableByModulus;

    /// map to store the cyclo order inverse preconditioned with modulus as a key
    /// Shoup's precomputation of above #m_cycloOrderInverseTableByModulus
    static std::map<IntType, VecType> m_cycloOrderInversePreconTableByModulus;

    /// map to store the forward roots of Unity for NTT, with bits reversed, with modulus as a key (aka twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityReverseTableByModulus;

    /// map to store inverse roots of unity for iNTT, with bits reversed, with modulus as a key (aka inverse twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityInverseReverseTableByModulus;

    /// map to store Shoup's precomputations of forward roots of unity for NTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityPreconReverseTableByModulus;

    /// map to store Shoup's precomputations of inverse rou for iNTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityInversePreconReverseTableByModulus;
};

// struct used as a key in BlueStein transform
template <typename IntType>
using ModulusRoot = std::pair<IntType, IntType>;

template <typename IntType>
using ModulusRootPair = std::pair<ModulusRoot<IntType>, ModulusRoot<IntType>>;

/**
 */
template <typename VecType>
class BluesteinFFTDyn {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform.
   *
    // map to store the root of unity table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityTableByModulusRoot;

    // map to store the root of unity inverse table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityInverseTableByModulusRoot;

    // map to store the power of roots as a table with modulus + root of unity as
    // key.
    static std::map<ModulusRoot<IntType>, VecType> m_powersTableByModulusRoot;

    // map to store the forward transform of power table with modulus + root of
    // unity as key.
    static std::map<ModulusRootPair<IntType>, VecType> m_RBTableByModulusRootPair;

private:
    // map to store the precomputed NTT modulus with modulus as key.
    static std::map<IntType, ModulusRoot<IntType>> m_defaultNTTModulusRoot;
};

/**
 */
template <typename VecType>
class ChineseRemainderTransformArbDyn final : public lbcrypto::ChineseRemainderTransformArbInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Sets the cyclotomic polynomial.
   *

private:
    /**
   * @brief Padding zeroes to a vector
   * @param &element is the input of type VecType to be padded with zeros.
    // key.
    static std::map<IntType, VecType> m_cyclotomicPolyMap;

    // map to store the forward NTT transform of the inverse of cyclotomic
    // polynomial with polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyReverseNTTMap;

    // map to store the forward NTT transform of the cyclotomic polynomial with
    // polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyNTTMap;

    // map to store the root of unity table used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionTableByModulus;

    // map to store the root of unity table for computing forward NTT of inverse
    // cyclotomic polynomial used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionInverseTableByModulus;

    // modulus used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTModulus;

    // root of unity used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTRootOfUnity;

    // dimension of the NTT transform in NTT based polynomial division.
    static std::map<usint, usint> m_nttDivisionDim;
};

}  // namespace bigintdyn


//========================================
//===== File: ./src/core/include/math/hal/bigintdyn/transformdyn-impl.h =====
//========================================

namespace bigintdyn {

using namespace lbcrypto;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTDyn<VecType>::m_cycloOrderInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTDyn<VecType>::m_cycloOrderInversePreconTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTDyn<VecType>::m_rootOfUnityReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTDyn<VecType>::m_rootOfUnityInverseReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTDyn<VecType>::m_rootOfUnityPreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTDyn<VecType>::m_rootOfUnityInversePreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbDyn<VecType>::m_cyclotomicPolyMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbDyn<VecType>::m_cyclotomicPolyReverseNTTMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbDyn<VecType>::m_cyclotomicPolyNTTMap;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTDyn<VecType>::m_rootOfUnityTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType>
    BluesteinFFTDyn<VecType>::m_rootOfUnityInverseTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTDyn<VecType>::m_powersTableByModulusRoot;

template <typename VecType>
std::map<ModulusRootPair<typename VecType::Integer>, VecType> BluesteinFFTDyn<VecType>::m_RBTableByModulusRootPair;

template <typename VecType>
std::map<typename VecType::Integer, ModulusRoot<typename VecType::Integer>>
    BluesteinFFTDyn<VecType>::m_defaultNTTModulusRoot;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbDyn<VecType>::m_rootOfUnityDivisionTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbDyn<VecType>::m_rootOfUnityDivisionInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbDyn<VecType>::m_DivisionNTTModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbDyn<VecType>::m_DivisionNTTRootOfUnity;

template <typename VecType>
std::map<usint, usint> ChineseRemainderTransformArbDyn<VecType>::m_nttDivisionDim;

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::ForwardTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityTable, VecType* result) {
    usint n = element.GetLength();

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::InverseTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityInverseTable,
                                                                     VecType* result) {

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               VecType* element) {
    usint n         = element->GetLength();

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        VecType* result) {

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               const VecType& preconRootOfUnityTable,
                                                                               VecType* element) {

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        const VecType& preconRootOfUnityTable,

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::InverseTransformFromBitReverseInPlace(const VecType& rootOfUnityInverseTable,
                                                                                 const IntType& cycloOrderInv,
                                                                                 VecType* element) {

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                          const VecType& rootOfUnityInverseTable,
                                                                          const IntType& cycloOrderInv,

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::InverseTransformFromBitReverseInPlace(
    const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable, const IntType& cycloOrderInv,
    const IntType& preconCycloOrderInv, VecType* element) {

template <typename VecType>
void NumberTheoreticTransformDyn<VecType>::InverseTransformFromBitReverse(
    const VecType& element, const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable,
    const IntType& cycloOrderInv, const IntType& preconCycloOrderInv, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTDyn<VecType>::ForwardTransformToBitReverseInPlace(const IntType& rootOfUnity,
                                                                                   const usint CycloOrder,
                                                                                   VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTDyn<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                            const IntType& rootOfUnity,
                                                                            const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTDyn<VecType>::InverseTransformFromBitReverseInPlace(const IntType& rootOfUnity,
                                                                                     const usint CycloOrder,
                                                                                     VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTDyn<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                              const IntType& rootOfUnity,
                                                                              const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTDyn<VecType>::PreCompute(const IntType& rootOfUnity, const usint CycloOrder,
                                                          const IntType& modulus) {
    // Half of cyclo order

template <typename VecType>
void ChineseRemainderTransformFTTDyn<VecType>::PreCompute(std::vector<IntType>& rootOfUnity, const usint CycloOrder,
                                                          std::vector<IntType>& moduliiChain) {
    usint numOfRootU = rootOfUnity.size();

template <typename VecType>
void ChineseRemainderTransformFTTDyn<VecType>::Reset() {
    m_cycloOrderInverseTableByModulus.clear();
    m_cycloOrderInversePreconTableByModulus.clear();

template <typename VecType>
void BluesteinFFTDyn<VecType>::PreComputeDefaultNTTModulusRoot(usint cycloOrder, const IntType& modulus) {
    usint nttDim                              = pow(2, ceil(log2(2 * cycloOrder - 1)));
    const auto nttModulus                     = LastPrime<IntType>(log2(nttDim) + 2 * modulus.GetMSB(), nttDim);

template <typename VecType>
void BluesteinFFTDyn<VecType>::PreComputeRootTableForNTT(usint cyclotoOrder,
                                                         const ModulusRoot<IntType>& nttModulusRoot) {
    usint nttDim           = pow(2, ceil(log2(2 * cyclotoOrder - 1)));

template <typename VecType>
void BluesteinFFTDyn<VecType>::PreComputePowers(usint cycloOrder, const ModulusRoot<IntType>& modulusRoot) {
    const auto& modulus = modulusRoot.first;
    const auto& root    = modulusRoot.second;

template <typename VecType>
void BluesteinFFTDyn<VecType>::PreComputeRBTable(usint cycloOrder, const ModulusRootPair<IntType>& modulusRootPair) {
    const auto& modulusRoot = modulusRootPair.first;
    const auto& modulus     = modulusRoot.first;

template <typename VecType>
VecType BluesteinFFTDyn<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                   const usint cycloOrder) {
    const auto& modulus        = element.GetModulus();

template <typename VecType>
VecType BluesteinFFTDyn<VecType>::ForwardTransform(const VecType& element, const IntType& root, const usint cycloOrder,
                                                   const ModulusRoot<IntType>& nttModulusRoot) {
    if (element.GetLength() != cycloOrder) {

template <typename VecType>
VecType BluesteinFFTDyn<VecType>::PadZeros(const VecType& a, const usint finalSize) {
    usint s = a.GetLength();
    VecType result(finalSize, a.GetModulus());

template <typename VecType>
VecType BluesteinFFTDyn<VecType>::Resize(const VecType& a, usint lo, usint hi) {
    VecType result(hi - lo + 1, a.GetModulus());


template <typename VecType>
void BluesteinFFTDyn<VecType>::Reset() {
    m_rootOfUnityTableByModulusRoot.clear();
    m_rootOfUnityInverseTableByModulusRoot.clear();

template <typename VecType>
void ChineseRemainderTransformArbDyn<VecType>::SetCylotomicPolynomial(const VecType& poly, const IntType& mod) {
    m_cyclotomicPolyMap[mod] = poly;
}

template <typename VecType>
void ChineseRemainderTransformArbDyn<VecType>::PreCompute(const usint cyclotoOrder, const IntType& modulus) {
    BluesteinFFTDyn<VecType>().PreComputeDefaultNTTModulusRoot(cyclotoOrder, modulus);
}

template <typename VecType>
void ChineseRemainderTransformArbDyn<VecType>::SetPreComputedNTTModulus(usint cyclotoOrder, const IntType& modulus,
                                                                        const IntType& nttModulus,
                                                                        const IntType& nttRoot) {

template <typename VecType>
void ChineseRemainderTransformArbDyn<VecType>::SetPreComputedNTTDivisionModulus(usint cyclotoOrder,
                                                                                const IntType& modulus,
                                                                                const IntType& nttMod,

template <typename VecType>
VecType ChineseRemainderTransformArbDyn<VecType>::InversePolyMod(const VecType& cycloPoly, const IntType& modulus,
                                                                 usint power) {
    VecType result(power, modulus);

template <typename VecType>
VecType ChineseRemainderTransformArbDyn<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbDyn<VecType>::InverseTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbDyn<VecType>::Pad(const VecType& element, const usint cycloOrder, bool forward) {
    usint n = GetTotient(cycloOrder);


template <typename VecType>
VecType ChineseRemainderTransformArbDyn<VecType>::Drop(const VecType& element, const usint cycloOrder, bool forward,
                                                       const IntType& bigMod, const IntType& bigRoot) {
    usint n = GetTotient(cycloOrder);

template <typename VecType>
void ChineseRemainderTransformArbDyn<VecType>::Reset() {
    m_cyclotomicPolyMap.clear();
    m_cyclotomicPolyReverseNTTMap.clear();


//========================================
//===== File: ./src/core/include/math/hal/bigintdyn/ubintdyn.h =====
//========================================

namespace bigintdyn {

template <typename limb_t>
class ubint;

/** Define the mapping for ExpBigInteger (experimental) */
using xubint     = ubint<expdtype>;

template <class ubint_el_t>
class mubintvec;

/**
 * @brief Struct to find log 2 value of N.
 */
template <usint N>
struct Log2 {
    static constexpr usint value = 1 + Log2<N / 2>::value;
};
template <>
struct Log2<2> {
    static constexpr usint value = 1;
};

// @brief A pre-computed constant of Log base 2 of 10.
 */
template <typename utype>
struct DataTypes {
    using SignedType       = void;
    using DoubleType       = void;
    using SignedDoubleType = void;
};
template <>
struct DataTypes<uint32_t> {
    using SignedType       = int32_t;
    using DoubleType       = uint64_t;
    using SignedDoubleType = int64_t;
};
template <>
struct DataTypes<uint64_t> {
    using SignedType = int64_t;
        #if defined(HAVE_INT128)
    using DoubleType       = uint128_t;
        #if defined(HAVE_INT128)
template <>
struct DataTypes<uint128_t> {
    using SignedType       = int128_t;
    using DoubleType       = uint128_t;
    using SignedDoubleType = int128_t;

template <typename limb_t>
class ubint final : public lbcrypto::BigIntegerInterface<ubint<limb_t>> {
private:
    // variable that stores the MOST SIGNIFICANT BIT position in the
    usint m_MSB{0};
    // vector storing the native integers. stored little endian
    // variable to store the maximum value of the limb data type
    static constexpr limb_t m_MaxLimb{std::numeric_limits<limb_t>::max()};
    // variable to store the bitlength of the limb data type
    static constexpr usint m_limbBitLength{sizeof(limb_t) * 8};
    // variable to store the log2 of the number of bits in the limb data type
    static constexpr usint m_log2LimbBitLength{Log2<sizeof(limb_t) * 8>::value};

    friend class mubintvec<ubint<limb_t>>;

public:
    using Integer  = limb_t;
    using Slimb_t  = typename DataTypes<limb_t>::SignedType;
    using Dlimb_t  = typename DataTypes<limb_t>::DoubleType;

    explicit operator bool() noexcept {
        return m_MSB != 0;
    }

   */
    explicit ubint(const std::string& strval) {
        this->ubint::SetValue(strval);
    }
    explicit ubint(const char* strval) {
        this->ubint::SetValue(std::string(strval));
    }
    explicit ubint(const char strval) : ubint(limb_t(strval - '0')) {}

    /**
   * Constructor from an unsigned integer.
   */
    template <typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
    ubint(T val) : m_MSB{lbcrypto::GetMSB(val)}, m_value{limb_t(val)} {
        if constexpr (sizeof(T) > sizeof(limb_t)) {
            if ((val >>= m_limbBitLength) > 0) {

    template <typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
    ubint(T val) = delete;

    template <typename T, std::enable_if_t<!std::is_integral_v<T> && !std::is_floating_point_v<T>, bool> = true>
    ubint(T val) : ubint(BasicInteger(val)) {}

    /**
   */
    template <typename T, std::enable_if_t<!std::is_same_v<T, const ubint>, bool> = true>
    ubint& operator=(T val) {
        return *this = ubint(val);
    }
   */
    template <typename T = limb_t>
    ubint Mod(const ubint& modulus, const ubint& mu,
              typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) const {
        return this->ubint::Mod(modulus);

    template <typename T = limb_t>
    ubint Mod(const ubint& modulus, const ubint& mu,
              typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) const {
        if (*this < modulus)

    template <typename T = limb_t>
    ubint& ModEq(const ubint& modulus, const ubint& mu,
                 typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) {
        return this->ubint::ModEq(modulus);

    template <typename T = limb_t>
    ubint& ModEq(const ubint& modulus, const ubint& mu,
                 typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) {
        if (*this < modulus)
   */
    template <typename T = limb_t>
    ubint ModAdd(const ubint& b, const ubint& modulus, const ubint& mu,
                 typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) const {
        return b.ModAdd(*this, modulus);

    template <typename T = limb_t>
    ubint ModAdd(const ubint& b, const ubint& modulus, const ubint& mu,
                 typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) const {
        return b.Add(*this).Mod(modulus, mu);

    template <typename T = limb_t>
    ubint& ModAddEq(const ubint& b, const ubint& modulus, const ubint& mu,
                    typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) {
        return this->ubint::ModAddEq(b, modulus);

    template <typename T = limb_t>
    ubint& ModAddEq(const ubint& b, const ubint& modulus, const ubint& mu,
                    typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) {
        return *this = b.Add(*this).Mod(modulus, mu);
   */
    template <typename T = limb_t>
    ubint ModSub(const ubint& b, const ubint& modulus, const ubint& mu,
                 typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) const {
        return this->ubint::ModSub(b, modulus);

    template <typename T = limb_t>
    ubint ModSub(const ubint& b, const ubint& modulus, const ubint& mu,
                 typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) const {
        auto bv(b);

    template <typename T = limb_t>
    ubint& ModSubEq(const ubint& b, const ubint& modulus, const ubint& mu,
                    typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) {
        return this->ubint::ModSubEq(b, modulus);

    template <typename T = limb_t>
    ubint& ModSubEq(const ubint& b, const ubint& modulus, const ubint& mu,
                    typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) {
        auto bv(b);
   */
    template <typename T = limb_t>
    ubint ModMul(const ubint& b, const ubint& modulus,
                 typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) const {
        auto bv(b);

    template <typename T = limb_t>
    ubint ModMul(const ubint& b, const ubint& modulus,
                 typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) const {
        return b.ModMul(*this, modulus, modulus.ComputeMu());

    template <typename T = limb_t>
    ubint& ModMulEq(const ubint& b, const ubint& modulus,
                    typename std::enable_if_t<!std::is_same_v<T, Dlimb_t>, bool> = true) {
        auto bv(b);

    template <typename T = limb_t>
    ubint& ModMulEq(const ubint& b, const ubint& modulus,
                    typename std::enable_if_t<std::is_same_v<T, Dlimb_t>, bool> = true) {
        return *this = b.ModMul(*this, modulus, modulus.ComputeMu());

    template <typename T = BasicInteger>
    T ConvertToInt() const noexcept {
        constexpr usint limblen{sizeof(T) * 8};
        if constexpr (m_limbBitLength >= limblen) {
   */
    static ubint FromBinaryString(const std::string& bitString);

    /**
   * Returns the MSB location of the value.
    /*
    static bool isPowerOfTwo(const ubint& x) {
        if (x.m_MSB == 0)
            return false;
        const size_t limbs{x.m_value.size() - 1};
   */
    static ubint Allocator() noexcept {
        return ubint();
    }


    static const std::string IntegerTypeName() {
        if constexpr (std::is_same_v<limb_t, uint32_t>)
            return "UBDYNINT_32";
        if constexpr (std::is_same_v<limb_t, uint64_t>)
            return "UBDYNINT_128";
        static_assert(true, "Configuration Error: ubintdyn.h");
    }

    /**
   */
    static void PrintIntegerConstants() {
        std::cout << "sizeof UINT8_C  " << sizeof(UINT8_C(1)) << std::endl;
        std::cout << "sizeof UINT16_C " << sizeof(UINT16_C(1)) << std::endl;
        std::cout << "sizeof UINT32_C " << sizeof(UINT32_C(1)) << std::endl;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("v", m_value));
        ar(::cereal::make_nvp("m", m_MSB));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +

    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    /**
   * Sets the MSB to the correct value as computed from the internal value.
   */
   */
    static constexpr usint MSBToLimbs(usint msb) noexcept {
        constexpr usint mask{m_limbBitLength - 1};
        if (msb == 0)
            return 1;
// stream helper function for vector of objects
template <typename limb_t>
std::ostream &operator<<(std::ostream& os, const std::vector<limb_t>& v) {
  os << "[";
  for (auto&& itr : v)


//========================================
//===== File: ./src/core/include/math/hal/bigintfxd/backendfxd.h =====
//========================================

static_assert(bigintfxd::DataTypeChecker<integral_dtype>::value, "Data type provided is not supported in BigInteger");

// Global alias for MATHBACKEND 2 Integer
using M2Integer = bigintfxd::BigInteger;


//========================================
//===== File: ./src/core/include/math/hal/bigintfxd/mubintvecfxd.h =====
//========================================
 */
namespace bigintfxd {

// Forward declare this class for aliases
template <typename IntegerType>
class BigVectorFixedT;

using BigVector = BigVectorFixedT<BigInteger>;

 */
template <class IntegerType>
class BigVectorFixedT final : public lbcrypto::BigVectorInterface<BigVectorFixedT<IntegerType>, IntegerType>,
                              public lbcrypto::Serializable {
public:
    ~BigVectorFixedT() {
        delete[] m_data;
    }

    static inline BigVectorFixedT Single(const IntegerType& val, const IntegerType& modulus) {
        BigVectorFixedT vec(1, modulus);
        vec[0] = val;
        return vec;
   */
    explicit BigVectorFixedT(usint length, const IntegerType& modulus = 0);

    BigVectorFixedT(usint length, const IntegerType& modulus, const IntegerType& value)
        : m_data(new IntegerType[length]()), m_length{length}, m_modulus{modulus} {
   */
    template <class IntegerType_c>
    friend std::ostream& operator<<(std::ostream& os, const BigVectorFixedT<IntegerType_c>& ptr_obj) {
        auto len = ptr_obj.m_length;
        os << "[";

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("m", m_modulus));

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("m", m_modulus));

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    // m_data is a pointer to the vector
    IntegerType* m_data;
    // m_length stores the length of the vector


//========================================
//===== File: ./src/core/include/math/hal/bigintfxd/transformfxd.h =====
//========================================

namespace bigintfxd {

/**
 * @brief Number Theoretic Transform implementation
 */
template <typename VecType>
class NumberTheoreticTransformFxd {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform in the ring Z_q[X]/(X^n-1).
   *
 */
template <typename VecType>
class ChineseRemainderTransformFTTFxd : public lbcrypto::ChineseRemainderTransformFTTInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Copies \p element into \p result and calls NumberTheoreticTransform::ForwardTransformToBitReverseInPlace()
   *
    /// For inverse FTT, we also need #m_cycloOrderInversePreconTableByModulus (this is to use an N-size NTT for FTT instead of 2N-size NTT).
    static std::map<IntType, VecType> m_cycloOrderInverseTableByModulus;

    /// map to store the cyclo order inverse preconditioned with modulus as a key
    /// Shoup's precomputation of above #m_cycloOrderInverseTableByModulus
    static std::map<IntType, VecType> m_cycloOrderInversePreconTableByModulus;

    /// map to store the forward roots of Unity for NTT, with bits reversed, with modulus as a key (aka twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityReverseTableByModulus;

    /// map to store inverse roots of unity for iNTT, with bits reversed, with modulus as a key (aka inverse twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityInverseReverseTableByModulus;

    /// map to store Shoup's precomputations of forward roots of unity for NTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityPreconReverseTableByModulus;

    /// map to store Shoup's precomputations of inverse rou for iNTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityInversePreconReverseTableByModulus;
};

// struct used as a key in BlueStein transform
template <typename IntType>
using ModulusRoot = std::pair<IntType, IntType>;

template <typename IntType>
using ModulusRootPair = std::pair<ModulusRoot<IntType>, ModulusRoot<IntType>>;

/**
 */
template <typename VecType>
class BluesteinFFTFxd {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform.
   *
    // map to store the root of unity table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityTableByModulusRoot;

    // map to store the root of unity inverse table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityInverseTableByModulusRoot;

    // map to store the power of roots as a table with modulus + root of unity as
    // key.
    static std::map<ModulusRoot<IntType>, VecType> m_powersTableByModulusRoot;

    // map to store the forward transform of power table with modulus + root of
    // unity as key.
    static std::map<ModulusRootPair<IntType>, VecType> m_RBTableByModulusRootPair;

private:
    // map to store the precomputed NTT modulus with modulus as key.
    static std::map<IntType, ModulusRoot<IntType>> m_defaultNTTModulusRoot;
};

/**
 */
template <typename VecType>
class ChineseRemainderTransformArbFxd : public lbcrypto::ChineseRemainderTransformArbInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Sets the cyclotomic polynomial.
   *

private:
    /**
   * @brief Padding zeroes to a vector
   * @param &element is the input of type VecType to be padded with zeros.
    // key.
    static std::map<IntType, VecType> m_cyclotomicPolyMap;

    // map to store the forward NTT transform of the inverse of cyclotomic
    // polynomial with polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyReverseNTTMap;

    // map to store the forward NTT transform of the cyclotomic polynomial with
    // polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyNTTMap;

    // map to store the root of unity table used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionTableByModulus;

    // map to store the root of unity table for computing forward NTT of inverse
    // cyclotomic polynomial used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionInverseTableByModulus;

    // modulus used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTModulus;

    // root of unity used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTRootOfUnity;

    // dimension of the NTT transform in NTT based polynomial division.
    static std::map<usint, usint> m_nttDivisionDim;
};

}  // namespace bigintfxd


//========================================
//===== File: ./src/core/include/math/hal/bigintfxd/transformfxd-impl.h =====
//========================================

namespace bigintfxd {

using namespace lbcrypto;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTFxd<VecType>::m_cycloOrderInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTFxd<VecType>::m_cycloOrderInversePreconTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTFxd<VecType>::m_rootOfUnityReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTFxd<VecType>::m_rootOfUnityInverseReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTFxd<VecType>::m_rootOfUnityPreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTFxd<VecType>::m_rootOfUnityInversePreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbFxd<VecType>::m_cyclotomicPolyMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbFxd<VecType>::m_cyclotomicPolyReverseNTTMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbFxd<VecType>::m_cyclotomicPolyNTTMap;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTFxd<VecType>::m_rootOfUnityTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType>
    BluesteinFFTFxd<VecType>::m_rootOfUnityInverseTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTFxd<VecType>::m_powersTableByModulusRoot;

template <typename VecType>
std::map<ModulusRootPair<typename VecType::Integer>, VecType> BluesteinFFTFxd<VecType>::m_RBTableByModulusRootPair;

template <typename VecType>
std::map<typename VecType::Integer, ModulusRoot<typename VecType::Integer>>
    BluesteinFFTFxd<VecType>::m_defaultNTTModulusRoot;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbFxd<VecType>::m_rootOfUnityDivisionTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbFxd<VecType>::m_rootOfUnityDivisionInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbFxd<VecType>::m_DivisionNTTModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbFxd<VecType>::m_DivisionNTTRootOfUnity;

template <typename VecType>
std::map<usint, usint> ChineseRemainderTransformArbFxd<VecType>::m_nttDivisionDim;

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::ForwardTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityTable, VecType* result) {
    usint n = element.GetLength();

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::InverseTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityInverseTable,
                                                                     VecType* result) {

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               VecType* element) {
    usint n         = element->GetLength();

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        VecType* result) {

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               const VecType& preconRootOfUnityTable,
                                                                               VecType* element) {

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        const VecType& preconRootOfUnityTable,

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::InverseTransformFromBitReverseInPlace(const VecType& rootOfUnityInverseTable,
                                                                                 const IntType& cycloOrderInv,
                                                                                 VecType* element) {

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                          const VecType& rootOfUnityInverseTable,
                                                                          const IntType& cycloOrderInv,

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::InverseTransformFromBitReverseInPlace(
    const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable, const IntType& cycloOrderInv,
    const IntType& preconCycloOrderInv, VecType* element) {

template <typename VecType>
void NumberTheoreticTransformFxd<VecType>::InverseTransformFromBitReverse(
    const VecType& element, const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable,
    const IntType& cycloOrderInv, const IntType& preconCycloOrderInv, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTFxd<VecType>::ForwardTransformToBitReverseInPlace(const IntType& rootOfUnity,
                                                                                   const usint CycloOrder,
                                                                                   VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTFxd<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                            const IntType& rootOfUnity,
                                                                            const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTFxd<VecType>::InverseTransformFromBitReverseInPlace(const IntType& rootOfUnity,
                                                                                     const usint CycloOrder,
                                                                                     VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTFxd<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                              const IntType& rootOfUnity,
                                                                              const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTFxd<VecType>::PreCompute(const IntType& rootOfUnity, const usint CycloOrder,
                                                          const IntType& modulus) {
    // Half of cyclo order

template <typename VecType>
void ChineseRemainderTransformFTTFxd<VecType>::PreCompute(std::vector<IntType>& rootOfUnity, const usint CycloOrder,
                                                          std::vector<IntType>& moduliiChain) {
    usint numOfRootU = rootOfUnity.size();

template <typename VecType>
void ChineseRemainderTransformFTTFxd<VecType>::Reset() {
    m_cycloOrderInverseTableByModulus.clear();
    m_cycloOrderInversePreconTableByModulus.clear();

template <typename VecType>
void BluesteinFFTFxd<VecType>::PreComputeDefaultNTTModulusRoot(usint cycloOrder, const IntType& modulus) {
    usint nttDim                              = pow(2, ceil(log2(2 * cycloOrder - 1)));
    const auto nttModulus                     = LastPrime<IntType>(log2(nttDim) + 2 * modulus.GetMSB(), nttDim);

template <typename VecType>
void BluesteinFFTFxd<VecType>::PreComputeRootTableForNTT(usint cyclotoOrder,
                                                         const ModulusRoot<IntType>& nttModulusRoot) {
    usint nttDim           = pow(2, ceil(log2(2 * cyclotoOrder - 1)));

template <typename VecType>
void BluesteinFFTFxd<VecType>::PreComputePowers(usint cycloOrder, const ModulusRoot<IntType>& modulusRoot) {
    const auto& modulus = modulusRoot.first;
    const auto& root    = modulusRoot.second;

template <typename VecType>
void BluesteinFFTFxd<VecType>::PreComputeRBTable(usint cycloOrder, const ModulusRootPair<IntType>& modulusRootPair) {
    const auto& modulusRoot = modulusRootPair.first;
    const auto& modulus     = modulusRoot.first;

template <typename VecType>
VecType BluesteinFFTFxd<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                   const usint cycloOrder) {
    const auto& modulus        = element.GetModulus();

template <typename VecType>
VecType BluesteinFFTFxd<VecType>::ForwardTransform(const VecType& element, const IntType& root, const usint cycloOrder,
                                                   const ModulusRoot<IntType>& nttModulusRoot) {
    if (element.GetLength() != cycloOrder) {

template <typename VecType>
VecType BluesteinFFTFxd<VecType>::PadZeros(const VecType& a, const usint finalSize) {
    usint s = a.GetLength();
    VecType result(finalSize, a.GetModulus());

template <typename VecType>
VecType BluesteinFFTFxd<VecType>::Resize(const VecType& a, usint lo, usint hi) {
    VecType result(hi - lo + 1, a.GetModulus());


template <typename VecType>
void BluesteinFFTFxd<VecType>::Reset() {
    m_rootOfUnityTableByModulusRoot.clear();
    m_rootOfUnityInverseTableByModulusRoot.clear();

template <typename VecType>
void ChineseRemainderTransformArbFxd<VecType>::SetCylotomicPolynomial(const VecType& poly, const IntType& mod) {
    m_cyclotomicPolyMap[mod] = poly;
}

template <typename VecType>
void ChineseRemainderTransformArbFxd<VecType>::PreCompute(const usint cyclotoOrder, const IntType& modulus) {
    BluesteinFFTFxd<VecType>().PreComputeDefaultNTTModulusRoot(cyclotoOrder, modulus);
}

template <typename VecType>
void ChineseRemainderTransformArbFxd<VecType>::SetPreComputedNTTModulus(usint cyclotoOrder, const IntType& modulus,
                                                                        const IntType& nttModulus,
                                                                        const IntType& nttRoot) {

template <typename VecType>
void ChineseRemainderTransformArbFxd<VecType>::SetPreComputedNTTDivisionModulus(usint cyclotoOrder,
                                                                                const IntType& modulus,
                                                                                const IntType& nttMod,

template <typename VecType>
VecType ChineseRemainderTransformArbFxd<VecType>::InversePolyMod(const VecType& cycloPoly, const IntType& modulus,
                                                                 usint power) {
    VecType result(power, modulus);

template <typename VecType>
VecType ChineseRemainderTransformArbFxd<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbFxd<VecType>::InverseTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbFxd<VecType>::Pad(const VecType& element, const usint cycloOrder, bool forward) {
    usint n = GetTotient(cycloOrder);


template <typename VecType>
VecType ChineseRemainderTransformArbFxd<VecType>::Drop(const VecType& element, const usint cycloOrder, bool forward,
                                                       const IntType& bigMod, const IntType& bigRoot) {
    usint n = GetTotient(cycloOrder);

template <typename VecType>
void ChineseRemainderTransformArbFxd<VecType>::Reset() {
    m_cyclotomicPolyMap.clear();
    m_cyclotomicPolyReverseNTTMap.clear();


//========================================
//===== File: ./src/core/include/math/hal/bigintfxd/ubintfxd.h =====
//========================================
////////// bigintfxd code
typedef uint32_t integral_dtype;

        /** Define the mapping for BigIntegerFixedT
    3500 is the maximum bit width supported by BigIntegers, large enough for
 */
namespace bigintfxd {

using U64BITS = uint64_t;
        #if defined(HAVE_INT128)
// forward declaration for aliases
template <typename uint_type, usint BITLENGTH>
class BigIntegerFixedT;

// Create default type for the MATHBACKEND 2 integer
using BigInteger = BigIntegerFixedT<integral_dtype, BigIntegerBitLength>;
 */
template <usint N>
struct Log2 {
    static const usint value = 1 + Log2<N / 2>::value;
};

/**
 */
template <>
struct Log2<2> {
    static const usint value = 1;
};

/**
 */
template <typename U>
struct LogDtype {
    static const usint value = Log2<8 * sizeof(U)>::value;
};

/**
 */
template <typename Dtype>
struct DataTypeChecker {
    static const bool value = false;
};

/**
 */
template <>
struct DataTypeChecker<uint8_t> {
    static const bool value = true;
};

/**
 */
template <>
struct DataTypeChecker<uint16_t> {
    static const bool value = true;
};

/**
 */
template <>
struct DataTypeChecker<uint32_t> {
    static const bool value = true;
};

/**
 */
template <>
struct DataTypeChecker<uint64_t> {
    static const bool value = true;
};

/**
 */
template <typename uint_type>
struct UIntBitWidth {
    static const int value = 8 * sizeof(uint_type);
};

/**
 */
template <typename utype>
struct DoubleDataType {
    typedef void T;
};

/**
 */
template <>
struct DoubleDataType<uint8_t> {
    typedef uint16_t T;
};

/**
 */
template <>
struct DoubleDataType<uint16_t> {
    typedef uint32_t T;
};

/**
 */
template <>
struct DoubleDataType<uint32_t> {
    typedef uint64_t T;
};

/**
 */
template <>
struct DoubleDataType<uint64_t> {
        #if defined(HAVE_INT128)
    typedef uint128_t T;
        #else
    typedef uint64_t T;
        #endif
};

 */
template <typename uint_type, usint BITLENGTH>
class BigIntegerFixedT : public lbcrypto::BigIntegerInterface<BigIntegerFixedT<uint_type, BITLENGTH>> {
public:
    // CONSTRUCTORS

    /**
   */
    explicit BigIntegerFixedT(const std::string& strval);
    BigIntegerFixedT(const char* strval) : BigIntegerFixedT(std::string(strval)) {}  // NOLINT
    BigIntegerFixedT(const char val) : BigIntegerFixedT(uint64_t(val)) {}            // NOLINT

   */
    template <typename T, typename std::enable_if<
                              !std::is_same<T, int>::value && !std::is_same<T, uint32_t>::value &&
                                  !std::is_same<T, uint64_t>::value && !std::is_same<T, long>::value &&  // NOLINT
                                  !std::is_same<T, long long>::value &&                                  // NOLINT

    template <typename T, typename std::enable_if<!std::is_same<T, BigIntegerFixedT>::value &&
                                                      !std::is_same<T, const BigIntegerFixedT>::value,
                                                  bool>::type = true>
    BigIntegerFixedT& operator=(const T& val) {
    // TODO (dsuponit): make ConvertToInt() a template utility function
    template <typename T             = BasicInteger,
              std::enable_if_t<std::is_integral_v<T> || std::is_same_v<T, int128_t> || std::is_same_v<T, uint128_t>,
                               bool> = true>
    T ConvertToInt() const {
   */
    static BigIntegerFixedT intToBigInteger(usint m);

    /**
   * Convert a string representation of a binary number to a decimal BigIntegerFixedT.
   */
    static BigIntegerFixedT FromBinaryString(const std::string& bitString);

    // OTHER FUNCTIONS

   */
    static BigIntegerFixedT Allocator() {
        return BigIntegerFixedT(0);
    }


    static const std::string IntegerTypeName() {
        return "UBFIXINT";
    }

   */
    template <typename uint_type_c, usint BITLENGTH_c>
    friend std::ostream& operator<<(std::ostream& os, const BigIntegerFixedT<uint_type_c, BITLENGTH_c>& ptr_obj) {
        usint counter;
        // initiate to object to be printed

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::binary_data(m_value, sizeof(m_value)));

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("v", m_value));

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    static uint32_t SerializedVersion() {
        return 1;
    }

protected:
    /**
   * Converts the string v into base-r integer where r is equal to 2^bitwidth of
   * integral data type.

private:
    // array storing the native integers.
    // array size is the ceiling of BITLENGTH/(bits in the integral data type)
    uint_type m_value[(BITLENGTH + 8 * sizeof(uint_type) - 1) / (8 * sizeof(uint_type))];
    // variable to store the bit width of the integral data type.
    static const uschar m_uintBitLength;

    // variable to store the maximum value of the integral data type.
    static const uint_type m_uintMax;

    // variable to store the log(base 2) of the number of bits in the integral
    // data type.
    static const uschar m_logUintBitLength;

    // variable to store the size of the data array.
    static const usint m_nSize;

    // The maximum number of digits in BigIntegerFixedT. It is used by the cout(ostream)
    // function for printing the bigbinarynumber.
    static const usint m_numDigitInPrintval;

    /**
   * function to return the ceiling of the number divided by the number of bits
   */
    static uint_type ceilIntByUInt(const uint_type Number);

    // currently unused array
    static const BigIntegerFixedT* m_modChain;

    /**
   * function to return the MSB of number.

    static usint GetMSBUint_type(uint_type x);

    // Duint_type is the data type that has twice as many bits in the integral
    // data type.
    typedef typename DoubleDataType<uint_type>::T Duint_type;

    /**
   * function to return the MSB of number that is of type Duint_type.
   */
    static usint GetMSBDUint_type(Duint_type x);

    /**
   * function that returns the BigIntegerFixedT after multiplication by a uint.
   */
    static uint_type UintInBinaryToDecimal(uschar* a);

    /**
   * function that mutiplies by 2 to the binary array.
   */
    static void double_bitVal(uschar* a);

    /**
   * function that adds bit b to the binary array.
   */
    static void add_bitVal(uschar* a, uschar b);
};

}  // namespace bigintfxd


//========================================
//===== File: ./src/core/include/math/hal/bigintntl/backendntl.h =====
//========================================


//========================================
//===== File: ./src/core/include/math/hal/bigintntl/mubintvecntl.h =====
//========================================
 */
namespace NTL {

// Forward declare this class for aliases
template <typename IntegerType>
class myVecP;

// Create default type for the MATHBACKEND 6 Vector
using BigVector = myVecP<BigInteger>;

template <typename myT>
class myVecP : public NTL::Vec<myT>,
               public lbcrypto::BigVectorInterface<myVecP<myT>, myT>,
               public lbcrypto::Serializable {
public:
    // CONSTRUCTORS

    myVecP() : Vec<myT>() {

    static inline myVecP Single(const myT& val, const myT& modulus) {
        myVecP vec(1);
        vec.SetModulus(modulus);
        vec[0] = val;

    explicit myVecP(const size_t length) : Vec<myT>(INIT_SIZE, length) {
        m_modulus_state = GARBAGE;
    }


    explicit myVecP(const myVecP<myT>& a);

    myVecP(myVecP<myT>&& a);


    explicit myVecP(std::vector<std::string>& s);           // without modulus
    myVecP(std::vector<std::string>& s, const myT& q);      // with modulus
    myVecP(std::vector<std::string>& s, const char* sq);    // with modulus
    myVecP(std::vector<std::string>& s, const uint64_t q);  // with modulusu

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        // YSP. This was seg-faulting in MINGW

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("m", m_modulus.ToString()));

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    // utility function to warn if modulus is no good
    // use when argument to function is myT
    void ModulusCheck(std::string msg) const {
    // TODO: BE 2 has gotten rid of this, we may too.
    enum ModulusState {
        GARBAGE,
        INITIALIZED  // note different order,  GARBAGE is the default
                     // state

protected:
    bool IndexCheck(size_t index) const {
        return index < this->GetLength();
    }


//========================================
//===== File: ./src/core/include/math/hal/bigintntl/transformntl.h =====
//========================================
 */
namespace NTL {

/**
 * @brief Number Theoretic Transform implementation
 */
template <typename VecType>
class NumberTheoreticTransformNtl {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform in the ring Z_q[X]/(X^n-1).
   *
 */
template <typename VecType>
class ChineseRemainderTransformFTTNtl : public lbcrypto::ChineseRemainderTransformFTTInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Copies \p element into \p result and calls NumberTheoreticTransform::ForwardTransformToBitReverseInPlace()
   *
    /// For inverse FTT, we also need #m_cycloOrderInversePreconTableByModulus (this is to use an N-size NTT for FTT instead of 2N-size NTT).
    static std::map<IntType, VecType> m_cycloOrderInverseTableByModulus;

    /// map to store the cyclo order inverse preconditioned with modulus as a key
    /// Shoup's precomputation of above #m_cycloOrderInverseTableByModulus
    static std::map<IntType, VecType> m_cycloOrderInversePreconTableByModulus;

    /// map to store the forward roots of Unity for NTT, with bits reversed, with modulus as a key (aka twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityReverseTableByModulus;

    /// map to store inverse roots of unity for iNTT, with bits reversed, with modulus as a key (aka inverse twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityInverseReverseTableByModulus;

    /// map to store Shoup's precomputations of forward roots of unity for NTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityPreconReverseTableByModulus;

    /// map to store Shoup's precomputations of inverse rou for iNTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityInversePreconReverseTableByModulus;
};

// struct used as a key in BlueStein transform
template <typename IntType>
using ModulusRoot = std::pair<IntType, IntType>;

template <typename IntType>
using ModulusRootPair = std::pair<ModulusRoot<IntType>, ModulusRoot<IntType>>;

/**
 */
template <typename VecType>
class BluesteinFFTNtl {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform.
   *
    // map to store the root of unity table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityTableByModulusRoot;

    // map to store the root of unity inverse table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityInverseTableByModulusRoot;

    // map to store the power of roots as a table with modulus + root of unity as
    // key.
    static std::map<ModulusRoot<IntType>, VecType> m_powersTableByModulusRoot;

    // map to store the forward transform of power table with modulus + root of
    // unity as key.
    static std::map<ModulusRootPair<IntType>, VecType> m_RBTableByModulusRootPair;

private:
    // map to store the precomputed NTT modulus with modulus as key.
    static std::map<IntType, ModulusRoot<IntType>> m_defaultNTTModulusRoot;
};

/**
 */
template <typename VecType>
class ChineseRemainderTransformArbNtl : public lbcrypto::ChineseRemainderTransformArbInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Sets the cyclotomic polynomial.
   *

private:
    /**
   * @brief Padding zeroes to a vector
   * @param &element is the input of type VecType to be padded with zeros.
    // key.
    static std::map<IntType, VecType> m_cyclotomicPolyMap;

    // map to store the forward NTT transform of the inverse of cyclotomic
    // polynomial with polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyReverseNTTMap;

    // map to store the forward NTT transform of the cyclotomic polynomial with
    // polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyNTTMap;

    // map to store the root of unity table used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionTableByModulus;

    // map to store the root of unity table for computing forward NTT of inverse
    // cyclotomic polynomial used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionInverseTableByModulus;

    // modulus used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTModulus;

    // root of unity used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTRootOfUnity;

    // dimension of the NTT transform in NTT based polynomial division.
    static std::map<usint, usint> m_nttDivisionDim;
};
}  // namespace NTL



//========================================
//===== File: ./src/core/include/math/hal/bigintntl/transformntl-impl.h =====
//========================================

namespace NTL {

using namespace lbcrypto;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNtl<VecType>::m_cycloOrderInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNtl<VecType>::m_cycloOrderInversePreconTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNtl<VecType>::m_rootOfUnityReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNtl<VecType>::m_rootOfUnityInverseReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNtl<VecType>::m_rootOfUnityPreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNtl<VecType>::m_rootOfUnityInversePreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbNtl<VecType>::m_cyclotomicPolyMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbNtl<VecType>::m_cyclotomicPolyReverseNTTMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbNtl<VecType>::m_cyclotomicPolyNTTMap;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTNtl<VecType>::m_rootOfUnityTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType>
    BluesteinFFTNtl<VecType>::m_rootOfUnityInverseTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTNtl<VecType>::m_powersTableByModulusRoot;

template <typename VecType>
std::map<ModulusRootPair<typename VecType::Integer>, VecType> BluesteinFFTNtl<VecType>::m_RBTableByModulusRootPair;

template <typename VecType>
std::map<typename VecType::Integer, ModulusRoot<typename VecType::Integer>>
    BluesteinFFTNtl<VecType>::m_defaultNTTModulusRoot;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbNtl<VecType>::m_rootOfUnityDivisionTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbNtl<VecType>::m_rootOfUnityDivisionInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbNtl<VecType>::m_DivisionNTTModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbNtl<VecType>::m_DivisionNTTRootOfUnity;

template <typename VecType>
std::map<usint, usint> ChineseRemainderTransformArbNtl<VecType>::m_nttDivisionDim;

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::ForwardTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityTable, VecType* result) {
    usint n = element.GetLength();

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::InverseTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityInverseTable,
                                                                     VecType* result) {

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               VecType* element) {
    usint n         = element->GetLength();

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        VecType* result) {

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               const VecType& preconRootOfUnityTable,
                                                                               VecType* element) {

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        const VecType& preconRootOfUnityTable,

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::InverseTransformFromBitReverseInPlace(const VecType& rootOfUnityInverseTable,
                                                                                 const IntType& cycloOrderInv,
                                                                                 VecType* element) {

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                          const VecType& rootOfUnityInverseTable,
                                                                          const IntType& cycloOrderInv,

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::InverseTransformFromBitReverseInPlace(
    const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable, const IntType& cycloOrderInv,
    const IntType& preconCycloOrderInv, VecType* element) {

template <typename VecType>
void NumberTheoreticTransformNtl<VecType>::InverseTransformFromBitReverse(
    const VecType& element, const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable,
    const IntType& cycloOrderInv, const IntType& preconCycloOrderInv, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTNtl<VecType>::ForwardTransformToBitReverseInPlace(const IntType& rootOfUnity,
                                                                                   const usint CycloOrder,
                                                                                   VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTNtl<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                            const IntType& rootOfUnity,
                                                                            const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTNtl<VecType>::InverseTransformFromBitReverseInPlace(const IntType& rootOfUnity,
                                                                                     const usint CycloOrder,
                                                                                     VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTNtl<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                              const IntType& rootOfUnity,
                                                                              const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTNtl<VecType>::PreCompute(const IntType& rootOfUnity, const usint CycloOrder,
                                                          const IntType& modulus) {
    // Half of cyclo order

template <typename VecType>
void ChineseRemainderTransformFTTNtl<VecType>::PreCompute(std::vector<IntType>& rootOfUnity, const usint CycloOrder,
                                                          std::vector<IntType>& moduliiChain) {
    usint numOfRootU = rootOfUnity.size();

template <typename VecType>
void ChineseRemainderTransformFTTNtl<VecType>::Reset() {
    m_cycloOrderInverseTableByModulus.clear();
    m_cycloOrderInversePreconTableByModulus.clear();

template <typename VecType>
void BluesteinFFTNtl<VecType>::PreComputeDefaultNTTModulusRoot(usint cycloOrder, const IntType& modulus) {
    usint nttDim                              = pow(2, ceil(log2(2 * cycloOrder - 1)));
    const auto nttModulus                     = LastPrime<IntType>(log2(nttDim) + 2 * modulus.GetMSB(), nttDim);

template <typename VecType>
void BluesteinFFTNtl<VecType>::PreComputeRootTableForNTT(usint cyclotoOrder,
                                                         const ModulusRoot<IntType>& nttModulusRoot) {
    usint nttDim           = pow(2, ceil(log2(2 * cyclotoOrder - 1)));

template <typename VecType>
void BluesteinFFTNtl<VecType>::PreComputePowers(usint cycloOrder, const ModulusRoot<IntType>& modulusRoot) {
    const auto& modulus = modulusRoot.first;
    const auto& root    = modulusRoot.second;

template <typename VecType>
void BluesteinFFTNtl<VecType>::PreComputeRBTable(usint cycloOrder, const ModulusRootPair<IntType>& modulusRootPair) {
    const auto& modulusRoot = modulusRootPair.first;
    const auto& modulus     = modulusRoot.first;

template <typename VecType>
VecType BluesteinFFTNtl<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                   const usint cycloOrder) {
    const auto& modulus        = element.GetModulus();

template <typename VecType>
VecType BluesteinFFTNtl<VecType>::ForwardTransform(const VecType& element, const IntType& root, const usint cycloOrder,
                                                   const ModulusRoot<IntType>& nttModulusRoot) {
    if (element.GetLength() != cycloOrder) {

template <typename VecType>
VecType BluesteinFFTNtl<VecType>::PadZeros(const VecType& a, const usint finalSize) {
    usint s = a.GetLength();
    VecType result(finalSize, a.GetModulus());

template <typename VecType>
VecType BluesteinFFTNtl<VecType>::Resize(const VecType& a, usint lo, usint hi) {
    VecType result(hi - lo + 1, a.GetModulus());


template <typename VecType>
void BluesteinFFTNtl<VecType>::Reset() {
    m_rootOfUnityTableByModulusRoot.clear();
    m_rootOfUnityInverseTableByModulusRoot.clear();

template <typename VecType>
void ChineseRemainderTransformArbNtl<VecType>::SetCylotomicPolynomial(const VecType& poly, const IntType& mod) {
    m_cyclotomicPolyMap[mod] = poly;
}

template <typename VecType>
void ChineseRemainderTransformArbNtl<VecType>::PreCompute(const usint cyclotoOrder, const IntType& modulus) {
    BluesteinFFTNtl<VecType>().PreComputeDefaultNTTModulusRoot(cyclotoOrder, modulus);
}

template <typename VecType>
void ChineseRemainderTransformArbNtl<VecType>::SetPreComputedNTTModulus(usint cyclotoOrder, const IntType& modulus,
                                                                        const IntType& nttModulus,
                                                                        const IntType& nttRoot) {

template <typename VecType>
void ChineseRemainderTransformArbNtl<VecType>::SetPreComputedNTTDivisionModulus(usint cyclotoOrder,
                                                                                const IntType& modulus,
                                                                                const IntType& nttMod,

template <typename VecType>
VecType ChineseRemainderTransformArbNtl<VecType>::InversePolyMod(const VecType& cycloPoly, const IntType& modulus,
                                                                 usint power) {
    VecType result(power, modulus);

template <typename VecType>
VecType ChineseRemainderTransformArbNtl<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbNtl<VecType>::InverseTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbNtl<VecType>::Pad(const VecType& element, const usint cycloOrder, bool forward) {
    usint n = GetTotient(cycloOrder);


template <typename VecType>
VecType ChineseRemainderTransformArbNtl<VecType>::Drop(const VecType& element, const usint cycloOrder, bool forward,
                                                       const IntType& bigMod, const IntType& bigRoot) {
    usint n = GetTotient(cycloOrder);

template <typename VecType>
void ChineseRemainderTransformArbNtl<VecType>::Reset() {
    m_cyclotomicPolyMap.clear();
    m_cyclotomicPolyReverseNTTMap.clear();


//========================================
//===== File: ./src/core/include/math/hal/bigintntl/ubintntl.h =====
//========================================
 */
namespace NTL {

// forward declaration for aliases
class myZZ;

// Create default type for the MATHBACKEND 6 integer
using BigInteger = myZZ;
 */
template <usint N>
struct Log2 {
    static const usint value = 1 + Log2<N / 2>::value;
};

/**
 */
template <>
struct Log2<2> {
    static const usint value = 1;
};

class myZZ : public NTL::ZZ, public lbcrypto::BigIntegerInterface<myZZ> {
public:
    // CONSTRUCTORS

    /**
   */
    explicit myZZ(const std::string& strval);
    explicit myZZ(const char* strval) : myZZ(std::string(strval)) {}

    /**
   * Constructor from an unsigned integer.
   */
    template <typename T,
              typename std::enable_if<
                  !std::is_same<T, int>::value && !std::is_same<T, uint32_t>::value &&
                      !std::is_same<T, uint64_t>::value && !std::is_same<T, long>::value &&                // NOLINT
    // OpenFHE conversion methods
    template <typename T = BasicInteger>
    T ConvertToInt() const {
        #if defined(HAVE_INT128)
        if constexpr (std::is_same_v<T, uint128_t>) {
   */
    static myZZ FromBinaryString(const std::string& bitString);

    // OTHER FUNCTIONS


    static const myZZ& zero();

    usint GetMSB() const;

    // limb data type.
    static const usint m_log2LimbBitLength;

    /**
   * Gets a subset of bits of a given length with LSB at specified index.
   */
    static myZZ Allocator() {
        return 0;
    }


    static const std::string IntegerTypeName() {
        return "UBNTLINT";
    }


    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        void* data              = this->rep.rep;

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("v", ToString()));

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    // adapter kits
    void SetMSB();

    // todo: rename to MSB2NLimbs()
    static usint ceilIntByUInt(const ZZ_limb_t Number);

    mutable ::cereal::size_type m_MSB;
    usint GetMSBLimb_t(ZZ_limb_t x) const;


//========================================
//===== File: ./src/core/include/math/hal/integer.h =====
//========================================

namespace lbcrypto {

template <typename T>
class BigIntegerInterface {
public:
    // CONSTRUCTORS

    // Constructors must be implemented in the derived classes

protected:
    ~BigIntegerInterface() = default;

    // SERIALIZATION
// TODO
class BigMatrixInterface {};
}  // namespace lbcrypto

#endif


//========================================
//===== File: ./src/core/include/math/hal/intnat/mubintvecnat.h =====
//========================================
 */
namespace intnat {

// Forward declare class and give it an alias for the expected type
template <typename IntType>
class NativeVectorT;
using NativeVector = NativeVectorT<NativeInteger>;

/**
#if 0  // allocator that reports bytes used.
template <class Tp>
struct NAlloc {
    typedef Tp value_type;
    NAlloc() = default;
    template <class T> NAlloc(const NAlloc<T>&) {}
    Tp* allocate(std::size_t n) {
        n *= sizeof(Tp);
        return static_cast<Tp*>(::operator new(n));
};
template <class T, class U>
bool operator==(const NAlloc<T>&, const NAlloc<U>&) { return true; }
template <class T, class U>
bool operator!=(const NAlloc<T>&, const NAlloc<U>&) { return false; }
#endif

#if 0  // allocator that reports bytes used.
template <class Tp>
struct NAlloc {
    typedef Tp value_type;
    NAlloc() = default;
    template <class T> NAlloc(const NAlloc<T>&) {}
    Tp* allocate(std::size_t n) {
        n *= sizeof(Tp);
        std::cout << "allocating   " << n << " bytes\n";
};
template <class T, class U>
bool operator==(const NAlloc<T>&, const NAlloc<U>&) { return true; }
template <class T, class U>
bool operator!=(const NAlloc<T>&, const NAlloc<U>&) { return false; }
#endif

template <class IntegerType>
class NativeVectorT final : public lbcrypto::BigVectorInterface<NativeVectorT<IntegerType>, IntegerType>,
                            public lbcrypto::Serializable {
private:
    // m_modulus stores the internal modulus of the vector.
    IntegerType m_modulus{0};


public:
    using BasicInt = typename IntegerType::Integer;

    constexpr NativeVectorT() = default;

    static constexpr NativeVectorT Single(const IntegerType& val, const IntegerType& modulus) noexcept {
        return NativeVectorT(1, modulus, val);
    }

   */
    explicit constexpr NativeVectorT(usint length) noexcept : m_data(length) {}

    /**
   * Basic constructor for specifying the length of the vector and the modulus.
   */
    template <class IntegerType_c>
    friend std::ostream& operator<<(std::ostream& os, const NativeVectorT<IntegerType_c>& ptr_obj) {
        auto len = ptr_obj.m_data.size();
        os << "[";

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ::cereal::size_type size = m_data.size();

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("v", m_data));

    template <class Archive>
    typename std::enable_if<!cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    template <class Archive>
    typename std::enable_if<cereal::traits::is_text_archive<Archive>::value, void>::type load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {

    static uint32_t SerializedVersion() {
        return 1;
    }
};

namespace cereal {

//! Serialization for vector of NativeInteger

template <class Archive, class A>
inline void CEREAL_SAVE_FUNCTION_NAME(Archive& ar, std::vector<intnat::NativeIntegerT<uint64_t>, A> const& vec) {
    ar(make_size_tag(static_cast<cereal::size_type>(vec.size())));  // number of elements
    for (const auto& v : vec) {
#if defined(HAVE_INT128)
template <class Archive, class A>
inline void CEREAL_SAVE_FUNCTION_NAME(Archive& ar, std::vector<intnat::NativeIntegerT<uint128_t>, A> const& vec) {
    ar(make_size_tag(static_cast<cereal::size_type>(vec.size())));  // number of elements
    constexpr uint128_t mask = (static_cast<uint128_t>(1) << 64) - 1;

template <class Archive, class A>
inline void CEREAL_LOAD_FUNCTION_NAME(Archive& ar, std::vector<intnat::NativeIntegerT<uint64_t>, A>& vec) {
    cereal::size_type size;
    ar(make_size_tag(size));
#if defined(HAVE_INT128)
template <class Archive, class A>
inline void CEREAL_LOAD_FUNCTION_NAME(Archive& ar, std::vector<intnat::NativeIntegerT<uint128_t>, A>& vec) {
    cereal::size_type size;
    ar(make_size_tag(size));


//========================================
//===== File: ./src/core/include/math/hal/intnat/transformnat.h =====
//========================================
 */
namespace intnat {

struct HashPair {
    template <class T1, class T2>
    size_t operator()(const std::pair<T1, T2>& p) const {
        auto hash1 = std::hash<T1>{}(std::get<0>(p));
        auto hash2 = std::hash<T2>{}(std::get<1>(p));

    static size_t HashCombine(size_t lhs, size_t rhs) {
        lhs ^= rhs + 0x9e3779b9 + (lhs << 6) + (lhs >> 2);
        return lhs;
    }
 */
template <typename VecType>
class NumberTheoreticTransformNat {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform in the ring Z_q[X]/(X^n-1).
   *
 */
template <typename VecType>
class ChineseRemainderTransformFTTNat final : public lbcrypto::ChineseRemainderTransformFTTInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Copies \p element into \p result and calls NumberTheoreticTransform::ForwardTransformToBitReverseInPlace()
   *
    /// For inverse FTT, we also need #m_cycloOrderInversePreconTableByModulus (this is to use an N-size NTT for FTT instead of 2N-size NTT).
    static std::map<IntType, VecType> m_cycloOrderInverseTableByModulus;

    /// map to store the cyclo order inverse preconditioned with modulus as a key
    /// Shoup's precomputation of above #m_cycloOrderInverseTableByModulus
    static std::map<IntType, VecType> m_cycloOrderInversePreconTableByModulus;

    /// map to store the forward roots of Unity for NTT, with bits reversed, with modulus as a key (aka twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityReverseTableByModulus;

    /// map to store inverse roots of unity for iNTT, with bits reversed, with modulus as a key (aka inverse twiddle factors)
    static std::map<IntType, VecType> m_rootOfUnityInverseReverseTableByModulus;

    /// map to store Shoup's precomputations of forward roots of unity for NTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityPreconReverseTableByModulus;

    /// map to store Shoup's precomputations of inverse rou for iNTT, with bits reversed, with modulus as a key
    static std::map<IntType, VecType> m_rootOfUnityInversePreconReverseTableByModulus;
};

// struct used as a key in BlueStein transform
template <typename IntType>
using ModulusRoot = std::pair<IntType, IntType>;

template <typename IntType>
using ModulusRootPair = std::pair<ModulusRoot<IntType>, ModulusRoot<IntType>>;

/**
 */
template <typename VecType>
class BluesteinFFTNat {
    using IntType = typename VecType::Integer;

public:
    /**
   * Forward transform.
   *
    // map to store the root of unity table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityTableByModulusRoot;

    // map to store the root of unity inverse table with modulus as key.
    static std::map<ModulusRoot<IntType>, VecType> m_rootOfUnityInverseTableByModulusRoot;

    // map to store the power of roots as a table with modulus + root of unity as
    // key.
    static std::map<ModulusRoot<IntType>, VecType> m_powersTableByModulusRoot;

    // map to store the forward transform of power table with modulus + root of
    // unity as key.
    static std::map<ModulusRootPair<IntType>, VecType> m_RBTableByModulusRootPair;

private:
    // map to store the precomputed NTT modulus with modulus as key.
    static std::map<IntType, ModulusRoot<IntType>> m_defaultNTTModulusRoot;
};

/**
 */
template <typename VecType>
class ChineseRemainderTransformArbNat final : public lbcrypto::ChineseRemainderTransformArbInterface<VecType> {
    using IntType = typename VecType::Integer;

public:
    /**
   * Sets the cyclotomic polynomial.
   *

private:
    /**
   * @brief Padding zeroes to a vector
   * @param &element is the input of type VecType to be padded with zeros.
    // key.
    static std::map<IntType, VecType> m_cyclotomicPolyMap;

    // map to store the forward NTT transform of the inverse of cyclotomic
    // polynomial with polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyReverseNTTMap;

    // map to store the forward NTT transform of the cyclotomic polynomial with
    // polynomial ring's modulus as key.
    static std::map<IntType, VecType> m_cyclotomicPolyNTTMap;

    // map to store the root of unity table used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionTableByModulus;

    // map to store the root of unity table for computing forward NTT of inverse
    // cyclotomic polynomial used in NTT based polynomial division.
    static std::map<IntType, VecType> m_rootOfUnityDivisionInverseTableByModulus;

    // modulus used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTModulus;

    // root of unity used in NTT based polynomial division.
    static std::map<IntType, IntType> m_DivisionNTTRootOfUnity;

    // dimension of the NTT transform in NTT based polynomial division.
    static std::map<usint, usint> m_nttDivisionDim;
};

}  // namespace intnat


//========================================
//===== File: ./src/core/include/math/hal/intnat/transformnat-impl.h =====
//========================================

namespace intnat {

using namespace lbcrypto;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNat<VecType>::m_cycloOrderInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNat<VecType>::m_cycloOrderInversePreconTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNat<VecType>::m_rootOfUnityReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNat<VecType>::m_rootOfUnityInverseReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNat<VecType>::m_rootOfUnityPreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformFTTNat<VecType>::m_rootOfUnityInversePreconReverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbNat<VecType>::m_cyclotomicPolyMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbNat<VecType>::m_cyclotomicPolyReverseNTTMap;

template <typename VecType>
std::map<typename VecType::Integer, VecType> ChineseRemainderTransformArbNat<VecType>::m_cyclotomicPolyNTTMap;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTNat<VecType>::m_rootOfUnityTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType>
    BluesteinFFTNat<VecType>::m_rootOfUnityInverseTableByModulusRoot;

template <typename VecType>
std::map<ModulusRoot<typename VecType::Integer>, VecType> BluesteinFFTNat<VecType>::m_powersTableByModulusRoot;

template <typename VecType>
std::map<ModulusRootPair<typename VecType::Integer>, VecType> BluesteinFFTNat<VecType>::m_RBTableByModulusRootPair;

template <typename VecType>
std::map<typename VecType::Integer, ModulusRoot<typename VecType::Integer>>
    BluesteinFFTNat<VecType>::m_defaultNTTModulusRoot;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbNat<VecType>::m_rootOfUnityDivisionTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, VecType>
    ChineseRemainderTransformArbNat<VecType>::m_rootOfUnityDivisionInverseTableByModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbNat<VecType>::m_DivisionNTTModulus;

template <typename VecType>
std::map<typename VecType::Integer, typename VecType::Integer>
    ChineseRemainderTransformArbNat<VecType>::m_DivisionNTTRootOfUnity;

template <typename VecType>
std::map<usint, usint> ChineseRemainderTransformArbNat<VecType>::m_nttDivisionDim;

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::ForwardTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityTable, VecType* result) {
    usint n = element.GetLength();

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::InverseTransformIterative(const VecType& element,
                                                                     const VecType& rootOfUnityInverseTable,
                                                                     VecType* result) {

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               VecType* element) {
    usint n         = element->GetLength();

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        VecType* result) {

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::ForwardTransformToBitReverseInPlace(const VecType& rootOfUnityTable,
                                                                               const VecType& preconRootOfUnityTable,
                                                                               VecType* element) {

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                        const VecType& rootOfUnityTable,
                                                                        const VecType& preconRootOfUnityTable,

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::InverseTransformFromBitReverseInPlace(const VecType& rootOfUnityInverseTable,
                                                                                 const IntType& cycloOrderInv,
                                                                                 VecType* element) {

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                          const VecType& rootOfUnityInverseTable,
                                                                          const IntType& cycloOrderInv,

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::InverseTransformFromBitReverseInPlace(
    const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable, const IntType& cycloOrderInv,
    const IntType& preconCycloOrderInv, VecType* element) {

template <typename VecType>
void NumberTheoreticTransformNat<VecType>::InverseTransformFromBitReverse(
    const VecType& element, const VecType& rootOfUnityInverseTable, const VecType& preconRootOfUnityInverseTable,
    const IntType& cycloOrderInv, const IntType& preconCycloOrderInv, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTNat<VecType>::ForwardTransformToBitReverseInPlace(const IntType& rootOfUnity,
                                                                                   const usint CycloOrder,
                                                                                   VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTNat<VecType>::ForwardTransformToBitReverse(const VecType& element,
                                                                            const IntType& rootOfUnity,
                                                                            const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTNat<VecType>::InverseTransformFromBitReverseInPlace(const IntType& rootOfUnity,
                                                                                     const usint CycloOrder,
                                                                                     VecType* element) {

template <typename VecType>
void ChineseRemainderTransformFTTNat<VecType>::InverseTransformFromBitReverse(const VecType& element,
                                                                              const IntType& rootOfUnity,
                                                                              const usint CycloOrder, VecType* result) {

template <typename VecType>
void ChineseRemainderTransformFTTNat<VecType>::PreCompute(const IntType& rootOfUnity, const usint CycloOrder,
                                                          const IntType& modulus) {
    usint CycloOrderHf = (CycloOrder >> 1);

template <typename VecType>
void ChineseRemainderTransformFTTNat<VecType>::PreCompute(std::vector<IntType>& rootOfUnity, const usint CycloOrder,
                                                          std::vector<IntType>& moduliiChain) {
    usint numOfRootU = rootOfUnity.size();

template <typename VecType>
void ChineseRemainderTransformFTTNat<VecType>::Reset() {
    m_cycloOrderInverseTableByModulus.clear();
    m_cycloOrderInversePreconTableByModulus.clear();

template <typename VecType>
void BluesteinFFTNat<VecType>::PreComputeDefaultNTTModulusRoot(usint cycloOrder, const IntType& modulus) {
    usint nttDim                              = pow(2, ceil(log2(2 * cycloOrder - 1)));
    const auto nttModulus                     = LastPrime<IntType>(log2(nttDim) + 2 * modulus.GetMSB(), nttDim);

template <typename VecType>
void BluesteinFFTNat<VecType>::PreComputeRootTableForNTT(usint cyclotoOrder,
                                                         const ModulusRoot<IntType>& nttModulusRoot) {
    usint nttDim           = pow(2, ceil(log2(2 * cyclotoOrder - 1)));

template <typename VecType>
void BluesteinFFTNat<VecType>::PreComputePowers(usint cycloOrder, const ModulusRoot<IntType>& modulusRoot) {
    const auto& modulus = modulusRoot.first;
    const auto& root    = modulusRoot.second;

template <typename VecType>
void BluesteinFFTNat<VecType>::PreComputeRBTable(usint cycloOrder, const ModulusRootPair<IntType>& modulusRootPair) {
    const auto& modulusRoot = modulusRootPair.first;
    const auto& modulus     = modulusRoot.first;

template <typename VecType>
VecType BluesteinFFTNat<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                   const usint cycloOrder) {
    const auto& modulus        = element.GetModulus();

template <typename VecType>
VecType BluesteinFFTNat<VecType>::ForwardTransform(const VecType& element, const IntType& root, const usint cycloOrder,
                                                   const ModulusRoot<IntType>& nttModulusRoot) {
    if (element.GetLength() != cycloOrder) {

template <typename VecType>
VecType BluesteinFFTNat<VecType>::PadZeros(const VecType& a, const usint finalSize) {
    usint s = a.GetLength();
    VecType result(finalSize, a.GetModulus());

template <typename VecType>
VecType BluesteinFFTNat<VecType>::Resize(const VecType& a, usint lo, usint hi) {
    VecType result(hi - lo + 1, a.GetModulus());


template <typename VecType>
void BluesteinFFTNat<VecType>::Reset() {
    m_rootOfUnityTableByModulusRoot.clear();
    m_rootOfUnityInverseTableByModulusRoot.clear();

template <typename VecType>
void ChineseRemainderTransformArbNat<VecType>::SetCylotomicPolynomial(const VecType& poly, const IntType& mod) {
    m_cyclotomicPolyMap[mod] = poly;
}

template <typename VecType>
void ChineseRemainderTransformArbNat<VecType>::PreCompute(const usint cyclotoOrder, const IntType& modulus) {
    BluesteinFFTNat<VecType>().PreComputeDefaultNTTModulusRoot(cyclotoOrder, modulus);
}

template <typename VecType>
void ChineseRemainderTransformArbNat<VecType>::SetPreComputedNTTModulus(usint cyclotoOrder, const IntType& modulus,
                                                                        const IntType& nttModulus,
                                                                        const IntType& nttRoot) {

template <typename VecType>
void ChineseRemainderTransformArbNat<VecType>::SetPreComputedNTTDivisionModulus(usint cyclotoOrder,
                                                                                const IntType& modulus,
                                                                                const IntType& nttMod,

template <typename VecType>
VecType ChineseRemainderTransformArbNat<VecType>::InversePolyMod(const VecType& cycloPoly, const IntType& modulus,
                                                                 usint power) {
    VecType result(power, modulus);

template <typename VecType>
VecType ChineseRemainderTransformArbNat<VecType>::ForwardTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbNat<VecType>::InverseTransform(const VecType& element, const IntType& root,
                                                                   const IntType& nttModulus, const IntType& nttRoot,
                                                                   const usint cycloOrder) {

template <typename VecType>
VecType ChineseRemainderTransformArbNat<VecType>::Pad(const VecType& element, const usint cycloOrder, bool forward) {
    usint n = GetTotient(cycloOrder);


template <typename VecType>
VecType ChineseRemainderTransformArbNat<VecType>::Drop(const VecType& element, const usint cycloOrder, bool forward,
                                                       const IntType& bigMod, const IntType& bigRoot) {
    usint n = GetTotient(cycloOrder);

template <typename VecType>
void ChineseRemainderTransformArbNat<VecType>::Reset() {
    m_cyclotomicPolyMap.clear();
    m_cyclotomicPolyReverseNTTMap.clear();


//========================================
//===== File: ./src/core/include/math/hal/intnat/ubintnat.h =====
//========================================

namespace intnat {

// Forward declare class and give it an alias for the expected type
template <typename IntType>
class NativeIntegerT;
using NativeInteger = NativeIntegerT<BasicInteger>;

template <typename IntType>
class NativeVectorT;

// constexpr double LOG2_10 = 3.32192809;  //!< @brief A pre-computed  constant of Log base 2 of 10.
// constexpr usint BARRETT_LEVELS = 8;  //!< @brief The number of levels (precomputed
 */
template <typename utype>
struct DataTypes {
    using SignedType       = void;
    using DoubleType       = void;
    using SignedDoubleType = void;
};
template <>
struct DataTypes<uint32_t> {
    using SignedType       = int32_t;
    using DoubleType       = uint64_t;
    using SignedDoubleType = int64_t;
};
template <>
struct DataTypes<uint64_t> {
    using SignedType = int64_t;
#if defined(HAVE_INT128)
    using DoubleType       = uint128_t;
#if defined(HAVE_INT128)
template <>
struct DataTypes<uint128_t> {
    using SignedType       = int128_t;
    using DoubleType       = uint128_t;
    using SignedDoubleType = int128_t;
 */
template <typename NativeInt>
class NativeIntegerT final : public lbcrypto::BigIntegerInterface<NativeIntegerT<NativeInt>> {
private:
    NativeInt m_value{0};

    // variable to store the maximum value of the integral data type.
    static constexpr NativeInt m_uintMax{std::numeric_limits<NativeInt>::max()};
    // variable to store the bit width of the integral data type.
    //    static constexpr usint m_uintBitLength{sizeof(NativeInt) * 8};
    static constexpr usint m_uintBitLength{std::numeric_limits<NativeInt>::digits};

    friend class NativeVectorT<NativeIntegerT<NativeInt>>;

public:
    using Integer         = NativeInt;
    using SignedNativeInt = typename DataTypes<NativeInt>::SignedType;
    using DNativeInt      = typename DataTypes<NativeInt>::DoubleType;
    // data structure to represent a double-word integer as two single-word integers
    struct typeD {
        NativeInt hi{0};
        NativeInt lo{0};
        inline std::string ConvertToString() const {

    explicit operator NativeInt() const {
        return m_value;
    }
    explicit operator bool() const {
        return m_value != 0;
    }


    explicit NativeIntegerT(const char* strval) {
        this->NativeIntegerT::SetValue(std::string(strval));
    }
    // explicit NativeIntegerT(const char strval) : m_value{NativeInt(strval - '0')} {}

    template <typename T,
              std::enable_if_t<std::is_integral_v<T> || std::is_same_v<T, int128_t> || std::is_same_v<T, uint128_t>,
                               bool> = true>
    constexpr NativeIntegerT(T val) noexcept : m_value(val) {}

    template <typename T, std::enable_if_t<std::is_same_v<T, M2Integer> || std::is_same_v<T, M4Integer> ||
                                               std::is_same_v<T, M6Integer>,
                                           bool> = true>
    constexpr NativeIntegerT(T val) noexcept : m_value{val.template ConvertToInt<NativeInt>()} {}

    template <typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
    NativeIntegerT(T val) = delete;

    constexpr NativeIntegerT& operator=(const NativeIntegerT& val) noexcept {

    template <typename T,
              std::enable_if_t<std::is_integral_v<T> || std::is_same_v<T, int128_t> || std::is_same_v<T, uint128_t>,
                               bool> = true>
    constexpr NativeIntegerT& operator=(T val) noexcept {

    template <typename T, std::enable_if_t<std::is_same_v<T, M2Integer> || std::is_same_v<T, M4Integer> ||
                                               std::is_same_v<T, M6Integer>,
                                           bool> = true>
    constexpr NativeIntegerT& operator=(T val) noexcept {

    template <typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
    NativeIntegerT& operator=(T val) = delete;

    /**
        return *this =
                   static_cast<NativeInt>(p.ConvertToDouble() * (this->ConvertToDouble() / q.ConvertToDouble()) + 0.5);
    }

    /**
   */
    template <typename T = NativeInt>
    NativeIntegerT ComputeMu(typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) const {
        if (m_value == 0)
            OPENFHE_THROW("NativeIntegerT ComputeMu: Divide by zero");

    template <typename T = NativeInt>
    NativeIntegerT ComputeMu(typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) const {
        if (m_value == 0)
            OPENFHE_THROW("NativeIntegerT ComputeMu: Divide by zero");
   */
    template <typename T = NativeInt>
    NativeIntegerT ModAdd(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                          typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) const {
        auto& mv{modulus.m_value};

    template <typename T = NativeInt>
    NativeIntegerT ModAdd(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                          typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) const {
        auto av{*this};
   */
    template <typename T = NativeInt>
    NativeIntegerT& ModAddEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                             typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) {
        auto& mv{modulus.m_value};

    template <typename T = NativeInt>
    NativeIntegerT& ModAddEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                             typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) {
        auto av{*this};
   */
    template <typename T = NativeInt>
    NativeIntegerT ModSub(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                          typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) const {
        auto& mv{modulus.m_value};

    template <typename T = NativeInt>
    NativeIntegerT ModSub(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                          typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) const {
        auto av{*this};

    template <typename T = NativeInt>
    NativeIntegerT& ModSubEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                             typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) {
        auto& mv{modulus.m_value};

    template <typename T = NativeInt>
    NativeIntegerT& ModSubEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                             typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) {
        auto av{*this};
   */
    template <typename T = NativeInt>
    NativeIntegerT ModMul(const NativeIntegerT& b, const NativeIntegerT& modulus,
                          typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) const {
        auto av{m_value};

    template <typename T = NativeInt>
    NativeIntegerT ModMul(const NativeIntegerT& b, const NativeIntegerT& modulus,
                          typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) const {
        typeD tmp;
   */
    template <typename T = NativeInt>
    NativeIntegerT& ModMulEq(const NativeIntegerT& b, const NativeIntegerT& modulus,
                             typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) {
        auto av{m_value};

    template <typename T = NativeInt>
    NativeIntegerT& ModMulEq(const NativeIntegerT& b, const NativeIntegerT& modulus,
                             typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) {
        auto av{*this};
   */
    template <typename T = NativeInt>
    NativeIntegerT ModMul(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                          typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) const {
#ifdef NATIVEINT_BARRET_MOD

    template <typename T = NativeInt>
    NativeIntegerT ModMul(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                          typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) const {
        auto av{*this};
   */
    template <typename T = NativeInt>
    NativeIntegerT& ModMulEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                             typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) {
#ifdef NATIVEINT_BARRET_MOD

    template <typename T = NativeInt>
    NativeIntegerT& ModMulEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                             typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) {
        int64_t n{modulus.GetMSB() - 2};
   */
    template <typename T = NativeInt>
    NativeIntegerT ModMulFast(const NativeIntegerT& b, const NativeIntegerT& modulus,
                              typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) const {
        DNativeInt rv{static_cast<DNativeInt>(m_value) * b.m_value};

    template <typename T = NativeInt>
    NativeIntegerT ModMulFast(const NativeIntegerT& b, const NativeIntegerT& modulus,
                              typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) const {
        int64_t n = modulus.GetMSB() - 2;
    // TODO: find what in Matrix<DCRTPoly> is calling ModMulFastEq incorrectly
    template <typename T = NativeInt>
    NativeIntegerT ModMulFastEq(const NativeIntegerT& b, const NativeIntegerT& modulus,
                                typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) {
        DNativeInt rv{static_cast<DNativeInt>(m_value) * b.m_value};

    template <typename T = NativeInt>
    NativeIntegerT ModMulFastEq(const NativeIntegerT& b, const NativeIntegerT& modulus,
                                typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) {
        int64_t n = modulus.GetMSB() - 2;
    */
    template <typename T = NativeInt>
    NativeIntegerT ModMulFast(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                              typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) const {
        int64_t n = modulus.GetMSB() - 2;

    template <typename T = NativeInt>
    NativeIntegerT ModMulFast(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                              typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) const {
        int64_t n = modulus.GetMSB() - 2;
   */
    template <typename T = NativeInt>
    NativeIntegerT& ModMulFastEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                                 typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) {
        typeD tmp;

    template <typename T = NativeInt>
    NativeIntegerT& ModMulFastEq(const NativeIntegerT& b, const NativeIntegerT& modulus, const NativeIntegerT& mu,
                                 typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) {
        int64_t n{modulus.GetMSB() - 2};
   */
    template <typename T = NativeInt>
    NativeIntegerT PrepModMulConst(
        const NativeIntegerT& modulus,
        typename std::enable_if<!std::is_same<T, DNativeInt>::value, bool>::type = true) const {

    template <typename T = NativeInt>
    NativeIntegerT PrepModMulConst(
        const NativeIntegerT& modulus,
        typename std::enable_if<std::is_same<T, DNativeInt>::value, bool>::type = true) const {
   */
    template <typename T = NativeInt>
    NativeIntegerT ModExp(const NativeIntegerT& b, const NativeIntegerT& mod,
                          typename std::enable_if<!std::is_same<T, DNativeInt>::value, bool>::type = true) const {
        DNativeInt t{m_value};

    template <typename T = NativeInt>
    NativeIntegerT ModExp(const NativeIntegerT& b, const NativeIntegerT& mod,
                          typename std::enable_if<std::is_same<T, DNativeInt>::value, bool>::type = true) const {
        NativeIntegerT t{m_value % mod.m_value};
   */
    template <typename T             = NativeInt,
              std::enable_if_t<std::is_integral_v<T> || std::is_same_v<T, int128_t> || std::is_same_v<T, uint128_t>,
                               bool> = true>
    constexpr T ConvertToInt() const noexcept {
   */
    static NativeIntegerT FromBinaryString(const std::string& bitString) {
        if (bitString.length() > NativeIntegerT::MaxBits())
            OPENFHE_THROW("Bit string is too long to fit in an intnat");
        NativeInt v{0};
   */
    static constexpr NativeIntegerT Allocator() noexcept {
        return NativeIntegerT();
    }


    static const std::string IntegerTypeName() {
        return "UBNATINT";
    }


    template <class Archive, typename T = void>
    typename std::enable_if_t<std::is_same_v<NativeInt, uint64_t> || std::is_same_v<NativeInt, uint32_t>, T> load(
        Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
#if defined(HAVE_INT128)
    template <class Archive>
    typename std::enable_if_t<std::is_same_v<NativeInt, uint128_t> && !cereal::traits::is_text_archive<Archive>::value,
                              void>
    load(Archive& ar, std::uint32_t const version) {

    template <class Archive>
    typename std::enable_if_t<std::is_same_v<NativeInt, uint128_t> && cereal::traits::is_text_archive<Archive>::value,
                              void>
    load(Archive& ar, std::uint32_t const version) {

    template <class Archive, typename T = void>
    typename std::enable_if_t<std::is_same_v<NativeInt, uint64_t> || std::is_same<NativeInt, uint32_t>::value, T> save(
        Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("v", m_value));
#if defined(HAVE_INT128)
    template <class Archive>
    typename std::enable_if_t<std::is_same_v<NativeInt, uint128_t> && !cereal::traits::is_text_archive<Archive>::value,
                              void>
    save(Archive& ar, std::uint32_t const version) const {

    template <class Archive>
    typename std::enable_if_t<std::is_same_v<NativeInt, uint128_t> && cereal::traits::is_text_archive<Archive>::value,
                              void>
    save(Archive& ar, std::uint32_t const version) const {

    static uint32_t SerializedVersion() {
        return 1;
    }

    static constexpr usint MaxBits() noexcept {
        return m_uintBitLength;
    }

    static constexpr bool IsNativeInt() noexcept {
        return true;
    }

private:
    // Computes res -= a;
    static void SubtractD(typeD& res, const typeD& a) {
        if (res.lo < a.lo) {
            res.lo += m_uintMax + 1 - a.lo;
            res.hi--;
   */
    static NativeInt RShiftD(const typeD& x, int64_t shift) {
        return (x.lo >> shift) | (x.hi << (NativeIntegerT::MaxBits() - shift));
    }

   */
    static void MultD(NativeInt a, NativeInt b, typeD& res) {
        if constexpr (std::is_same_v<NativeInt, uint32_t>) {
            uint64_t c{static_cast<uint64_t>(a) * b};
            res.hi = static_cast<uint32_t>(c >> 32);
        if constexpr (std::is_same_v<NativeInt, uint128_t>) {
            static constexpr uint128_t masklo = (static_cast<uint128_t>(1) << 64) - 1;
            static constexpr uint128_t onehi  = static_cast<uint128_t>(1) << 64;

            uint128_t a1{a >> 64};
            uint128_t a2{a & masklo};
   */
    static NativeInt MultDHi(NativeInt a, NativeInt b) {
        typeD x;
        MultD(a, b, x);
        return x.hi;
   */
    static DNativeInt GetD(const typeD& x) {
        return (DNativeInt(x.hi) << NativeIntegerT::MaxBits()) | x.lo;
    }

    static std::string toString(uint32_t value) noexcept {
        return std::to_string(value);
    }

    static std::string toString(uint64_t value) noexcept {
        return std::to_string(value);
    }

    // TODO
    static std::string toString(uint128_t value) noexcept {
        constexpr size_t maxChars = 15;
        constexpr uint128_t divisor{0x38d7ea4c68000};  // 10**15
        std::string tmp(46, '0');

    template <typename T = NativeInt>
    static void ModMu(typeD& prod, NativeIntegerT& a, const T& mv, const T& mu, int64_t n,
                      typename std::enable_if_t<!std::is_same_v<T, DNativeInt>, bool> = true) {
        prod = {0, a.m_value};
        MultD(RShiftD(prod, n), mu, prod);

    template <typename T = NativeInt>
    static void ModMu(typeD& prod, NativeIntegerT& a, const T& mv, const T& mu, int64_t n,
                      typename std::enable_if_t<std::is_same_v<T, DNativeInt>, bool> = true) {
        prod = {0, a.m_value};
        MultD(RShiftD(prod, n), mu, prod);
// helper template to stream vector contents provided T has an stream operator<<
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {
    os << "[";
    //    for (const auto& i : v)
// to stream internal representation
template std::ostream& operator<< <uint64_t>(std::ostream& os, const std::vector<uint64_t>& v);

}  // namespace intnat



//========================================
//===== File: ./src/core/include/math/hal/nativeintbackend.h =====
//========================================

namespace lbcrypto {

using NativeInteger = intnat::NativeInteger;
using NativeVector  = intnat::NativeVector;


//========================================
//===== File: ./src/core/include/math/hal/transform.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Golden Chinese Remainder Transform FFT implementation.
 */
template <typename VecType>
class ChineseRemainderTransformFTTInterface {
    using IntType = typename VecType::Integer;

public:
    /**
   * Copies \p element into \p result and calls NumberTheoreticTransform::ForwardTransformToBitReverseInPlace()
   *
   */
    virtual void ForwardTransformToBitReverse(const VecType& element, const IntType& rootOfUnity,
                                              const usint CycloOrder, VecType* result) = 0;

    /**
   */
    virtual void ForwardTransformToBitReverseInPlace(const IntType& rootOfUnity, const usint CycloOrder,
                                                     VecType* element) = 0;

    /**
   */
    virtual void InverseTransformFromBitReverse(const VecType& element, const IntType& rootOfUnity,
                                                const usint CycloOrder, VecType* result) = 0;

    /**
   */
    virtual void InverseTransformFromBitReverseInPlace(const IntType& rootOfUnity, const usint CycloOrder,
                                                       VecType* element) = 0;

    /**
   */
    virtual void PreCompute(const IntType& rootOfUnity, const usint CycloOrder, const IntType& modulus) = 0;

    /**
   * Precomputation of root of unity tables for transforms in the ring
   */
    virtual void PreCompute(std::vector<IntType>& rootOfUnity, const usint CycloOrder,
                            std::vector<IntType>& moduliChain) = 0;

    /**
   */
    virtual void Reset() = 0;
};

/**
 */
template <typename VecType>
class ChineseRemainderTransformArbInterface {
    using IntType = typename VecType::Integer;

public:
    /**
   * Sets the cyclotomic polynomial.
   *
   */
    virtual void SetCylotomicPolynomial(const VecType& poly, const IntType& mod) = 0;

    /**
   * Forward transform.
   */
    virtual VecType ForwardTransform(const VecType& element, const IntType& root, const IntType& bigMod,
                                     const IntType& bigRoot, const usint cycloOrder) = 0;

    /**
   */
    virtual VecType InverseTransform(const VecType& element, const IntType& root, const IntType& bigMod,
                                     const IntType& bigRoot, const usint cycloOrder) = 0;

    /**
   */
    virtual void Reset() = 0;

    /**
   * @brief Precomputes the root of unity and modulus needed for NTT operation
   */
    virtual void PreCompute(const usint cyclotoOrder, const IntType& modulus) = 0;

    /**
   * @brief Sets the precomputed root of unity and modulus needed for NTT
   */
    virtual void SetPreComputedNTTModulus(usint cyclotoOrder, const IntType& modulus, const IntType& nttMod,
                                          const IntType& nttRoot) = 0;

    /**
   */
    virtual void SetPreComputedNTTDivisionModulus(usint cyclotoOrder, const IntType& modulus, const IntType& nttMod,
                                                  const IntType& nttRoot) = 0;

    /**
   */
    virtual VecType InversePolyMod(const VecType& cycloPoly, const IntType& modulus, usint power) = 0;

private:
    /**
   * @brief Padding zeroes to a vector
   * @param &element is the input of type VecType to be padded with zeros.
   */
    virtual VecType Pad(const VecType& element, const usint cycloOrder, bool forward) = 0;

    /**
   * @brief Dropping elements from a vector
   */
    virtual VecType Drop(const VecType& element, const usint cycloOrder, bool forward, const IntType& bigMod,
                         const IntType& bigRoot) = 0;
};
}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/math/hal/vector.h =====
//========================================

namespace lbcrypto {

template <typename T, typename I>
class BigVectorInterface {
public:
    typedef I Integer;

    // CONSTRUCTORS


protected:
    ~BigVectorInterface() = default;

    // STRINGS & STREAMS


//========================================
//===== File: ./src/core/include/math/math-hal.h =====
//========================================

namespace lbcrypto {
// Promote BigInteger and BigVector to lbcrypto namespace
using BigInteger = bigintbackend::BigInteger;
using BigVector  = bigintbackend::BigVector;
// TODO: total hack ... move this!!!!!
template <typename VecType>
using NatChineseRemainderTransformFTT = intnat::ChineseRemainderTransformFTTNat<VecType>;
template <typename VecType>
using NatChineseRemainderTransformArb = intnat::ChineseRemainderTransformArbNat<VecType>;

//==============================================================================================

template <typename VecType>
struct FTTTypedef {
    typedef void type;
};

template <>
struct FTTTypedef<NativeVector> {
    typedef NatChineseRemainderTransformFTT<NativeVector> type;
};

#ifdef WITH_BE2
template <>
struct FTTTypedef<M2Vector> {
    typedef bigintfxd::ChineseRemainderTransformFTTFxd<M2Vector> type;
};
#endif

#ifdef WITH_BE4
template <>
struct FTTTypedef<M4Vector> {
    typedef bigintdyn::ChineseRemainderTransformFTTDyn<M4Vector> type;
};
#endif

#ifdef WITH_NTL
template <>
struct FTTTypedef<M6Vector> {
    typedef NTL::ChineseRemainderTransformFTTNtl<M6Vector> type;
};
#endif

template <typename VecType>
using ChineseRemainderTransformFTT = typename FTTTypedef<VecType>::type;

//==============================================================================================

template <typename VecType>
struct ArbTypedef {
    typedef void type;
};

template <>
struct ArbTypedef<NativeVector> {
    typedef NatChineseRemainderTransformArb<NativeVector> type;
};

#ifdef WITH_BE2
template <>
struct ArbTypedef<M2Vector> {
    typedef bigintfxd::ChineseRemainderTransformArbFxd<M2Vector> type;
};
#endif

#ifdef WITH_BE4
template <>
struct ArbTypedef<M4Vector> {
    typedef bigintdyn::ChineseRemainderTransformArbDyn<M4Vector> type;
};
#endif

#ifdef WITH_NTL
template <>
struct ArbTypedef<M6Vector> {
    typedef NTL::ChineseRemainderTransformArbNtl<M6Vector> type;
};
#endif

template <typename VecType>
using ChineseRemainderTransformArb = typename ArbTypedef<VecType>::type;

#endif


//========================================
//===== File: ./src/core/include/math/matrix.h =====
//========================================

namespace lbcrypto {

// Forward declaration
class Field2n;

template <class Element>
class Matrix : public Serializable {
public:
    typedef std::vector<std::vector<Element>> data_t;
    typedef std::vector<Element> data_row_t;
    typedef std::function<Element(void)> alloc_func;

    /**
   * Constructor that initializes matrix values using a zero allocator
   */
    explicit Matrix(alloc_func allocZero = 0) : data(), rows(0), cols(0), allocZero(allocZero) {}

    /**
   * Set the size of a matrix, elements are zeroed out
   */
    template <typename T                          = Element,
              typename std::enable_if<!std::is_same<T, M2DCRTPoly>::value && !std::is_same<T, M4DCRTPoly>::value &&
                                          !std::is_same<T, M6DCRTPoly>::value,
                                      bool>::type = true>

    template <typename T                          = Element,
              typename std::enable_if<std::is_same<T, M2DCRTPoly>::value || std::is_same<T, M4DCRTPoly>::value ||
                                          std::is_same<T, M6DCRTPoly>::value,
                                      bool>::type = true>
   */
    template <typename T                          = Element,
              typename std::enable_if<std::is_same<T, double>::value || std::is_same<T, int>::value ||
                                          std::is_same<T, int64_t>::value || std::is_same<T, Field2n>::value,
                                      bool>::type = true>

    template <typename T                          = Element,
              typename std::enable_if<!std::is_same<T, double>::value && !std::is_same<T, int>::value &&
                                          !std::is_same<T, int64_t>::value && !std::is_same<T, Field2n>::value,
                                      bool>::type = true>
#define NOT_AN_ELEMENT_MATRIX(T)                   \
    template <>                                    \
    void Matrix<T>::SwitchFormat() {               \
        OPENFHE_THROW("Not a matrix of Elements"); \
    }

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("d", data));
        ar(::cereal::make_nvp("r", rows));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    data_t data;
    uint32_t rows;
    uint32_t cols;
 */
template <class Element>
Matrix<Element> operator*(Element const& e, Matrix<Element> const& M) {
    return M.ScalarMult(e);
}
 */
template <typename Element>
Matrix<typename Element::Integer> Rotate(Matrix<Element> const& inMat);

/**
 */
template <typename Element>
Matrix<typename Element::Vector> RotateVecResult(Matrix<Element> const& inMat);

/**
 */
template <class Element>
std::ostream& operator<<(std::ostream& os, const Matrix<Element>& m);

/**
 */
template <typename Element>
Matrix<Element> SplitInt64IntoElements(Matrix<int64_t> const& other, size_t n,
                                       const std::shared_ptr<typename Element::Params> params);

#define SPLIT64_FOR_TYPE(T)                                                              \
    template <>                                                                          \
    Matrix<T> SplitInt64IntoElements(Matrix<int64_t> const& other, size_t n,             \
                                     const std::shared_ptr<typename T::Params> params) { \
        auto zero_alloc = T::Allocator(params, Format::COEFFICIENT);                     \
 */
template <typename Element>
Matrix<Element> SplitInt32AltIntoElements(Matrix<int32_t> const& other, size_t n,
                                          const std::shared_ptr<typename Element::Params> params);

#define SPLIT32ALT_FOR_TYPE(T)                                                              \
    template <>                                                                             \
    Matrix<T> SplitInt32AltIntoElements(Matrix<int32_t> const& other, size_t n,             \
                                        const std::shared_ptr<typename T::Params> params) { \
        auto zero_alloc = T::Allocator(params, Format::COEFFICIENT);                        \
 */
template <typename Element>
Matrix<Element> SplitInt64AltIntoElements(Matrix<int64_t> const& other, size_t n,
                                          const std::shared_ptr<typename Element::Params> params);

#define SPLIT64ALT_FOR_TYPE(T)                                                              \
    template <>                                                                             \
    Matrix<T> SplitInt64AltIntoElements(Matrix<int64_t> const& other, size_t n,             \
                                        const std::shared_ptr<typename T::Params> params) { \
        auto zero_alloc = T::Allocator(params, Format::COEFFICIENT);                        \


//========================================
//===== File: ./src/core/include/math/matrix-impl.h =====
//========================================

namespace lbcrypto {

template <class Element>
Matrix<Element>::Matrix(alloc_func allocZero, size_t rows, size_t cols, alloc_func allocGen)
    : data(), rows(rows), cols(cols), allocZero(allocZero) {
    data.resize(rows);

template <class Element>
Matrix<Element>& Matrix<Element>::operator=(const Matrix<Element>& other) {
    rows = other.rows;
    cols = other.cols;

template <class Element>
Matrix<Element>& Matrix<Element>::Fill(const Element& val) {
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {

template <class Element>
Matrix<Element> Matrix<Element>::Mult(Matrix<Element> const& other) const {
    // NUM_THREADS = omp_get_max_threads();


template <class Element>
Matrix<Element>& Matrix<Element>::operator+=(Matrix<Element> const& other) {
    if (rows != other.rows || cols != other.cols) {
        OPENFHE_THROW("Addition operands have incompatible dimensions");

template <class Element>
Matrix<Element>& Matrix<Element>::operator-=(Matrix<Element> const& other) {
    if (rows != other.rows || cols != other.cols) {
        OPENFHE_THROW("Subtraction operands have incompatible dimensions");

template <class Element>
Matrix<Element> Matrix<Element>::Transpose() const {
    Matrix<Element> result(allocZero, cols, rows);
    for (size_t row = 0; row < rows; ++row) {
// decomposition or the Cholesky decomposition(for positive definite matrices).
template <class Element>
void Matrix<Element>::Determinant(Element* determinant) const {
    if (rows != cols)
        OPENFHE_THROW("Supported only for square matrix");
// multiplied by -1^{i+j} The determinant subroutine is used
template <class Element>
Matrix<Element> Matrix<Element>::CofactorMatrix() const {
    if (rows != cols)
        OPENFHE_THROW("Supported only for square matrix");
//  add rows to bottom of the matrix
template <class Element>
Matrix<Element>& Matrix<Element>::VStack(Matrix<Element> const& other) {
    if (cols != other.cols) {
        OPENFHE_THROW("VStack rows not equal size");
//  add cols to right of the matrix
template <class Element>
inline Matrix<Element>& Matrix<Element>::HStack(Matrix<Element> const& other) {
    if (rows != other.rows) {
        OPENFHE_THROW("HStack cols not equal size");
 */
template <class Element>
Matrix<Element> Matrix<Element>::MultByUnityVector() const {
    Matrix<Element> result(allocZero, rows, 1);

 */
template <class Element>
Matrix<Element> Matrix<Element>::MultByRandomVector(std::vector<int> ranvec) const {
    Matrix<Element> result(allocZero, rows, 1);



//========================================
//===== File: ./src/core/include/math/matrixstrassen.h =====
//========================================

namespace lbcrypto {

template <class Element>
class MatrixStrassen {  // TODO : public Serializable {
public:
    typedef std::vector<std::vector<Element>> data_t;
    typedef std::vector<Element> lineardata_t;
    typedef typename std::vector<Element>::iterator it_lineardata_t;
    typedef std::function<Element(void)> alloc_func;

    /**
   * Constructor that initializes matrix values using a zero allocator
   */
    explicit MatrixStrassen(alloc_func allocZero) : data(), rows(0), cols(0), allocZero(allocZero) {}

    void SetSize(size_t rows, size_t cols) {
        if (this->rows != 0 || this->cols != 0) {

private:
    struct MatDescriptor {
        int lda;
        int nrec;
        int nproc;
 */
template <class Element>
inline MatrixStrassen<Element> operator*(Element const& e, MatrixStrassen<Element> const& M) {
    return M.ScalarMult(e);
}
 */
template <class Element>
inline std::ostream& operator<<(std::ostream& os, const MatrixStrassen<Element>& m);

/**


//========================================
//===== File: ./src/core/include/math/matrixstrassen-impl.h =====
//========================================

namespace lbcrypto {

template <class Element>
MatrixStrassen<Element>::MatrixStrassen(alloc_func allocZero, size_t rows, size_t cols, alloc_func allocGen)
    : data(), rows(rows), cols(cols), allocZero(allocZero) {
    data.resize(rows);

template <class Element>
MatrixStrassen<Element>& MatrixStrassen<Element>::operator=(const MatrixStrassen<Element>& other) {
    rows = other.rows;
    cols = other.cols;

template <class Element>
MatrixStrassen<Element>& MatrixStrassen<Element>::Ones() {
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {

template <class Element>
MatrixStrassen<Element>& MatrixStrassen<Element>::Fill(const Element& val) {
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {

template <class Element>
MatrixStrassen<Element>& MatrixStrassen<Element>::Identity() {
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {

template <class Element>
MatrixStrassen<Element> MatrixStrassen<Element>::GadgetVector(int32_t base) const {
    MatrixStrassen<Element> g(allocZero, rows, cols);
    // auto two = allocZero();

template <class Element>
double MatrixStrassen<Element>::Norm() const {
    double retVal = 0.0;
    double locVal = 0.0;

template <class Element>
void MatrixStrassen<Element>::SetFormat(Format format) {
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {

template <class Element>
MatrixStrassen<Element>& MatrixStrassen<Element>::operator+=(MatrixStrassen<Element> const& other) {
    if (rows != other.rows || cols != other.cols) {
        OPENFHE_THROW("Addition operands have incompatible dimensions");

template <class Element>
inline MatrixStrassen<Element>& MatrixStrassen<Element>::operator-=(MatrixStrassen<Element> const& other) {
    if (rows != other.rows || cols != other.cols) {
        OPENFHE_THROW("Subtraction operands have incompatible dimensions");

template <class Element>
MatrixStrassen<Element> MatrixStrassen<Element>::Transpose() const {
    MatrixStrassen<Element> result(allocZero, cols, rows);
    for (size_t row = 0; row < rows; ++row) {
// decomposition or the Cholesky decomposition(for positive definite matrices).
template <class Element>
void MatrixStrassen<Element>::Determinant(Element* determinant) const {
    if (rows != cols)
        OPENFHE_THROW("Supported only for square matrix");
// multiplied by -1^{i+j} The determinant subroutine is used
template <class Element>
MatrixStrassen<Element> MatrixStrassen<Element>::CofactorMatrixStrassen() const {
    if (rows != cols)
        OPENFHE_THROW("Supported only for square matrix");
//  add rows to bottom of the matrix
template <class Element>
MatrixStrassen<Element>& MatrixStrassen<Element>::VStack(MatrixStrassen<Element> const& other) {
    if (cols != other.cols) {
        OPENFHE_THROW("VStack rows not equal size");
//  add cols to right of the matrix
template <class Element>
inline MatrixStrassen<Element>& MatrixStrassen<Element>::HStack(MatrixStrassen<Element> const& other) {
    if (rows != other.rows) {
        OPENFHE_THROW("HStack cols not equal size");

template <class Element>
void MatrixStrassen<Element>::SwitchFormat() {
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {

template <class Element>
void MatrixStrassen<Element>::LinearizeDataCAPS(lineardata_t* lineardataPtr) const {
    lineardataPtr->clear();


template <class Element>
void MatrixStrassen<Element>::UnlinearizeDataCAPS(lineardata_t* lineardataPtr) const {
    int datasize = cols;


template <class Element>
void MatrixStrassen<Element>::deepCopyData(data_t const& src) {
    data.clear();
    data.resize(src.size());

template <class Element>
inline std::ostream& operator<<(std::ostream& os, const MatrixStrassen<Element>& m) {
    os << "[ ";
    for (size_t row = 0; row < m.GetRows(); ++row) {

template <class Element>
MatrixStrassen<Element> MatrixStrassen<Element>::Mult(MatrixStrassen<Element> const& other, int nrec, int pad) const {
    int allrows = rows;

// involved in the multiplication
template <class Element>
void MatrixStrassen<Element>::multiplyInternalCAPS(it_lineardata_t A, it_lineardata_t B, it_lineardata_t C,
                                                   MatDescriptor desc, it_lineardata_t work) const {
    // (planned) out of recursion in the data layout, do a regular matrix

template <class Element>
void MatrixStrassen<Element>::addMatricesCAPS(int numEntries, it_lineardata_t C, it_lineardata_t A,
                                              it_lineardata_t B) const {
#pragma omp parallel for schedule(static, (numEntries + NUM_THREADS - 1) / NUM_THREADS)

template <class Element>
void MatrixStrassen<Element>::subMatricesCAPS(int numEntries, it_lineardata_t C, it_lineardata_t A,
                                              it_lineardata_t B) const {
#pragma omp parallel for schedule(static, (numEntries + NUM_THREADS - 1) / NUM_THREADS)

template <class Element>
void MatrixStrassen<Element>::smartSubtractionCAPS(it_lineardata_t result, it_lineardata_t A, it_lineardata_t B) const {
    Element temp;


template <class Element>
void MatrixStrassen<Element>::smartAdditionCAPS(it_lineardata_t result, it_lineardata_t A, it_lineardata_t B) const {
    Element temp;

// in the order specified
template <class Element>
void MatrixStrassen<Element>::tripleSubMatricesCAPS(int numEntries, it_lineardata_t T1, it_lineardata_t S11,
                                                    it_lineardata_t S12, it_lineardata_t T2, it_lineardata_t S21,
                                                    it_lineardata_t S22, it_lineardata_t T3, it_lineardata_t S31,

template <class Element>
void MatrixStrassen<Element>::tripleAddMatricesCAPS(int numEntries, it_lineardata_t T1, it_lineardata_t S11,
                                                    it_lineardata_t S12, it_lineardata_t T2, it_lineardata_t S21,
                                                    it_lineardata_t S22, it_lineardata_t T3, it_lineardata_t S31,

template <class Element>
void MatrixStrassen<Element>::addSubMatricesCAPS(int numEntries, it_lineardata_t T1, it_lineardata_t S11,
                                                 it_lineardata_t S12, it_lineardata_t T2, it_lineardata_t S21,
                                                 it_lineardata_t S22) const {

template <class Element>
void MatrixStrassen<Element>::strassenDFSCAPS(it_lineardata_t A, it_lineardata_t B, it_lineardata_t C,
                                              MatDescriptor desc, it_lineardata_t workPassThrough) const {
#ifdef SANITY_CHECKS

template <class Element>
void MatrixStrassen<Element>::block_multiplyCAPS(it_lineardata_t A, it_lineardata_t B, it_lineardata_t C,
                                                 MatDescriptor d, it_lineardata_t work) const {
#pragma omp parallel for

template <class Element>
void MatrixStrassen<Element>::sendBlockCAPS(/*MPI_Comm comm,*/ int rank, int target, it_lineardata_t O, int bs,
                                            int source, it_lineardata_t I, int ldi) const {
    if (source == target) {

template <class Element>
void MatrixStrassen<Element>::receiveBlockCAPS(int rank, int target, it_lineardata_t O, int bs, int source,
                                               it_lineardata_t I, int ldo) const {
    if (source == target) {

template <class Element>
void MatrixStrassen<Element>::distributeFrom1ProcRecCAPS(MatDescriptor desc, it_lineardata_t O, it_lineardata_t I,
                                                         int ldi) const {
    if (desc.nrec == 0) {  // base case; put the matrix block-cyclic layout

template <class Element>
void MatrixStrassen<Element>::distributeFrom1ProcCAPS(MatDescriptor desc, it_lineardata_t O, it_lineardata_t I) const {
    distributeFrom1ProcRecCAPS(desc, O, I, desc.lda);
}

template <class Element>
void MatrixStrassen<Element>::collectTo1ProcRecCAPS(MatDescriptor desc, it_lineardata_t O, it_lineardata_t I,
                                                    int ldo) const {
    if (desc.nrec == 0) {  // base case; put the matrix block-cyclic layout

template <class Element>
void MatrixStrassen<Element>::collectTo1ProcCAPS(MatDescriptor desc, it_lineardata_t O, it_lineardata_t I) const {
    collectTo1ProcRecCAPS(desc, O, I, desc.lda);
}

template <class Element>
void MatrixStrassen<Element>::getData(const data_t& Adata, const data_t& Bdata, const data_t& Cdata, int row, int inner,
                                      int col) const {
    printf("Adata[3][0] = %d\n", static_cast<int>(*Adata[3][0]));
 */
template <class Element>
MatrixStrassen<Element> MatrixStrassen<Element>::MultByUnityVector() const {
    MatrixStrassen<Element> result(allocZero, rows, 1);

 */
template <class Element>
MatrixStrassen<Element> MatrixStrassen<Element>::MultByRandomVector(std::vector<int> ranvec) const {
    MatrixStrassen<Element> result(allocZero, rows, 1);
#pragma omp parallel for

template <class Element>
int MatrixStrassen<Element>::getRank() const {
    return rank;
}

template <class Element>
void MatrixStrassen<Element>::verifyDescriptor(MatDescriptor desc) {
    assert(desc.lda % ((1 << desc.nrec) * desc.bs * desc.nprocr) == 0);
    assert(desc.lda % ((1 << desc.nrec) * desc.bs * desc.nprocc) == 0);

template <class Element>
long long MatrixStrassen<Element>::numEntriesPerProc(MatDescriptor desc) const {  // NOLINT
    long long lda = desc.lda;                                                     // NOLINT
    return ((lda * lda) / desc.nproc / desc.nproc_summa);


//========================================
//===== File: ./src/core/include/math/nbtheory.h =====
//========================================
#if defined(HAVE_INT128)
namespace {  // to define local (or C-style static) functions here

inline int clz_u128(uint128_t u) {
    uint64_t hi(u >> 64), lo(u);
 */
namespace lbcrypto {

/**
 * Finds roots of unity for given input.  Assumes the the input is a power of
 */
template <typename IntType>
IntType RootOfUnity(usint m, const IntType& modulo);

/**
 */
template <typename IntType>
std::vector<IntType> RootsOfUnity(usint m, const std::vector<IntType>& moduli);

/**
inline static unsigned char reverse_byte(unsigned char x) {
    static const unsigned char table[] = {
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88,
        0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4,
        0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac,

static int shift_trick[] = {0, 7, 6, 5, 4, 3, 2, 1};

/* Function to reverse bits of num */
inline usint ReverseBits(usint num, usint msb) {
 */
template <
    typename T,
    std::enable_if_t<std::is_integral_v<T> || std::is_same_v<T, int128_t> || std::is_same_v<T, uint128_t>, bool> = true>
inline constexpr usint GetMSB(T x) {
    #if defined(_MSC_VER)
        static_assert(false, "MSVC doesn't support 128-bit integers");
    #endif
        return 128 - clz_u128(uint128_t(x));
    }

template <typename IntType>
std::shared_ptr<std::vector<int64_t>> GetDigits(const IntType& u, uint64_t base, uint32_t k) {
    auto u_vec = std::make_shared<std::vector<int64_t>>(k);

 */
template <typename IntType>
IntType GreatestCommonDivisor(const IntType& a, const IntType& b);

/**
 */
template <typename IntType>
bool MillerRabinPrimalityTest(const IntType& p, const usint niter = 100);

/**
 */
template <typename IntType>
const IntType PollardRhoFactorization(const IntType& n);

/**
 */
template <typename IntType>
void PrimeFactorize(IntType n, std::set<IntType>& primeFactors);

/**
 */
template <typename IntType>
IntType FirstPrime(uint32_t nBits, uint64_t m);

/**
 */
template <typename IntType>
IntType LastPrime(uint32_t nBits, uint64_t m);

/**
 */
template <typename IntType>
IntType NextPrime(const IntType& q, uint64_t m);

/**
 */
template <typename IntType>
IntType PreviousPrime(const IntType& q, uint64_t m);

/**
 */
template <typename IntType>
IntType NextPowerOfTwo(IntType n);

/**
 */
template <typename IntType>
std::vector<IntType> GetTotientList(const IntType& n);

/**
 */
template <typename IntVector>
IntVector PolyMod(const IntVector& dividend, const IntVector& divisor, const typename IntVector::Integer& modulus);

/**
 */
template <typename IntVector>
IntVector PolynomialMultiplication(const IntVector& a, const IntVector& b);

/**
 */
template <typename IntVector>
IntVector GetCyclotomicPolynomial(usint m, const typename IntVector::Integer& modulus);

/**
 */
template <typename IntVector>
typename IntVector::Integer SyntheticRemainder(const IntVector& dividend, const typename IntVector::Integer& a,
                                               const typename IntVector::Integer& modulus);

 */
template <typename IntVector>
IntVector SyntheticPolyRemainder(const IntVector& dividend, const IntVector& aList,
                                 const typename IntVector::Integer& modulus);

 */
template <typename IntVector>
IntVector PolynomialPower(const IntVector& input, usint power);

/**
 */
template <typename IntVector>
IntVector SyntheticPolynomialDivision(const IntVector& dividend, const typename IntVector::Integer& a,
                                      const typename IntVector::Integer& modulus);

 */
template <typename IntType>
bool IsGenerator(const IntType& g, const IntType& q);

/**
 */
template <typename IntType>
IntType FindGeneratorCyclic(const IntType& q);

/**


//========================================
//===== File: ./src/core/include/math/nbtheory-impl.h =====
//========================================

namespace lbcrypto {

/*
 Generates a random number between 0 and n.
 */
template <typename IntType>
static IntType RNG(const IntType& modulus) {
    constexpr uint32_t chunk_min{0};
    constexpr uint32_t chunk_max{std::numeric_limits<uint32_t>::max()};
    constexpr uint32_t chunk_width{std::numeric_limits<uint32_t>::digits};
    static std::uniform_int_distribution<uint32_t> distribution(chunk_min, chunk_max);

    uint32_t chunksPerValue{(modulus.GetMSB() - 1) / chunk_width};
    uint32_t shiftChunk{chunksPerValue * chunk_width};
 */
template <typename IntType>
static bool WitnessFunction(const IntType& a, const IntType& d, usint s, const IntType& p) {
    IntType mod  = a.ModExp(d, p);
    bool prevMod = false;
    for (usint i = 0; i < s; ++i) {
 */
template <typename IntType>
static IntType FindGenerator(const IntType& q) {
    IntType qm1(q - IntType(1));
    IntType qm2(q - IntType(2));
    std::set<IntType> primeFactors;
 */
template <typename IntType>
IntType FindGeneratorCyclic(const IntType& q) {
    IntType phi_q(GetTotient(q.ConvertToInt()));
    IntType phi_q_m1(GetTotient(q.ConvertToInt()));
 */
template <typename IntType>
bool IsGenerator(const IntType& g, const IntType& q) {
    IntType qm1(GetTotient(q.ConvertToInt()));
    std::set<IntType> primeFactors;
 */
template <typename IntType>
IntType RootOfUnity(usint m, const IntType& modulo) {
    IntType M(m);
    if ((modulo - IntType(1)).Mod(M) != IntType(0)) {

template <typename IntType>
std::vector<IntType> RootsOfUnity(usint m, const std::vector<IntType>& moduli) {
    std::vector<IntType> rootsOfUnity(moduli.size());
    for (size_t i = 0; i < moduli.size(); ++i)

template <typename IntType>
IntType GreatestCommonDivisor(const IntType& a, const IntType& b) {
    static const IntType ZERO(0);
    auto m_a(a);
    auto m_b(b);
    while (m_b != ZERO) {
 */
template <typename IntType>
bool MillerRabinPrimalityTest(const IntType& p, const usint niter) {
    static const IntType ZERO(0);
    static const IntType TWO(2);
    static const IntType THREE(3);
    static const IntType FIVE(5);

    if (p == TWO || p == THREE || p == FIVE)
        return true;
 */
template <typename IntType>
const IntType PollardRhoFactorization(const IntType& n) {
    if (n.Mod(IntType(2)) == IntType(0))
        return IntType(2);
 */
template <typename IntType>
void PrimeFactorize(IntType n, std::set<IntType>& primeFactors) {
    if (n == IntType(0) || n == IntType(1))
        return;

template <typename IntType>
IntType FirstPrime(uint32_t nBits, uint64_t m) {
    if constexpr (std::is_same_v<IntType, NativeInteger>) {
        if (nBits > MAX_MODULUS_SIZE)

template <typename IntType>
IntType LastPrime(uint32_t nBits, uint64_t m) {
    if constexpr (std::is_same_v<IntType, NativeInteger>) {
        if (nBits > MAX_MODULUS_SIZE)

template <typename IntType>
IntType NextPrime(const IntType& q, uint64_t m) {
    IntType M(m), qNew(q + M);
    while (!MillerRabinPrimalityTest(qNew)) {

template <typename IntType>
IntType PreviousPrime(const IntType& q, uint64_t m) {
    IntType M(m), qNew(q - M);
    while (!MillerRabinPrimalityTest(qNew)) {

template <typename IntType>
IntType NextPowerOfTwo(IntType n) {
    usint result = ceil(log2(n));
    return result;
/*Naive Loop to find coprimes to n*/
template <typename IntType>
std::vector<IntType> GetTotientList(const IntType& n) {
    std::vector<IntType> result;
    static const IntType one(1);
    for (IntType i = one; i < n; i = i + one) {
        if (GreatestCommonDivisor(i, n) == one)
            result.push_back(i);
/* Calculate the remainder from polynomial division */
template <typename IntVector>
IntVector PolyMod(const IntVector& dividend, const IntVector& divisor, const typename IntVector::Integer& modulus) {
    auto mu(modulus.ComputeMu());
    usint divisorLength(divisor.GetLength());

template <typename IntVector>
IntVector PolynomialMultiplication(const IntVector& a, const IntVector& b) {
    usint degreeA(a.GetLength());
    usint degreeB(b.GetLength());

template <typename IntVector>
IntVector GetCyclotomicPolynomial(usint m, const typename IntVector::Integer& modulus) {
    auto intCP = GetCyclotomicPolynomialRecursive(m);
    IntVector result(intCP.size(), modulus);

template <typename IntVector>
typename IntVector::Integer SyntheticRemainder(const IntVector& dividend, const typename IntVector::Integer& a,
                                               const typename IntVector::Integer& modulus) {
    auto mu  = modulus.ComputeMu();

template <typename IntVector>
IntVector SyntheticPolyRemainder(const IntVector& dividend, const IntVector& aList,
                                 const typename IntVector::Integer& modulus) {
    IntVector result(aList.GetLength(), modulus);

template <typename IntVector>
IntVector PolynomialPower(const IntVector& input, usint power) {
    usint finalDegree = (input.GetLength() - 1) * power;
    IntVector finalPoly(finalDegree + 1, input.GetModulus());

template <typename IntVector>
IntVector SyntheticPolynomialDivision(const IntVector& dividend, const typename IntVector::Integer& a,
                                      const typename IntVector::Integer& modulus) {
    auto mu(modulus.ComputeMu());


//========================================
//===== File: ./src/core/include/math/ternaryuniformgenerator.h =====
//========================================

namespace lbcrypto {

/**
 * @brief A generator of the Ternary Uniform Distribution.
 */
template <typename VecType>
class TernaryUniformGeneratorImpl {
public:
    /**
   * @brief Basic constructor for Binary Uniform Generator.
   */

private:
    static std::uniform_int_distribution<int> m_distribution;
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/math/ternaryuniformgenerator-impl.h =====
//========================================

namespace lbcrypto {

template <typename VecType>
std::uniform_int_distribution<int> TernaryUniformGeneratorImpl<VecType>::m_distribution =
    std::uniform_int_distribution<int>(-1, 1);

template <typename VecType>
VecType TernaryUniformGeneratorImpl<VecType>::GenerateVector(usint size, const typename VecType::Integer& modulus,
                                                             usint h) const {
    VecType v(size);

template <typename VecType>
std::shared_ptr<int32_t> TernaryUniformGeneratorImpl<VecType>::GenerateIntVector(usint size, usint h) const {
    std::shared_ptr<int32_t> ans(new int32_t[size], std::default_delete<int32_t[]>());



//========================================
//===== File: ./src/core/include/openfhecore.h =====
//========================================


//========================================
//===== File: ./src/core/include/utils/blockAllocator/blockAllocator.h =====
//========================================
/// http://www.codeproject.com/Articles/1083210/An-efficient-Cplusplus-fixed-block-memory-allocato
class Allocator {
public:
    enum AllocatorMode { HEAP_BLOCKS, HEAP_POOL, STATIC_POOL };

    /// Constructor
    /// @param[in]  size - size of the fixed blocks

private:
    /// Push a memory block onto head of free-list.
    /// @param[in]  pMemory - block of memory to push onto free-list
    void Push(void* pMemory);

    struct Block {
        Block* pNext;
    };

// Template class to create external memory pool
template <class T, size_t Objects>
class AllocatorPool : public Allocator {
public:
    AllocatorPool() : Allocator(sizeof(T), Objects, m_memory) {}

private:
    char m_memory[sizeof(T) * Objects];
};

#define DECLARE_ALLOCATOR                                   \
public:                                                     \
    void* operator new(size_t size) {                       \
        return _allocator.Allocate(size);                   \
    }                                                       \
                                                            \
private:                                                    \
    static Allocator _allocator;

// macro to provide source file interface
#define IMPLEMENT_ALLOCATOR(class, objects, memory) \


//========================================
//===== File: ./src/core/include/utils/blockAllocator/stl_allocator.h =====
//========================================

template <typename T>
class stl_allocator;
template <>
class stl_allocator<void> {
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    // reference to void members are impossible.
    typedef void value_type;

    template <class U>
    struct rebind {
        typedef stl_allocator<U> other;
    };
};

/// and release memory.
template <typename T>
class stl_allocator {
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    /// Constructor
    stl_allocator() {}
    /// Copy constructor
    template <class U>
    stl_allocator(const stl_allocator<U>&) {}

    template <class U>
    struct rebind {
        typedef stl_allocator<U> other;
    };

    /// Return reference address.

template <typename T, typename U>
inline bool operator==(const stl_allocator<T>&, const stl_allocator<U>) {
    return true;
}

template <typename T, typename U>
inline bool operator!=(const stl_allocator<T>&, const stl_allocator<U>) {
    return false;
}

namespace std {
template <class _Tp1, class _Tp2>
inline stl_allocator<_Tp2>& STD_ALLOC_CDECL __stl_alloc_rebind(stl_allocator<_Tp1>& __a, const _Tp2*) {
    return (stl_allocator<_Tp2>&)(__a);
}

template <class _Tp1, class _Tp2>
inline stl_allocator<_Tp2> STD_ALLOC_CDECL __stl_alloc_create(const stl_allocator<_Tp1>&, const _Tp2*) {
    return stl_allocator<_Tp2>();
}


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xallocator.h =====
//========================================
/// first before xalloc_destroy() is called.
class XallocInitDestroy {
public:
    XallocInitDestroy();
    ~XallocInitDestroy();

private:
    static uint32_t refCount;
};
#endif  // AUTOMATIC_XALLOCATOR_INIT_DESTROY

#define XALLOCATOR                        \
public:                                   \
    void* operator new(size_t size) {     \
        return xmalloc(size);             \
    }                                     \


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xlist.h =====
//========================================

template <class _Ty, class _Ax = stl_allocator<_Ty> >
class xlist : public std::list<_Ty, _Ax> {};

#endif


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xmap.h =====
//========================================

template <class _Kty, class _Ty, class _Pr = std::less<_Kty>,
          class _Alloc = stl_allocator<std::pair<const _Kty, _Ty> > >
class xmap : public std::map<_Kty, _Ty, _Pr, _Alloc> {};

template <class _Kty, class _Ty, class _Pr = std::less<_Kty>,
          class _Alloc = stl_allocator<std::pair<const _Kty, _Ty> > >
class xmultimap : public std::multimap<_Kty, _Ty, _Pr, _Alloc> {};

#endif


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xqueue.h =====
//========================================

template <class _Tp, class _Sequence = std::list<_Tp, stl_allocator<_Tp> > >
class xqueue : public std::queue<_Tp, _Sequence> {};

#endif


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xset.h =====
//========================================

template <class _Kty, class _Pr = std::less<_Kty>, class _Alloc = stl_allocator<_Kty> >
class xset : public std::set<_Kty, _Pr, _Alloc> {};

/// @see xset
template <class _Kty, class _Pr = std::less<_Kty>, class _Alloc = stl_allocator<_Kty> >
class xmultiset : public std::multiset<_Kty, _Pr, _Alloc> {};

#endif


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xsstream.h =====
//========================================

typedef std::basic_stringstream<char, std::char_traits<char>, stl_allocator<char>> xstringstream;
typedef std::basic_ostringstream<char, std::char_traits<char>, stl_allocator<char>> xostringstream;

typedef std::basic_stringstream<wchar_t, std::char_traits<wchar_t>, stl_allocator<wchar_t>> xwstringstream;
typedef std::basic_ostringstream<wchar_t, std::char_traits<wchar_t>, stl_allocator<wchar_t>> xwostringstream;

#endif


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xstring.h =====
//========================================

typedef std::basic_string<char, std::char_traits<char>, stl_allocator<char>> xstring;
typedef std::basic_string<wchar_t, std::char_traits<wchar_t>, stl_allocator<wchar_t>> xwstring;

#endif


//========================================
//===== File: ./src/core/include/utils/blockAllocator/xvector.h =====
//========================================

template <class _Ty, class _Ax = stl_allocator<_Ty> >
class xvector : public std::vector<_Ty, _Ax> {
public:
    constexpr xvector() noexcept : std::vector<_Ty, _Ax>() {}
    explicit constexpr xvector(usint length) noexcept : std::vector<_Ty, _Ax>(length) {}
    constexpr xvector(usint length, const _Ty& val) noexcept : std::vector<_Ty, _Ax>(length, val) {}
};



//========================================
//===== File: ./src/core/include/utils/caller_info.h =====
//========================================


//========================================
//===== File: ./src/core/include/utils/debug.h =====
//========================================

typedef std::chrono::high_resolution_clock::time_point TimeVar;

#define duration(a)    std::chrono::duration_cast<std::chrono::milliseconds>(a).count()
#define duration_ns(a) std::chrono::duration_cast<std::chrono::nanoseconds>(a).count()

template <typename F, typename... Args>
double funcTime(F func, Args&&... args) {
    TimeVar t1 = timeNow();
    func(std::forward<Args>(args)...);


//========================================
//===== File: ./src/core/include/utils/demangle.h =====
//========================================


//========================================
//===== File: ./src/core/include/utils/exception.h =====
//========================================

namespace lbcrypto {

// Exceptions thrown inside of a critical region, or inside of an omp thread,
// must be caught in the same thread where thrown, or Bad Things Happen
// regions (thank you stack overflow)
class ThreadException {
    std::exception_ptr Ptr;
    std::mutex Lock;

public:
    ThreadException() : Ptr(nullptr) {}
    ~ThreadException() {}
    void Rethrow() {

    template <typename Function, typename... Parameters>
    void Run(Function f, Parameters... params) {
        try {
            f(params...);
// e.Rethrow();
class openfhe_error : public std::runtime_error {
    std::string filename;
    int linenum;
    std::string message;

public:
    openfhe_error(const std::string& file, int line, const std::string& what)
        : std::runtime_error(what), filename(file), linenum(line) {
        message = filename + ":" + std::to_string(linenum) + " " + what;

class config_error : public openfhe_error {
public:
    config_error(const std::string& file, int line, const std::string& what) : openfhe_error(file, line, what) {}
};

class math_error : public openfhe_error {
public:
    math_error(const std::string& file, int line, const std::string& what) : openfhe_error(file, line, what) {}
};

class not_implemented_error : public openfhe_error {
public:
    not_implemented_error(const std::string& file, int line, const std::string& what)
        : openfhe_error(file, line, what) {}
};

class not_available_error : public openfhe_error {
public:
    not_available_error(const std::string& file, int line, const std::string& what) : openfhe_error(file, line, what) {}
};

class type_error : public openfhe_error {
public:
    type_error(const std::string& file, int line, const std::string& what) : openfhe_error(file, line, what) {}
};

// use this error when serializing openfhe objects
class serialize_error : public openfhe_error {
public:
    serialize_error(const std::string& file, int line, const std::string& what) : openfhe_error(file, line, what) {}
};

// use this error when deserializing openfhe objects
class deserialize_error : public openfhe_error {
public:
    deserialize_error(const std::string& file, int line, const std::string& what) : openfhe_error(file, line, what) {}
};

class OpenFHEException : public std::exception {
    std::string m_errorDescription;
    std::string m_fileName;
    std::string m_funcName;

public:
    OpenFHEException(const std::string errorDescription, const std::string fileName = __builtin_FILE(),
                     const std::string funcName = __builtin_FUNCTION(), size_t lineNumber = __builtin_LINE())
        : m_errorDescription(errorDescription), m_fileName(fileName), m_funcName(funcName), m_lineNumber(lineNumber) {


//========================================
//===== File: ./src/core/include/utils/get-call-stack.h =====
//========================================


//========================================
//===== File: ./src/core/include/utils/hashutil.h =====
//========================================

namespace lbcrypto {

enum HashAlgorithm { SHA_256 = 0, SHA_512 = 1 };

class HashUtil {
public:
    static void Hash(std::string message, HashAlgorithm algo, std::vector<int64_t>& digest) {
        switch (algo) {
            case SHA_256:
                SHA256(message, digest);

    static std::string HashString(std::string message);

private:
    static void SHA256(std::string message, std::vector<int64_t>& digest);
    static void SHA512(std::string message, std::vector<int64_t>& digest);
    static const uint32_t k_256[64];
    static const uint64_t k_512[80];
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/core/include/utils/inttypes.h =====
//========================================
 */
typedef uint8_t uschar;

/**
 * @brief Type used for representing unsigned 16-bit short integers.
 */
typedef uint16_t usshort;

/**
 * @brief Type used for representing unsigned 32-bit integers.
 */
typedef uint32_t usint;

typedef uint64_t PlaintextModulus;

/**
* @brief Represents whether the polynomial ring is in EVALUATION or COEFFICIENT
 */
enum Format { EVALUATION = 0, COEFFICIENT = 1 };
std::ostream& operator<<(std::ostream& s, Format f);

#endif


//========================================
//===== File: ./src/core/include/utils/memory.h =====
//========================================

namespace lbcrypto {

//  make_unique was left out of c++11, these are the accepted implementation
#if _MSC_VER == 1700
                                                                                   \
        template <class T COMMA LIST(_CLASS_TYPE)>                                 \
        inline std::unique_ptr<T> make_unique(LIST(_TYPE_REFREF_ARG)) {            \
            return std::unique_ptr<T>(new T(LIST(_FORWARD_ARG)));                  \
        }
//  *nix implementation
template <typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

template <class X>
void MoveAppend(std::vector<X>& dst, std::vector<X>& src) {
    if (dst.empty()) {
        dst = std::move(src);


//========================================
//===== File: ./src/core/include/utils/openfhebase64.h =====
//========================================

namespace lbcrypto {

extern const char to_base64_char[];

inline unsigned char get_6bits_atoffset(uint64_t m_value, uint32_t index) {
    static unsigned char smallmask[] = {0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f};
    if (index == 0)
        OPENFHE_THROW("Zero index in GetBitAtIndex");
    if (index <= 6)


//========================================
//===== File: ./src/core/include/utils/parallel.h =====
//========================================

namespace lbcrypto {

class ParallelControls {
public:
    // @Brief CTOR, enables parallel operations as default
    // Cache the number of machine threads the system reports (can be
    // overridden by environment variables)

    static int GetNumProcs() {
#ifdef PARALLEL
        return omp_get_num_procs();
#else

private:
    int machineThreads{1};
};



//========================================
//===== File: ./src/core/include/utils/prng/blake2.h =====
//========================================

enum blake2s_constant {
  BLAKE2S_BLOCKBYTES = 64,
  BLAKE2S_OUTBYTES = 32,
  BLAKE2S_KEYBYTES = 32,

enum blake2b_constant {
  BLAKE2B_BLOCKBYTES = 128,
  BLAKE2B_OUTBYTES = 64,
  BLAKE2B_KEYBYTES = 64,

typedef struct blake2s_state__ {
  uint32_t h[8];
  uint32_t t[2];
  uint32_t f[2];

typedef struct blake2b_state__ {
  uint64_t h[8];
  uint64_t t[2];
  uint64_t f[2];

typedef struct blake2sp_state__ {
  blake2s_state S[8][1];
  blake2s_state R[1];
  uint8_t buf[8 * BLAKE2S_BLOCKBYTES];

typedef struct blake2bp_state__ {
  blake2b_state S[4][1];
  blake2b_state R[1];
  uint8_t buf[4 * BLAKE2B_BLOCKBYTES];

typedef struct blake2s_param__ blake2s_param;

BLAKE2_PACKED(struct blake2b_param__ {
  uint8_t digest_length;                   /* 1 */

typedef struct blake2b_param__ blake2b_param;

typedef struct blake2xs_state__ {
  blake2s_state S[1];
  blake2s_param P[1];
} blake2xs_state;

typedef struct blake2xb_state__ {
  blake2b_state S[1];
  blake2b_param P[1];
} blake2xb_state;
/* Padded structs result in a compile-time error */
enum {
  BLAKE2_DUMMY_1 = 1 / (sizeof(blake2s_param) == BLAKE2S_OUTBYTES),
  BLAKE2_DUMMY_2 = 1 / (sizeof(blake2b_param) == BLAKE2B_OUTBYTES)
};


//========================================
//===== File: ./src/core/include/utils/prng/blake2engine.h =====
//========================================

namespace default_prng {
/**
 * @brief Defines the PRNG engine (based on BLAKE2) used by OpenFHE. It can be used
 * as an example for adding other PRNG engines to OpenFHE.
 */
class Blake2Engine : public PRNG {
 public:
    enum {
        MAX_SEED_GENS = 16,
        // the buffer stores 1024 samples of 32-bit integers
        PRNG_BUFFER_SIZE = 1024
     */
    explicit Blake2Engine(const blake2_seed_array_t& seed, uint64_t counter) : m_seed(seed), m_counter(counter) {}

    ~Blake2Engine();


 private:
    /**
     * @brief The main call to blake2xb function
     */


//========================================
//===== File: ./src/core/include/utils/prng/blake2-impl.h =====
//========================================

static BLAKE2_INLINE uint32_t load32(const void *src) {
#if defined(NATIVE_LITTLE_ENDIAN)
  uint32_t w;
  memcpy(&w, src, sizeof w);

static BLAKE2_INLINE uint64_t load64(const void *src) {
#if defined(NATIVE_LITTLE_ENDIAN)
  uint64_t w;
  memcpy(&w, src, sizeof w);

static BLAKE2_INLINE uint16_t load16(const void *src) {
#if defined(NATIVE_LITTLE_ENDIAN)
  uint16_t w;
  memcpy(&w, src, sizeof w);

static BLAKE2_INLINE void store16(void *dst, uint16_t w) {
#if defined(NATIVE_LITTLE_ENDIAN)
  memcpy(dst, &w, sizeof w);
#else

static BLAKE2_INLINE void store32(void *dst, uint32_t w) {
#if defined(NATIVE_LITTLE_ENDIAN)
  memcpy(dst, &w, sizeof w);
#else

static BLAKE2_INLINE void store64(void *dst, uint64_t w) {
#if defined(NATIVE_LITTLE_ENDIAN)
  memcpy(dst, &w, sizeof w);
#else

static BLAKE2_INLINE uint64_t load48(const void *src) {
  const uint8_t *p = (const uint8_t *)src;
  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |
         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |

static BLAKE2_INLINE void store48(void *dst, uint64_t w) {
  uint8_t *p = (uint8_t *)dst;
  p[0] = (uint8_t)(w >> 0);
  p[1] = (uint8_t)(w >> 8);

static BLAKE2_INLINE uint32_t rotr32(const uint32_t w, const unsigned c) {
  return (w >> c) | (w << (32 - c));
}

static BLAKE2_INLINE uint64_t rotr64(const uint64_t w, const unsigned c) {
  return (w >> c) | (w << (64 - c));
}

/* prevents compiler optimizing out memset() */
static BLAKE2_INLINE void secure_zero_memory(void *v, size_t n) {
  static void *(*const volatile memset_v)(void *, int, size_t) = &memset;
  memset_v(v, 0, n);
}



//========================================
//===== File: ./src/core/include/utils/prng/prng.h =====
//========================================
//    returning a dynamically allocated object of that derived class (see how it is done in blake2engine.h)
class PRNG {
public:
    // all C++11 distributions used in OpenFHE work with uint32_t by default.
    // a different data type can be specified if needed for a particular architecture
    using result_type = uint32_t;
     */
    static constexpr result_type min() {
        return std::numeric_limits<result_type>::min();
    }

     */
    static constexpr result_type max() {
        return std::numeric_limits<result_type>::max();
    }

    virtual result_type operator()() = 0;
    virtual ~PRNG()                  = default;

protected:
    PRNG() = default;
};
#endif  // __PRNG_H__


//========================================
//===== File: ./src/core/include/utils/serial.h =====
//========================================

namespace lbcrypto {

namespace Serial {
//========================== BINARY serialization ==========================
/**
		 * Serialize an object
		 */
template <typename T>
void Serialize(const T& obj, std::ostream& stream, const SerType::SERBINARY& st) {
    cereal::PortableBinaryOutputArchive archive(stream);
    archive(obj);
		 */
template <typename T>
void Deserialize(T& obj, std::istream& stream, const SerType::SERBINARY& st) {
    cereal::PortableBinaryInputArchive archive(stream);
    archive(obj);

template <typename T>
bool SerializeToFile(const std::string& filename, const T& obj, const SerType::SERBINARY& sertype) {
    std::ofstream file(filename, std::ios::out | std::ios::binary);
    if (file.is_open()) {

template <typename T>
bool DeserializeFromFile(const std::string& filename, T& obj, const SerType::SERBINARY& sertype) {
    std::ifstream file(filename, std::ios::in | std::ios::binary);
    if (file.is_open()) {
		 */
template <typename T>
void Serialize(const T& obj, std::ostream& stream, const SerType::SERJSON& ser) {
    cereal::JSONOutputArchive archive(stream);
    archive(obj);
		 */
template <typename T>
void Deserialize(T& obj, std::istream& stream, const SerType::SERJSON& ser) {
    cereal::JSONInputArchive archive(stream);
    archive(obj);

template <typename T>
bool SerializeToFile(const std::string& filename, const T& obj, const SerType::SERJSON& sertype) {
    std::ofstream file(filename, std::ios::out | std::ios::binary);
    if (file.is_open()) {

template <typename T>
bool DeserializeFromFile(const std::string& filename, T& obj, const SerType::SERJSON& sertype) {
    std::ifstream file(filename, std::ios::in | std::ios::binary);
    if (file.is_open()) {
		 */
template <typename T>
std::string SerializeToString(const T& t) {
    std::stringstream s;
    Serialize(t, s, SerType::JSON);
		 */
template <typename T>
void DeserializeFromString(T& obj, const std::string& json) {
    std::stringstream s;
    s << json;


//========================================
//===== File: ./src/core/include/utils/serializable.h =====
//========================================

namespace lbcrypto {

/**
 * \class Serializable
 */
class Serializable {
public:
    virtual ~Serializable()                          = default;
    virtual std::string SerializedObjectName() const = 0;
};

// helper template to stream vector contents provided T has an stream operator<<
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {
    os << "[";
    for (auto i = v.begin(); i != v.end(); ++i) {


//========================================
//===== File: ./src/core/include/utils/sertype.h =====
//========================================

namespace lbcrypto {

namespace SerType {

class SERJSON {};
static const SERJSON JSON;  // should be const static to avoid compilation failure

class SERBINARY {};
static const SERBINARY BINARY;  // should be const static to avoid compilation failure

}  // namespace SerType



//========================================
//===== File: ./src/core/include/utils/type_name.h =====
//========================================
// define my own "is_shared_pointer"
template <typename T>
struct is_shared_pointer : std::false_type {};
template <typename T>
struct is_shared_pointer<std::shared_ptr<T>> : std::true_type {};
template <typename T>
struct is_shared_pointer<std::shared_ptr<T const>> : std::true_type {};
//=============================================================================
// sharedPtr() returns true if the argument is a shared_ptr or false otherwise
template <typename T>
bool sharedPtr(const T& t) {
    return is_shared_pointer<T>::value;
}
// typeName() for objects
template <typename T,
          typename std::enable_if<!std::is_pointer<T>::value && !is_shared_pointer<T>::value, bool>::type = true>
std::string typeName(const T& obj) {
    return demangle(typeid(obj).name());
// typeName() for pointers
template <typename T,
          typename std::enable_if<std::is_pointer<T>::value || is_shared_pointer<T>::value, bool>::type = true>
std::string typeName(const T& ptr) {
    return demangle(typeid(ptr).name());
// returns the actual type of the object ptr points to.
template <typename T,
          typename std::enable_if<std::is_pointer<T>::value || is_shared_pointer<T>::value, bool>::type = true>
std::string objectTypeName(const T& ptr) {
    return demangle(typeid(*ptr).name());


//========================================
//===== File: ./src/core/include/utils/utilities.h =====
//========================================
 */
namespace lbcrypto {

/**
 * Determines if a number is a power of 2.
 */
template <typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
inline constexpr bool IsPowerOfTwo(T Input) {
    return Input && !(Input & (Input - 1));
}

enum { MAX_DOUBLE_PRECISION = 52 };
#endif

inline bool isConvertableToNativeInt(double d) {


//========================================
//===== File: ./src/core/include/utils/utilities-int.h =====
//========================================

namespace lbcrypto {

#if defined(HAVE_INT128)
/**


//========================================
//===== File: ./src/core/include/version.h =====
//========================================


//========================================
//===== File: ./src/pke/include/ciphertext.h =====
//========================================

namespace lbcrypto {
/**
 * @brief CiphertextImpl
 *
 */
template <class Element>
class CiphertextImpl : public CryptoObject<Element> {
public:
    /**
   * Default constructor
   */
   */
    explicit CiphertextImpl(CryptoContext<Element> cc, const std::string& id = "",
                            PlaintextEncodings encType = INVALID_ENCODING)
        : CryptoObject<Element>(cc, id), encodingType(encType) {}

   */
    explicit CiphertextImpl(const std::shared_ptr<Key<Element>> k)
        : CryptoObject<Element>(k->GetCryptoContext(), k->GetKeyTag()) {}

    /**

    explicit CiphertextImpl(Ciphertext<Element> ciphertext) : CryptoObject<Element>(*ciphertext) {
        m_elements         = ciphertext->m_elements;
        m_noiseScaleDeg    = ciphertext->m_noiseScaleDeg;
        m_level            = ciphertext->m_level;

    explicit CiphertextImpl(Ciphertext<Element>&& ciphertext) : CryptoObject<Element>(*ciphertext) {
        m_elements         = std::move(ciphertext->m_elements);
        m_noiseScaleDeg    = std::move(ciphertext->m_noiseScaleDeg);
        m_level            = std::move(ciphertext->m_level);
   */
    virtual Ciphertext<Element> CloneEmpty() const {
        Ciphertext<Element> ct(std::make_shared<CiphertextImpl<Element>>(this->GetCryptoContext(), this->GetKeyTag(),
                                                                         this->GetEncodingType()));

   */
    virtual ~CiphertextImpl() {}

    /**
   * GetEncodingType

    virtual Ciphertext<Element> Clone() const {
        Ciphertext<Element> cRes = this->CloneZero();
        cRes->SetElements(this->GetElements());


    virtual Ciphertext<Element> CloneZero() const {
        Ciphertext<Element> cRes = this->CloneEmpty();
        cRes->SetNoiseScaleDeg(this->GetNoiseScaleDeg());
        cRes->SetLevel(this->GetLevel());

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<CryptoObject<Element>>(this));
        ar(cereal::make_nvp("v", m_elements));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    // vector of ring elements for this Ciphertext
    std::vector<Element> m_elements;

 */
template <class Element>
Ciphertext<Element> operator+(const Ciphertext<Element>& a, const Ciphertext<Element>& b) {
    return a->GetCryptoContext()->EvalAdd(a, b);
}
 */
template <class Element>
const Ciphertext<Element>& operator+=(Ciphertext<Element>& a, const Ciphertext<Element>& b) {
    return a = a->GetCryptoContext()->EvalAdd(a, b);
}
 */
template <class Element>
Ciphertext<Element> operator-(const Ciphertext<Element>& a) {
    return a->GetCryptoContext()->EvalNegate(a);
}
 */
template <class Element>
Ciphertext<Element> operator-(const Ciphertext<Element>& a, const Ciphertext<Element>& b) {
    return a->GetCryptoContext()->EvalSub(a, b);
}
 */
template <class Element>
const Ciphertext<Element>& operator-=(Ciphertext<Element>& a, const Ciphertext<Element>& b) {
    return a = a->GetCryptoContext()->EvalSub(a, b);
}
 */
template <class Element>
Ciphertext<Element> operator*(const Ciphertext<Element>& a, const Ciphertext<Element>& b) {
    return a->GetCryptoContext()->EvalMult(a, b);
}
 */
template <class Element>
const Ciphertext<Element>& operator*=(Ciphertext<Element>& a, const Ciphertext<Element>& b) {
    return a = a->GetCryptoContext()->EvalMult(a, b);
}


//========================================
//===== File: ./src/pke/include/ciphertext-fwd.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class CiphertextImpl;

template <typename Element>
using Ciphertext = std::shared_ptr<CiphertextImpl<Element>>;

template <typename Element>
using ConstCiphertext = std::shared_ptr<const CiphertextImpl<Element>>;

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/ciphertext-ser.h =====
//========================================


//========================================
//===== File: ./src/pke/include/constants.h =====
//========================================

namespace lbcrypto {

//======================================================================================================================
std::ostream& operator<<(std::ostream& s, PKESchemeFeature f);


//========================================
//===== File: ./src/pke/include/constants-defs.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Lists all features supported by public key encryption schemes
 */
enum PKESchemeFeature {
    PKE          = 0x01,
    KEYSWITCH    = 0x02,
    PRE          = 0x04,

enum ScalingTechnique {
    FIXEDMANUAL = 0,
    FIXEDAUTO,
    FLEXIBLEAUTO,

enum ProxyReEncryptionMode {
    NOT_SET = 0,
    INDCPA,
    FIXED_NOISE_HRA,

enum MultipartyMode {
    INVALID_MULTIPARTY_MODE = 0,
    FIXED_NOISE_MULTIPARTY,
    NOISE_FLOODING_MULTIPARTY,

enum ExecutionMode {
    EXEC_EVALUATION = 0,
    EXEC_NOISE_ESTIMATION,
};

enum DecryptionNoiseMode {
    FIXED_NOISE_DECRYPT = 0,
    NOISE_FLOODING_DECRYPT,
};

enum KeySwitchTechnique {
    INVALID_KS_TECH = 0,
    BV,
    HYBRID,

enum EncryptionTechnique {
    STANDARD = 0,
    EXTENDED,
};

enum MultiplicationTechnique {
    BEHZ = 0,
    HPS,
    HPSPOVERQ,

enum PlaintextEncodings {
    INVALID_ENCODING = 0,
    COEF_PACKED_ENCODING,
    PACKED_ENCODING,

enum LargeScalingFactorConstants {
    MAX_BITS_IN_WORD = 61,
    MAX_LOG_STEP     = 60,
};
// TODO (dsuponit): remove BASE_NUM_LEVELS_TO_DROP
enum {
    BASE_NUM_LEVELS_TO_DROP = 1,
};

enum NoiseFlooding {
    // noise flooding distribution parameter for distributed decryption in threshold FHE
    MP_SD = 1048576,
    // noise flooding distribution parameter for fixed 20 bits noise multihop PRE
// interactive multi-party bootstrapping
enum COMPRESSION_LEVEL {  // TODO (dsuponit): change it to camel case
    // we don't support 0 or 1 compression levels
    // do not change values here



//========================================
//===== File: ./src/pke/include/cryptocontext.h =====
//========================================

namespace lbcrypto {

/**
 * @brief CryptoContextImpl
 */
template <typename Element>
class CryptoContextImpl : public Serializable {
    using IntType  = typename Element::Integer;
    using ParmType = typename Element::Params;

    */
    template <typename Value1>
    static Plaintext MakePlaintext(PlaintextEncodings encoding, CryptoContext<Element> cc, const Value1& value) {
        return PlaintextFactory::MakePlaintext(value, encoding, cc->GetElementParams(), cc->GetEncodingParams());
    }

    template <typename Value1, typename Value2>
    static Plaintext MakePlaintext(PlaintextEncodings encoding, CryptoContext<Element> cc, const Value1& value,
                                   const Value2& value2) {
        return PlaintextFactory::MakePlaintext(encoding, cc->GetElementParams(), cc->GetEncodingParams(), value,
                                               value2);
   */
    static std::set<uint32_t> GetEvalAutomorphismNoKeyIndices(const std::string& keyID,
                                                              const std::set<uint32_t>& indices) {
        std::set<uint32_t> existingIndices{CryptoContextImpl<Element>::GetExistingEvalAutomorphismKeyIndices(keyID)};
        // if no index found for the given keyID, then the entire set "indices" is returned
   */
    static std::shared_ptr<std::map<usint, EvalKey<Element>>> GetEvalAutomorphismKeyMapPtr(const std::string& keyID);
    /**
   * @brief Get automorphism keys for a specific secret key tag and an array of specific indices
   * @param keyID - secret key tag
   */
    static std::shared_ptr<std::map<usint, EvalKey<Element>>> GetPartialEvalAutomorphismKeyMapPtr(
        const std::string& keyID, const std::vector<uint32_t>& indexList);

    // cached evalmult keys, by secret key UID
    static std::map<std::string, std::vector<EvalKey<Element>>> s_evalMultKeyMap;
    // cached evalautomorphism keys, by secret key UID
    static std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>> s_evalAutomorphismKeyMap;

protected:
    // crypto parameters used for this context
    std::shared_ptr<CryptoParametersBase<Element>> params{nullptr};
    // algorithm used; accesses all crypto methods

    template <typename T>
    void ValidateKey(const T& key, CALLER_INFO_ARGS_HDR) const {
        if (key == nullptr) {
            std::string errorMsg(std::string("Key is nullptr") + CALLER_INFO);
    //虚数编码
    virtual Plaintext MakeCKKSPackedPlaintextInternal(const std::vector<std::complex<double>>& value,
                                                      size_t noiseScaleDeg, uint32_t level,
                                                      const std::shared_ptr<ParmType> params, usint slots) const {
        VerifyCKKSScheme(__func__);

public:
    /**
   * This stores the private key in the crypto context.
   * This is only intended for debugging and should not be
   */
    template <typename ST>
    static bool SerializeEvalMultKey(std::ostream& ser, const ST& sertype, std::string id = "") {
        const auto& evalMultKeys = CryptoContextImpl<Element>::GetAllEvalMultKeys();
        if (id.length() == 0) {
            Serial::Serialize(evalMultKeys, ser, sertype);
   */
    template <typename ST>
    static bool SerializeEvalMultKey(std::ostream& ser, const ST& sertype, const CryptoContext<Element> cc) {
        std::map<std::string, std::vector<EvalKey<Element>>> omap;
        for (const auto& [key, vec] : CryptoContextImpl<Element>::GetAllEvalMultKeys()) {
            if (vec[0]->GetCryptoContext() == cc) {
   */
    template <typename ST>
    static bool DeserializeEvalMultKey(std::istream& ser, const ST& sertype) {
        std::map<std::string, std::vector<EvalKey<Element>>> omap;

        Serial::Deserialize(omap, ser, sertype);
   */
    static void ClearEvalMultKeys();

    /**
   * ClearEvalMultKeys - flush EvalMultKey cache for a given id
   */
    static void ClearEvalMultKeys(const std::string& id);
    /**
   * ClearEvalMultKeys - flush EvalMultKey cache for a given context
   * @param cc crypto context
   */
    static void ClearEvalMultKeys(const CryptoContext<Element> cc);

    /**
   * InsertEvalMultKey - add the given vector of keys to the map, replacing the
   */
    static void InsertEvalMultKey(const std::vector<EvalKey<Element>>& evalKeyVec,
                                  const std::string& keyTag = std::string());

    /**
   */
    template <typename ST>
    static bool SerializeEvalSumKey(std::ostream& ser, const ST& sertype, std::string id = "") {
        return CryptoContextImpl<Element>::SerializeEvalAutomorphismKey(ser, sertype, id);
    }

   */
    template <typename ST>
    static bool SerializeEvalSumKey(std::ostream& ser, const ST& sertype, const CryptoContext<Element> cc) {
        return CryptoContextImpl<Element>::SerializeEvalAutomorphismKey(ser, sertype, cc);
    }

   */
    template <typename ST>
    static bool DeserializeEvalSumKey(std::istream& ser, const ST& sertype) {
        return CryptoContextImpl<Element>::DeserializeEvalAutomorphismKey(ser, sertype);
    }

   */
    static void ClearEvalSumKeys();

    /**
   * ClearEvalSumKeys - flush EvalSumKey cache for a given id
   */
    static void ClearEvalSumKeys(const std::string& id);

    /**
   * ClearEvalSumKeys - flush EvalSumKey cache for a given context
   */
    static void ClearEvalSumKeys(const CryptoContext<Element> cc);

    /**
   * InsertEvalSumKey - add the given map of keys to the map, replacing the
   */
    static void InsertEvalSumKey(const std::shared_ptr<std::map<usint, EvalKey<Element>>> mapToInsert,
                                 std::string keyTag = "") {
        CryptoContextImpl<Element>::InsertEvalAutomorphismKey(mapToInsert, keyTag);
    }
   */
    template <typename ST>
    static bool SerializeEvalAutomorphismKey(std::ostream& ser, const ST& sertype, std::string id = "") {
        // TODO (dsuponit): do we need Serailize/Deserialized to return bool?
        std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>>* smap;
        std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>> omap;
   */
    template <typename ST>
    static bool SerializeEvalAutomorphismKey(std::ostream& ser, const ST& sertype, const CryptoContext<Element> cc) {
        std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>> omap;
        for (const auto& k : CryptoContextImpl<Element>::GetAllEvalAutomorphismKeys()) {
            if (k.second->begin()->second->GetCryptoContext() == cc) {
   */
    template <typename ST>
    static bool SerializeEvalAutomorphismKey(std::ostream& ser, const ST& sertype, const std::string& keyID,
                                             const std::vector<uint32_t>& indexList) {
        std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>> keyMap = {
            {keyID, CryptoContextImpl<Element>::GetPartialEvalAutomorphismKeyMapPtr(keyID, indexList)}};
   */
    template <typename ST>
    static bool DeserializeEvalAutomorphismKey(std::ostream& ser, const ST& sertype, const std::string& keyID,
                                               const std::vector<uint32_t>& indexList) {
        if (!indexList.size())
            OPENFHE_THROW("indexList may not be empty");
   */
    template <typename ST>
    static bool DeserializeEvalAutomorphismKey(std::istream& ser, const ST& sertype) {
        std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>> keyMap;

        Serial::Deserialize(keyMap, ser, sertype);
   */
    static void ClearEvalAutomorphismKeys();

    /**
   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given id
   */
    static void ClearEvalAutomorphismKeys(const std::string& id);

    /**
   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given
   */
    static void ClearEvalAutomorphismKeys(const CryptoContext<Element> cc);

    /**
   * InsertEvalAutomorphismKey - add the given map of keys to the map, replacing
    // TODO (dsuponit): move InsertEvalAutomorphismKey() to the private section of the class
    static void InsertEvalAutomorphismKey(const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap,
                                          const std::string& keyTag = "");
    //------------------------------------------------------------------------------
    // TURN FEATURES ON
   */
    static std::map<std::string, std::vector<EvalKey<Element>>>& GetAllEvalMultKeys();

    /**
   * Get relinearization keys for a specific secret key tag
   */
    static const std::vector<EvalKey<Element>>& GetEvalMultKeyVector(const std::string& keyID);

    /**
   * Get a map of automorphism keys for all secret keys
   */
    static std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>>& GetAllEvalAutomorphismKeys();
    /**
   * Get automorphism keys for a specific secret key tag
   */
    static std::map<usint, EvalKey<Element>>& GetEvalAutomorphismKeyMap(const std::string& keyID) {
        return *(CryptoContextImpl<Element>::GetEvalAutomorphismKeyMapPtr(keyID));
    }
    /**
   */
    static std::map<std::string, std::shared_ptr<std::map<usint, EvalKey<Element>>>>& GetAllEvalSumKeys();

    /**
   * Get a map of summation keys (each is composed of several automorphism keys) for a specific secret key tag
   */
    static const std::map<usint, EvalKey<Element>>& GetEvalSumKeyMap(const std::string& id);

    //------------------------------------------------------------------------------
    // PLAINTEXT FACTORY METHODS
   */
    static Plaintext GetPlaintextForDecrypt(PlaintextEncodings pte, std::shared_ptr<ParmType> evp, EncodingParams ep);

    //------------------------------------------------------------------------------
    // PKE Wrapper
   */
    virtual Ciphertext<Element> EvalPoly(ConstCiphertext<Element> ciphertext,
                                         const std::vector<double>& coefficients) const {
        ValidateCiphertext(ciphertext);

     **/
    static std::set<uint32_t> GetExistingEvalAutomorphismKeyIndices(const std::string& keyTag);

    /**
     * @brief GetUniqueValues compares 2 sets to generate a set with unique values from the 2nd set
     **/
    static std::set<uint32_t> GetUniqueValues(const std::set<uint32_t>& oldValues, const std::set<uint32_t>& newValues);

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::make_nvp("cc", params));
        ar(cereal::make_nvp("kt", scheme));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > CryptoContextImpl<Element>::SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};
// Member function specializations. Their implementations are in cryptocontext.cpp
template <>
DecryptResult CryptoContextImpl<DCRTPoly>::MultipartyDecryptFusion(
    const std::vector<Ciphertext<DCRTPoly>>& partialCiphertextVec, Plaintext* plaintext) const;
template <>
std::unordered_map<uint32_t, DCRTPoly> CryptoContextImpl<DCRTPoly>::ShareKeys(const PrivateKey<DCRTPoly>& sk, usint N,
                                                                              usint threshold, usint index,
                                                                              const std::string& shareType) const;


//========================================
//===== File: ./src/pke/include/cryptocontextfactory.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class SchemeBase;
template <typename Element>
class CryptoParametersBase;

/**
 * @brief CryptoContextFactory
 */
template <typename Element>
class CryptoContextFactory {
    static std::vector<CryptoContext<Element>> AllContexts;

protected:
    static CryptoContext<Element> FindContext(std::shared_ptr<CryptoParametersBase<Element>> params,
                                              std::shared_ptr<SchemeBase<Element>> scheme);
    static void AddContext(CryptoContext<Element>);

public:
    static void ReleaseAllContexts() {
        AllContexts.clear();
    }

    static int GetContextCount() {
        return AllContexts.size();
    }

    static CryptoContext<Element> GetContext(std::shared_ptr<CryptoParametersBase<Element>> params,
                                             std::shared_ptr<SchemeBase<Element>> scheme,
                                             SCHEME schemeId = SCHEME::INVALID_SCHEME);

    // allows to avoid circular dependencies in some places by including cryptocontext-fwd.h
    static CryptoContext<Element> GetFullContextByDeserializedContext(const CryptoContext<Element> context);

    static const std::vector<CryptoContext<Element>>& GetAllContexts() {
        return AllContexts;
    }
};

template <>
std::vector<CryptoContext<DCRTPoly>> CryptoContextFactory<DCRTPoly>::AllContexts;

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/cryptocontext-fwd.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class CryptoContextImpl;

template <typename Element>
using CryptoContext = std::shared_ptr<CryptoContextImpl<Element>>;

} // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/cryptocontext-ser.h =====
//========================================

namespace lbcrypto {
// ================================= JSON serialization/deserialization
namespace Serial {
/**
 * Deserialize for a CryptoContext (that is, a shared pointer to a
 * CryptoContextImpl OpenFHE doesn't want multiple copies of the same crypto
 */
template <typename T>
void Deserialize(CryptoContext<T>& obj, std::istream& stream, const SerType::SERJSON&) {
    CryptoContext<T> newob;


template <typename T>
bool SerializeToFile(const std::string& filename, const CryptoContext<T>& obj, const SerType::SERJSON& sertype) {
    std::ofstream file(filename, std::ios::out | std::ios::binary);
    if (file.is_open()) {

template <typename T>
bool DeserializeFromFile(const std::string& filename, CryptoContext<T>& obj, const SerType::SERJSON& sertype) {
    std::ifstream file(filename, std::ios::in | std::ios::binary);
    if (file.is_open()) {
}  // namespace Serial
template void Serial::Deserialize(std::shared_ptr<CryptoContextImpl<DCRTPoly>>& obj, std::istream& stream,
                                  const SerType::SERJSON&);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalMultKey<SerType::SERJSON>(std::ostream& ser,
                                                                                  const SerType::SERJSON&,
                                                                                  std::string id);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalMultKey<SerType::SERJSON>(std::ostream& ser,
                                                                                  const SerType::SERJSON&,
                                                                                  const CryptoContext<DCRTPoly> cc);
template bool CryptoContextImpl<DCRTPoly>::DeserializeEvalMultKey<SerType::SERJSON>(std::istream& ser,
                                                                                    const SerType::SERJSON&);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalSumKey<SerType::SERJSON>(std::ostream& ser,
                                                                                 const SerType::SERJSON&,
                                                                                 std::string id);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalSumKey<SerType::SERJSON>(std::ostream& ser,
                                                                                 const SerType::SERJSON&,
                                                                                 const CryptoContext<DCRTPoly> cc);
template bool CryptoContextImpl<DCRTPoly>::DeserializeEvalSumKey<SerType::SERJSON>(std::istream& ser,
                                                                                   const SerType::SERJSON&);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalAutomorphismKey<SerType::SERJSON>(std::ostream& ser,
                                                                                          const SerType::SERJSON&,
                                                                                          std::string id);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalAutomorphismKey<SerType::SERJSON>(
    std::ostream& ser, const SerType::SERJSON&, const CryptoContext<DCRTPoly> cc);
template bool CryptoContextImpl<DCRTPoly>::DeserializeEvalAutomorphismKey<SerType::SERJSON>(std::istream& ser,
                                                                                            const SerType::SERJSON&);

// ================================= BINARY serialization/deserialization
namespace Serial {
/**
 * Deserialize for a CryptoContext (that is, a shared pointer to a
 * CryptoContextImpl OpenFHE doesn't want multiple copies of the same crypto
 */
template <typename T>
void Deserialize(CryptoContext<T>& obj, std::istream& stream, const SerType::SERBINARY&) {
    CryptoContext<T> newob;


template <typename T>
bool SerializeToFile(const std::string& filename, const CryptoContext<T>& obj, const SerType::SERBINARY& sertype) {
    std::ofstream file(filename, std::ios::out | std::ios::binary);
    if (file.is_open()) {

template <typename T>
bool DeserializeFromFile(const std::string& filename, CryptoContext<T>& obj, const SerType::SERBINARY& sertype) {
    std::ifstream file(filename, std::ios::in | std::ios::binary);
    if (file.is_open()) {

template <typename T>
std::string SerializeToString(const CryptoContext<T>& obj) {
    std::stringstream s;
    Serial::Serialize(obj, s, SerType::JSON);

template <typename T>
void DeserializeFromString(CryptoContext<T>& obj, const std::string& json) {
    std::stringstream s;
    s << json;

template void Serial::Deserialize(std::shared_ptr<CryptoContextImpl<DCRTPoly>>& obj, std::istream& stream,
                                  const SerType::SERBINARY&);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalMultKey<SerType::SERBINARY>(std::ostream& ser,
                                                                                    const SerType::SERBINARY&,
                                                                                    std::string id);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalMultKey<SerType::SERBINARY>(std::ostream& ser,
                                                                                    const SerType::SERBINARY&,
                                                                                    const CryptoContext<DCRTPoly> cc);
template bool CryptoContextImpl<DCRTPoly>::DeserializeEvalMultKey<SerType::SERBINARY>(std::istream& ser,
                                                                                      const SerType::SERBINARY&);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalSumKey<SerType::SERBINARY>(std::ostream& ser,
                                                                                   const SerType::SERBINARY&,
                                                                                   std::string id);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalSumKey<SerType::SERBINARY>(std::ostream& ser,
                                                                                   const SerType::SERBINARY&,
                                                                                   const CryptoContext<DCRTPoly> cc);
template bool CryptoContextImpl<DCRTPoly>::DeserializeEvalSumKey<SerType::SERBINARY>(std::istream& ser,
                                                                                     const SerType::SERBINARY&);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalAutomorphismKey<SerType::SERBINARY>(std::ostream& ser,
                                                                                            const SerType::SERBINARY&,
                                                                                            std::string id);
template bool CryptoContextImpl<DCRTPoly>::SerializeEvalAutomorphismKey<SerType::SERBINARY>(
    std::ostream& ser, const SerType::SERBINARY&, const CryptoContext<DCRTPoly> cc);
template bool CryptoContextImpl<DCRTPoly>::DeserializeEvalAutomorphismKey<SerType::SERBINARY>(
    std::istream& ser, const SerType::SERBINARY&);

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/cryptoobject.h =====
//========================================

namespace lbcrypto {

/**
 * @brief CryptoObject
 */
template <typename Element>
class CryptoObject {
protected:
    CryptoContext<Element> context;  // crypto context belongs to the tag used to find the evaluation key needed
                                     // for SHE/FHE operations
    std::string keyTag;

public:
    explicit CryptoObject(CryptoContext<Element> cc = nullptr, const std::string& tag = "")
        : context(cc), keyTag(tag) {}

    CryptoObject(const CryptoObject& rhs) {

    virtual ~CryptoObject() {}

    const CryptoObject& operator=(const CryptoObject& rhs) {
        this->context = rhs.context;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("cc", context));
        ar(::cereal::make_nvp("kt", keyTag));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/pke/include/encoding/ckkspackedencoding.h =====
//========================================

namespace lbcrypto {

/**
 * @class CKKSPackedEncoding

class CKKSPackedEncoding : public PlaintextImpl {
public:
    // these two constructors are used inside of Decrypt
    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>
   */
    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>
   */
    explicit CKKSPackedEncoding(const std::vector<std::complex<double>>& rhs, size_t slots)
        : PlaintextImpl(std::shared_ptr<Poly::Params>(0), nullptr, CKKSRNS_SCHEME), value(rhs) {
        // validate the number of slots
        if ((slots & (slots - 1)) != 0) {
   */
    static std::vector<DCRTPoly::Integer> CRTMult(const std::vector<DCRTPoly::Integer>& a,
                                                  const std::vector<DCRTPoly::Integer>& b,
                                                  const std::vector<DCRTPoly::Integer>& mods);

   */
    static void Destroy();

    void PrintValue(std::ostream& out) const override {
        // for sanity's sake, trailing zeros get elided into "..."

private:
    std::vector<std::complex<double>> value;

    double m_logError = 0;

protected:
    usint GetDefaultSlotSize() {
        auto batchSize = GetEncodingParams()->GetBatchSize();
        return (0 == batchSize) ? GetElementRingDimension() / 2 : batchSize;


//========================================
//===== File: ./src/pke/include/encoding/coefpackedencoding.h =====
//========================================

namespace lbcrypto {

class CoefPackedEncoding : public PlaintextImpl {
    std::vector<int64_t> value;

public:
    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>

    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>

    virtual ~CoefPackedEncoding() = default;

    /**
   * GetCoeffsValue


//========================================
//===== File: ./src/pke/include/encoding/encodingparams.h =====
//========================================

namespace lbcrypto {
class EncodingParamsImpl;

typedef std::shared_ptr<EncodingParamsImpl> EncodingParams;

/**
 * @class EncodingParamsImpl
 */
class EncodingParamsImpl : public lbcrypto::Serializable {
public:
    /**
   * Main constructor. Supports (1) default constructor, (2) regular encoding
   * with plaintext modulus set, (3) packed encoding with at least first two
   */
    virtual ~EncodingParamsImpl() {}

    // ACCESSORS


private:
    std::ostream& doprint(std::ostream& out) const {
        out << "[p=" << m_plaintextModulus << " rootP =" << m_plaintextRootOfUnity << " bigP =" << m_plaintextBigModulus
            << " rootBigP =" << m_plaintextBigRootOfUnity << " g=" << m_plaintextGenerator << " L=" << m_batchSize

public:
    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("m", m_plaintextModulus));
        ar(::cereal::make_nvp("ru", m_plaintextRootOfUnity));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/pke/include/encoding/encodings.h =====
//========================================


//========================================
//===== File: ./src/pke/include/encoding/packedencoding.h =====
//========================================

namespace lbcrypto {

// STL pair used as a key for some tables in PackedEncoding
using ModulusM = std::pair<NativeInteger, uint64_t>;

class PackedEncoding : public PlaintextImpl {
    std::vector<int64_t> value;

public:
    // these two constructors are used inside of Decrypt
    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>

    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>

    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>
   */
    explicit PackedEncoding(const std::vector<int64_t>& rhs)
        : PlaintextImpl(std::shared_ptr<Poly::Params>(0), nullptr), value(rhs) {}

    /**

    static usint GetAutomorphismGenerator(usint m) {
        return m_automorphismGenerator[m];
    }

   */
    static void SetParams(usint m, EncodingParams params);

    /**
   * @brief Method to set encoding params (this method should eventually be
   */
    static void SetParams(usint m, const PlaintextModulus& modulus)
        __attribute__((deprecated("use SetParams(usint m, EncodingParams p)")));

    /**
   */
    static void Destroy();

    void PrintValue(std::ostream& out) const {
        // for sanity's sake, trailing zeros get elided into "..."

private:
    // initial root of unity for plaintext space
    static std::map<ModulusM, NativeInteger> m_initRoot;
    // modulus and root of unity to be used for Arbitrary CRT
    static std::map<ModulusM, NativeInteger> m_bigModulus;
    static std::map<ModulusM, NativeInteger> m_bigRoot;

    // stores the list of primitive roots used in packing.
    static std::map<usint, usint> m_automorphismGenerator;
    static std::map<usint, std::vector<usint>> m_toCRTPerm;
    static std::map<usint, std::vector<usint>> m_fromCRTPerm;

    static void SetParams_2n(usint m, const NativeInteger& modulusNI);

    static void SetParams_2n(usint m, EncodingParams params);

    /**
   * @brief Packs the slot values into aggregate plaintext space.
   */
    template <typename P>
    void Pack(P* ring, const PlaintextModulus& modulus) const;

    // Optimized version of packing designed for DCRTPoly and NativePoly
   */
    template <typename P>
    void Unpack(P* ring, const PlaintextModulus& modulus) const;
};



//========================================
//===== File: ./src/pke/include/encoding/plaintext.h =====
//========================================

namespace lbcrypto {

/**
 * @class PlaintextImpl
 */
class PlaintextImpl {
protected:
    enum PtxtPolyType { IsPoly, IsDCRTPoly, IsNativePoly };

    bool isEncoded;
    PtxtPolyType typeFlag;

    static constexpr int intCTOR     = 0x01;
    static constexpr int vecintCTOR  = 0x02;
    static constexpr int fracCTOR    = 0x04;
    static constexpr int vecuintCTOR = 0x08;

    double scalingFactor           = 1;
    NativeInteger scalingFactorInt = 1;

public:
    PlaintextImpl(const std::shared_ptr<Poly::Params>& vp, EncodingParams ep, SCHEME schemeTag = SCHEME::INVALID_SCHEME,
                  bool isEncoded = false)
        : isEncoded(isEncoded),

    virtual ~PlaintextImpl() {}

    /**
   * GetEncodingType
   */
    virtual PlaintextEncodings GetEncodingType() const = 0;

    /**
   * Get the scaling factor of the plaintext for CKKS-based plaintexts.
   */
    virtual bool Encode() = 0;

    /**
   * Decode the polynomial into the plaintext
   */
    virtual bool Decode() = 0;

    /**
   * Calculate and return lower bound that can be encoded with the plaintext
   */
    template <typename Element>
    Element& GetElement() {
        OPENFHE_THROW("Generic GetElement() is not implemented");
    }

    template <typename Element>
    const Element& GetElement() const {
        OPENFHE_THROW("Generic GetElement() is not implemented");
    }
   */
    virtual size_t GetLength() const = 0;

    /**
   * resize the plaintext; only works for plaintexts that support a resizable
   */
    virtual void SetLength(size_t newSize) {
        OPENFHE_THROW("resize not supported");
    }


    virtual double GetLogError() const {
        OPENFHE_THROW("no estimate of noise available for the current scheme");
    }

    virtual double GetLogPrecision() const {
        OPENFHE_THROW("no estimate of precision available for the current scheme");
    }

    virtual const std::string& GetStringValue() const {
        OPENFHE_THROW("not a string");
    }
    virtual const std::vector<int64_t>& GetCoefPackedValue() const {
        OPENFHE_THROW("not a packed coefficient vector");
    }
    virtual const std::vector<int64_t>& GetPackedValue() const {
        OPENFHE_THROW("not a packed coefficient vector");
    }
    virtual const std::vector<std::complex<double>>& GetCKKSPackedValue() const {
        OPENFHE_THROW("not a packed vector of complex numbers");
    }
    virtual std::vector<double> GetRealPackedValue() const {
        OPENFHE_THROW("not a packed vector of real numbers");
    }
    virtual void SetStringValue(const std::string&) {
        OPENFHE_THROW("does not support a string");
    }
    virtual void SetIntVectorValue(const std::vector<int64_t>&) {
        OPENFHE_THROW("does not support an int vector");
    }

   */
    virtual bool CompareTo(const PlaintextImpl& other) const = 0;

    /**
   * operator== for plaintexts.  This method makes sure the plaintexts are of
   */
    virtual void PrintValue(std::ostream& out) const = 0;

    /**
   * GetFormattedValues() has a logic similar to PrintValue(), but requires a precision as an argument
   */
    virtual std::string GetFormattedValues(int64_t precision) const {
        OPENFHE_THROW("not implemented");
    }
};
 */
template <>
inline const Poly& PlaintextImpl::GetElement<Poly>() const {
    return encodedVector;
}

template <>
inline Poly& PlaintextImpl::GetElement<Poly>() {
    return encodedVector;
}
 */
template <>
inline const NativePoly& PlaintextImpl::GetElement<NativePoly>() const {
    return encodedNativeVector;
}

template <>
inline NativePoly& PlaintextImpl::GetElement<NativePoly>() {
    return encodedNativeVector;
}
 */
template <>
inline const DCRTPoly& PlaintextImpl::GetElement<DCRTPoly>() const {
    return encodedVectorDCRT;
}

template <>
inline DCRTPoly& PlaintextImpl::GetElement<DCRTPoly>() {
    return encodedVectorDCRT;
}


//========================================
//===== File: ./src/pke/include/encoding/plaintextfactory.h =====
//========================================

namespace lbcrypto {

class PlaintextFactory {
    PlaintextFactory() = delete;  // never construct one!

public:
    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>
    static Plaintext MakePlaintext(PlaintextEncodings encoding, std::shared_ptr<T> vp, EncodingParams ep,
                                   SCHEME schemeID = SCHEME::INVALID_SCHEME) {
        switch (encoding) {
            case COEF_PACKED_ENCODING:

    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>
    static Plaintext MakePlaintext(const std::vector<int64_t>& value, PlaintextEncodings encoding,
                                   std::shared_ptr<T> vp, EncodingParams ep, SCHEME schemeID = SCHEME::INVALID_SCHEME,
                                   size_t noiseScaleDeg = 1, uint32_t level = 0, NativeInteger scalingFactor = 1) {
        // Check if plaintext has got enough slots for data (value)

    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>
    static Plaintext MakePlaintext(const std::string& value, PlaintextEncodings encoding, std::shared_ptr<T> vp,
                                   EncodingParams ep, SCHEME schemeID = SCHEME::INVALID_SCHEME,
                                   size_t noiseScaleDeg = 1, uint32_t level = 0, NativeInteger scalingFactor = 1) {
        // Check if plaintext has got enough slots for data (value)


//========================================
//===== File: ./src/pke/include/encoding/plaintext-fwd.h =====
//========================================

namespace lbcrypto {

class PlaintextImpl;

using Plaintext      = std::shared_ptr<PlaintextImpl>;
using ConstPlaintext = std::shared_ptr<PlaintextImpl>;


//========================================
//===== File: ./src/pke/include/encoding/stringencoding.h =====
//========================================

namespace lbcrypto {

class StringEncoding : public PlaintextImpl {
    std::string ptx;
    // enum EncodingType { CHAR7bit } encoding = CHAR7bit;

public:
    // these three constructors are used inside of Decrypt
    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>

    template <typename T, typename std::enable_if<std::is_same<T, Poly::Params>::value ||
                                                      std::is_same<T, NativePoly::Params>::value ||
                                                      std::is_same<T, DCRTPoly::Params>::value,
                                                  bool>::type = true>

    virtual ~StringEncoding() {}

    /**
   * GetStringValue


//========================================
//===== File: ./src/pke/include/gen-cryptocontext.h =====
//========================================

namespace lbcrypto {

// forward declarations (don't include headers as compilation fails when you do)
template <typename T>
class CCParams;

template <typename T>
typename T::ContextType GenCryptoContext(const CCParams<T>& params) {
    return T::genCryptoContext(params);
}


//========================================
//===== File: ./src/pke/include/globals.h =====
//========================================

namespace lbcrypto {
/**
     * PrecomputeCRTTablesAfterDeserializaton() will be executed during CryptoContext deserialization.
     * Deserializing without this precomputation can speed up the procedure by a factor of 100.


//========================================
//===== File: ./src/pke/include/key/evalkey.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface for evaluation/proxy keys
 */
template <class Element>
class EvalKeyImpl : public Key<Element> {
public:
    /**
   * Basic constructor for setting crypto params
   *

    explicit EvalKeyImpl(CryptoContext<Element> cc = 0) : Key<Element>(cc) {}

    virtual ~EvalKeyImpl() {}

    /**
   * Setter function to store Relinearization Element Vector A.

    virtual void SetAVector(const std::vector<Element>& a) {
        OPENFHE_THROW("SetAVector copy operation not supported");
    }


    virtual void SetAVector(std::vector<Element>&& a) {
        OPENFHE_THROW("SetAVector move operation not supported");
    }


    virtual const std::vector<Element>& GetAVector() const {
        OPENFHE_THROW("GetAVector operation not supported");
    }


    virtual void SetBVector(const std::vector<Element>& b) {
        OPENFHE_THROW("SetBVector copy operation not supported");
    }


    virtual void SetBVector(std::vector<Element>&& b) {
        OPENFHE_THROW("SetBVector move operation not supported");
    }


    virtual const std::vector<Element>& GetBVector() const {
        OPENFHE_THROW("GetBVector operation not supported");
    }


    virtual void SetA(const Element& a) {
        OPENFHE_THROW("SetA copy operation not supported");
    }

   */
    virtual void SetA(Element&& a) {
        OPENFHE_THROW("SetA move operation not supported");
    }


    virtual const Element& GetA() const {
        OPENFHE_THROW("GetA operation not supported");
    }


    virtual void SetAinDCRT(const DCRTPoly& a) {
        OPENFHE_THROW("SetAinDCRT copy operation not supported");
    }

   */
    virtual void SetAinDCRT(DCRTPoly&& a) {
        OPENFHE_THROW("SetAinDCRT move operation not supported");
    }


    virtual const DCRTPoly& GetAinDCRT() const {
        OPENFHE_THROW("GetAinDCRT operation not supported");
    }


    virtual void SetBinDCRT(const DCRTPoly& b) {
        OPENFHE_THROW("SetAinDCRT copy operation not supported");
    }

   */
    virtual void SetBinDCRT(DCRTPoly&& b) {
        OPENFHE_THROW("SetAinDCRT move operation not supported");
    }


    virtual const DCRTPoly& GetBinDCRT() const {
        OPENFHE_THROW("GetAinDCRT operation not supported");
    }

    virtual void ClearKeys() {
        OPENFHE_THROW("ClearKeys operation is not supported");
    }


    virtual bool key_compare(const EvalKeyImpl& other) const {
        return false;
    }

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<Key<Element>>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(::cereal::base_class<Key<Element>>(this));
    }


//========================================
//===== File: ./src/pke/include/key/evalkey-fwd.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class EvalKeyImpl;

template <typename Element>
using EvalKey = std::shared_ptr<EvalKeyImpl<Element>>;

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/key/evalkeyrelin.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Concrete class for Relinearization keys of RLWE scheme
 */
template <class Element>
class EvalKeyRelinImpl : public EvalKeyImpl<Element> {
public:
    /**
   * Basic constructor for setting crypto params
   *
   */
    explicit EvalKeyRelinImpl(CryptoContext<Element> cc = 0) : EvalKeyImpl<Element>(cc) {}

    virtual ~EvalKeyRelinImpl() {}

    /**
   * Copy constructor
   */
    explicit EvalKeyRelinImpl(const EvalKeyRelinImpl<Element>& rhs)
        : EvalKeyImpl<Element>(rhs.GetCryptoContext()), m_rKey(rhs.m_rKey) {}

    /**
   */
    explicit EvalKeyRelinImpl(EvalKeyRelinImpl<Element>&& rhs) noexcept
        : EvalKeyImpl<Element>(rhs.GetCryptoContext()), m_rKey(std::move(rhs.m_rKey)) {}

    operator bool() const {
   */
    virtual void SetAVector(const std::vector<Element>& a) {
        m_rKey.insert(m_rKey.begin() + 0, a);
    }

   */
    virtual void SetAVector(std::vector<Element>&& a) {
        m_rKey.insert(m_rKey.begin() + 0, std::move(a));
    }

   */
    virtual const std::vector<Element>& GetAVector() const {
        return m_rKey.at(0);
    }

   */
    virtual void SetBVector(const std::vector<Element>& b) {
        m_rKey.insert(m_rKey.begin() + 1, b);
    }

   */
    virtual void SetBVector(std::vector<Element>&& b) {
        m_rKey.insert(m_rKey.begin() + 1, std::move(b));
    }

   */
    virtual const std::vector<Element>& GetBVector() const {
        return m_rKey.at(1);
    }


    virtual void SetAinDCRT(const DCRTPoly& a) {
        m_dcrtKeys.insert(m_dcrtKeys.begin() + 0, a);
    }

   */
    virtual void SetAinDCRT(DCRTPoly&& a) {
        m_dcrtKeys.insert(m_dcrtKeys.begin() + 0, std::move(a));
    }


    virtual const DCRTPoly& GetAinDCRT() const {
        return m_dcrtKeys.at(0);
    }


    virtual void SetBinDCRT(const DCRTPoly& b) {
        m_dcrtKeys.insert(m_dcrtKeys.begin() + 1, b);
    }

   */
    virtual void SetBinDCRT(DCRTPoly&& b) {
        m_dcrtKeys.insert(m_dcrtKeys.begin() + 1, std::move(b));
    }


    virtual const DCRTPoly& GetBinDCRT() const {
        return m_dcrtKeys.at(1);
    }

    virtual void ClearKeys() {
        m_rKey.clear();
        m_dcrtKeys.clear();
    }

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<EvalKeyImpl<Element>>(this));
        ar(::cereal::make_nvp("k", m_rKey));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    // private member to store vector of vector of Element.
    std::vector<std::vector<Element>> m_rKey;



//========================================
//===== File: ./src/pke/include/key/evalkeyrelin-fwd.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class EvalKeyRelinImpl;

template <typename Element>
using EvalKeyRelin = std::shared_ptr<EvalKeyRelinImpl<Element>>;

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/key/key.h =====
//========================================
 */
namespace lbcrypto {
/**
 * @brief Abstract interface class for  Keys
 *
 */
template <class Element>
class Key : public CryptoObject<Element>, public Serializable {
public:
    explicit Key(CryptoContext<Element> cc = 0, const std::string& id = "") : CryptoObject<Element>(cc, id) {}

    explicit Key(std::shared_ptr<CryptoObject<Element>> co) : CryptoObject<Element>(co) {}

    virtual ~Key() {}

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<CryptoObject<Element>>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(::cereal::base_class<CryptoObject<Element>>(this));
    }


//========================================
//===== File: ./src/pke/include/key/keypair.h =====
//========================================
 */
namespace lbcrypto {

template <class Element>
class KeyPair {
public:
    PublicKey<Element> publicKey;
    PrivateKey<Element> secretKey;


    explicit KeyPair(PublicKeyImpl<Element>* a = nullptr, PrivateKeyImpl<Element>* b = nullptr)
        : publicKey(a), secretKey(b) {}

    bool good() const {


//========================================
//===== File: ./src/pke/include/key/key-ser.h =====
//========================================


//========================================
//===== File: ./src/pke/include/key/privatekey.h =====
//========================================
 */
namespace lbcrypto {

/**
 * Generates a random 128-bit hash
 */
template <class Element>
class PrivateKeyImpl : public Key<Element> {
public:
    /**
   * Construct in context
   */
    explicit PrivateKeyImpl(CryptoContext<Element> cc = 0) : Key<Element>(cc, GenerateUniqueKeyID()) {}

    /**
   * Copy constructor
   */
    explicit PrivateKeyImpl(const PrivateKeyImpl<Element>& rhs)
        : Key<Element>(rhs.GetCryptoContext(), rhs.GetKeyTag()) {
        this->m_sk = rhs.m_sk;
    }
   */
    explicit PrivateKeyImpl(PrivateKeyImpl<Element>&& rhs) : Key<Element>(rhs.GetCryptoContext(), rhs.GetKeyTag()) {
        this->m_sk = std::move(rhs.m_sk);
    }


    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<Key<Element>>(this));
        ar(::cereal::make_nvp("s", m_sk));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    Element m_sk;
};



//========================================
//===== File: ./src/pke/include/key/privatekey-fwd.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class PrivateKeyImpl;

template <typename Element>
using PrivateKey = std::shared_ptr<PrivateKeyImpl<Element>>;

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/key/publickey.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Class for public key
 */
template <typename Element>
class PublicKeyImpl : public Key<Element> {
public:
    /**
   * Basic constructor
   *
   */
    explicit PublicKeyImpl(CryptoContext<Element> cc = 0, const std::string& id = "") : Key<Element>(cc, id) {}

    /**
   * Copy constructor
   */
    explicit PublicKeyImpl(const PublicKeyImpl<Element>& rhs)
        : Key<Element>(rhs.GetCryptoContext(), rhs.GetKeyTag()), m_h(rhs.m_h) {}

    /**
   */
    explicit PublicKeyImpl(PublicKeyImpl<Element>&& rhs) noexcept
        : Key<Element>(rhs.GetCryptoContext(), rhs.GetKeyTag()), m_h(std::move(rhs.m_h)) {}

    operator bool() const {

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<Key<Element>>(this));
        ar(::cereal::make_nvp("h", m_h));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

private:
    std::vector<Element> m_h;
};



//========================================
//===== File: ./src/pke/include/key/publickey-fwd.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class PublicKeyImpl;

template <typename Element>
using PublicKey = std::shared_ptr<PublicKeyImpl<Element>>;

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/keyswitch/keyswitch-base.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract class for LBC keyswitching
 */
template <class Element>
class KeySwitchBase {
    using ParmType = typename Element::Params;

public:
    KeySwitchBase(){};

    virtual ~KeySwitchBase(){};

    /**
   * Method for KeySwitchGen
   */
    virtual EvalKey<Element> KeySwitchGenInternal(const PrivateKey<Element> oldPrivateKey,
                                                  const PrivateKey<Element> newPrivateKey) const {
        OPENFHE_THROW(std::string(__func__) + " is not supported");
    }

    virtual EvalKey<Element> KeySwitchGenInternal(const PrivateKey<Element> oldPrivateKey,
                                                  const PrivateKey<Element> newPrivateKey,
                                                  const EvalKey<Element> evalKey) const {
        OPENFHE_THROW(std::string(__func__) + " is not supported");

    virtual EvalKey<Element> KeySwitchGenInternal(const PrivateKey<Element> oldPrivateKey,
                                                  const PublicKey<Element> newPublicKey) const {
        OPENFHE_THROW(std::string(__func__) + " is not supported");
    }

    virtual Ciphertext<Element> KeySwitch(ConstCiphertext<Element> ciphertext, const EvalKey<Element> evalKey) const;

    virtual void KeySwitchInPlace(Ciphertext<Element>& ciphertext, const EvalKey<Element> evalKey) const {
        OPENFHE_THROW("KeySwitch is not supported");
    }

    virtual Ciphertext<Element> KeySwitchExt(ConstCiphertext<Element> ciphertext, bool addFirst) const {
        OPENFHE_THROW("KeySwitchExt is not supported");
    }

    virtual Ciphertext<Element> KeySwitchDown(ConstCiphertext<Element> ciphertext) const {
        OPENFHE_THROW("KeySwitchDown is not supported");
    }

    virtual Element KeySwitchDownFirstElement(ConstCiphertext<Element> ciphertext) const {
        OPENFHE_THROW("KeySwitchDownFirstElement is not supported");
    }
    /////////////////////////////////////////

    virtual std::shared_ptr<std::vector<Element>> KeySwitchCore(const Element& a,
                                                                const EvalKey<Element> evalKey) const {
        OPENFHE_THROW("KeySwitchCore is not supported");
    }

    virtual std::shared_ptr<std::vector<Element>> EvalKeySwitchPrecomputeCore(
        const Element& c, std::shared_ptr<CryptoParametersBase<Element>> cryptoParamsBase) const {
        OPENFHE_THROW("EvalKeySwitchPrecomputeCore is not supported");
    }

    virtual std::shared_ptr<std::vector<Element>> EvalFastKeySwitchCore(
        const std::shared_ptr<std::vector<Element>> digits, const EvalKey<Element> evalKey,
        const std::shared_ptr<ParmType> paramsQl) const {
        OPENFHE_THROW("EvalFastKeySwitchCore is not supported");

    virtual std::shared_ptr<std::vector<Element>> EvalFastKeySwitchCoreExt(
        const std::shared_ptr<std::vector<Element>> digits, const EvalKey<Element> evalKey,
        const std::shared_ptr<ParmType> paramsQl) const {
        OPENFHE_THROW("EvalFastKeySwitchCoreExt is not supported");


//========================================
//===== File: ./src/pke/include/keyswitch/keyswitch-bv.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Implements BV key switching method from [Fully Homomorphic Encryption from
 */
class KeySwitchBV : public KeySwitchRNS {
    using ParmType = typename DCRTPoly::Params;
    using DugType  = typename DCRTPoly::DugType;
    using DggType  = typename DCRTPoly::DggType;

public:
    KeySwitchBV(){};

    virtual ~KeySwitchBV(){};

    EvalKey<DCRTPoly> KeySwitchGenInternal(const PrivateKey<DCRTPoly> oldPrivateKey,
                                           const PrivateKey<DCRTPoly> newPrivateKey) const override;

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<KeySwitchRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<KeySwitchRNS>(this));
    }


//========================================
//===== File: ./src/pke/include/keyswitch/keyswitch-hybrid.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Hybrid Keyswitching as described in [
 */
class KeySwitchHYBRID : public KeySwitchRNS {
    using ParmType = typename DCRTPoly::Params;
    using DugType  = typename DCRTPoly::DugType;
    using DggType  = typename DCRTPoly::DggType;

public:
    KeySwitchHYBRID(){};

    virtual ~KeySwitchHYBRID(){};

    EvalKey<DCRTPoly> KeySwitchGenInternal(const PrivateKey<DCRTPoly> oldPrivateKey,
                                           const PrivateKey<DCRTPoly> newPrivateKey) const override;

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<KeySwitchRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<KeySwitchRNS>(this));
    }


//========================================
//===== File: ./src/pke/include/keyswitch/keyswitch-rns.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief A child of KeySwitchBase for use with RNS keyswitching
 */
class KeySwitchRNS : public KeySwitchBase<DCRTPoly> {
public:
    virtual ~KeySwitchRNS() {}

    /////////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<KeySwitchBase<DCRTPoly>>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<KeySwitchBase<DCRTPoly>>(this));
    }

    virtual std::string SerializedObjectName() const {
        return "KeySwitchRNS";
    }
};


//========================================
//===== File: ./src/pke/include/metadata.h =====
//========================================

namespace lbcrypto {

class Metadata;
using MetadataMap = std::shared_ptr<std::map<std::string, std::shared_ptr<Metadata>>>;

/**
 */
class Metadata {
public:
    /**
   * Default constructor
   */
   */
    virtual ~Metadata() {}

    /**
   * This method creates a copy of the Metadata object
   */
    virtual std::shared_ptr<Metadata> Clone() const {
        return std::make_shared<Metadata>();
    }

   */
    virtual bool operator==(const Metadata& mdata) const {
        return true;
    }

   */
    virtual bool operator!=(const Metadata& mdata) const {
        return !(*this == mdata);
    }

   */
    virtual std::ostream& print(std::ostream& out) const {
        out << "[ ]" << std::endl;
        return out;
    }
   */
    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    /**
   */
    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
   */
    virtual std::string SerializedObjectName() const {
        return "Metadata";
    }

   */
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/pke/include/metadata-ser.h =====
//========================================


//========================================
//===== File: ./src/pke/include/openfhe.h =====
//========================================


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-advancedshe.h =====
//========================================
 */
namespace lbcrypto {

class AdvancedSHEBFVRNS : public AdvancedSHERNS {
public:
    virtual ~AdvancedSHEBFVRNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<AdvancedSHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<AdvancedSHERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-cryptoparameters.h =====
//========================================
 */
namespace lbcrypto {

class CryptoParametersBFVRNS : public CryptoParametersRNS {
    using ParmType = typename DCRTPoly::Params;

public:
    CryptoParametersBFVRNS() : CryptoParametersRNS() {}

    CryptoParametersBFVRNS(const CryptoParametersBFVRNS& rhs) : CryptoParametersRNS(rhs) {}

    virtual ~CryptoParametersBFVRNS() {}

    void PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech, EncryptionTechnique encTech,
                             MultiplicationTechnique multTech, uint32_t numPartQ, uint32_t auxBits,

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<CryptoParametersRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            std::string errMsg("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-fhe.h =====
//========================================
 */
namespace lbcrypto {

class FHEBFVRNS : public FHERNS {
public:
    virtual ~FHEBFVRNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<FHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<FHERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-leveledshe.h =====
//========================================
 */
namespace lbcrypto {

class LeveledSHEBFVRNS : public LeveledSHERNS {
public:
    virtual ~LeveledSHEBFVRNS() {}

    using LeveledSHERNS::EvalAddInPlace;


    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<LeveledSHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<LeveledSHERNS>(this));
    }

private:
    void RelinearizeCore(Ciphertext<DCRTPoly>& ciphertext, const EvalKey<DCRTPoly> evalKey) const;
};
}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-multiparty.h =====
//========================================
 */
namespace lbcrypto {
class MultipartyBFVRNS : public MultipartyRNS {
    using ParmType = typename DCRTPoly::Params;
    using IntType  = typename DCRTPoly::Integer;
    using DugType  = typename DCRTPoly::DugType;

public:
    virtual ~MultipartyBFVRNS() {}

    KeyPair<DCRTPoly> MultipartyKeyGen(CryptoContext<DCRTPoly> cc,
                                       const std::vector<PrivateKey<DCRTPoly>>& privateKeyVec,

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-parametergeneration.h =====
//========================================
 */
namespace lbcrypto {

class ParameterGenerationBFVRNS : public ParameterGenerationRNS {
public:
    virtual ~ParameterGenerationBFVRNS() {}

    bool ParamsGenBFVRNS(std::shared_ptr<CryptoParametersBase<DCRTPoly>> cryptoParams, uint32_t evalAddCount,
                         uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrBits, uint32_t n,

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-pke.h =====
//========================================
 */
namespace lbcrypto {

class PKEBFVRNS : public PKERNS {
    using ParmType = typename DCRTPoly::Params;
    using IntType  = typename DCRTPoly::Integer;
    using DugType  = typename DCRTPoly::DugType;

public:
    virtual ~PKEBFVRNS() {}

    KeyPair<DCRTPoly> KeyGenInternal(CryptoContext<DCRTPoly> cc, bool makeSparse) const override;


    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PKERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PKERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-pre.h =====
//========================================
 */
namespace lbcrypto {

class PREBFVRNS : public PRERNS {
public:
    virtual ~PREBFVRNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PRERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PRERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-scheme.h =====
//========================================
 */
namespace lbcrypto {

class SchemeBFVRNS : public SchemeRNS {
public:
    SchemeBFVRNS() {
        this->m_ParamsGen = std::make_shared<ParameterGenerationBFVRNS>();
    }

    virtual ~SchemeBFVRNS() {}

    bool operator==(const SchemeBase<DCRTPoly>& sch) const override {
        return dynamic_cast<const SchemeBFVRNS*>(&sch) != nullptr;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<SchemeRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(cereal::base_class<SchemeRNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/bfvrns-ser.h =====
//========================================


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/gen-cryptocontext-bfvrns.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class CryptoContextFactory;

class CryptoContextBFVRNS {
    using Element = DCRTPoly;

public:
    using ContextType               = CryptoContext<Element>;  // required by GenCryptoContext() in gen-cryptocontext.h
    using Factory                   = CryptoContextFactory<Element>;
    using PublicKeyEncryptionScheme = SchemeBFVRNS;

    static CryptoContext<Element> genCryptoContext(const CCParams<CryptoContextBFVRNS>& parameters) {
        validateParametersForCryptocontext(parameters);
        return genCryptoContextBFVRNSInternal<CryptoContextBFVRNS, Element>(parameters);
    }


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/gen-cryptocontext-bfvrns-internal.h =====
//========================================

namespace lbcrypto {

// forward declarations (don't include headers as compilation fails when you do)
template <typename T>
class CCParams;

template <typename ContextGeneratorType, typename Element>
typename ContextGeneratorType::ContextType genCryptoContextBFVRNSInternal(
    const CCParams<ContextGeneratorType>& parameters) {
    using ParmType                   = typename Element::Params;


//========================================
//===== File: ./src/pke/include/scheme/bfvrns/gen-cryptocontext-bfvrns-params.h =====
//========================================

namespace lbcrypto {

class CryptoContextBFVRNS;

// TODO (dsuponit): review class CCParams<> as we may need to add a class template CCParams<> (see the comments below)
// every CCParams class should include the following forward declaration as there is
// derived from Params or have them completely independent.
template <typename T>
class CCParams;
//====================================================================================================================
template <>
class CCParams<CryptoContextBFVRNS> : public Params {
public:
    CCParams() : Params(BFVRNS_SCHEME) {}
    explicit CCParams(const std::vector<std::string>& vals) : Params(vals) {}
    CCParams(const CCParams& obj) = default;
    CCParams(CCParams&& obj)      = default;
    ~CCParams()                   = default;


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-advancedshe.h =====
//========================================
 */
namespace lbcrypto {

class AdvancedSHEBGVRNS : public AdvancedSHERNS {
public:
    virtual ~AdvancedSHEBGVRNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<AdvancedSHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<AdvancedSHERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-cryptoparameters.h =====
//========================================
 */
namespace lbcrypto {

class CryptoParametersBGVRNS : public CryptoParametersRNS {
    using ParmType = typename DCRTPoly::Params;

public:
    CryptoParametersBGVRNS() : CryptoParametersRNS() {}

    CryptoParametersBGVRNS(const CryptoParametersBGVRNS& rhs) : CryptoParametersRNS(rhs) {}

    virtual ~CryptoParametersBGVRNS() {}

    void PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech, EncryptionTechnique encTech,
                             MultiplicationTechnique multTech, uint32_t numPartQ, uint32_t auxBits,

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<CryptoParametersRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            std::string errMsg("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-fhe.h =====
//========================================
 */
namespace lbcrypto {

class FHEBGVRNS : public FHERNS {
public:
    virtual ~FHEBGVRNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<FHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<FHERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-leveledshe.h =====
//========================================
 */
namespace lbcrypto {

class LeveledSHEBGVRNS : public LeveledSHERNS {
public:
    virtual ~LeveledSHEBGVRNS() {}

    /////////////////////////////////////
    // AUTOMORPHISM

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<LeveledSHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<LeveledSHERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-multiparty.h =====
//========================================
 */
namespace lbcrypto {
class MultipartyBGVRNS : public MultipartyRNS {
public:
    virtual ~MultipartyBGVRNS() {}

    DecryptResult MultipartyDecryptFusion(const std::vector<Ciphertext<DCRTPoly>>& ciphertextVec,
                                          NativePoly* plaintext) const override;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-parametergeneration.h =====
//========================================
 */
namespace lbcrypto {

/*
   * Struct that keeps track of all noise estimates necessary to compute moduli.
   */
struct BGVNoiseEstimates {
    double Berr;
    double Bkey;
    double expansionFactor;

class ParameterGenerationBGVRNS : public ParameterGenerationRNS {
public:
    virtual ~ParameterGenerationBGVRNS() {}

    /*
   * Method that generates parameters for the BGV RNS scheme.

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {

private:
    /*
   * Method that computes a security-compliant ring dimension.
   *


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-pke.h =====
//========================================
 */
namespace lbcrypto {

class PKEBGVRNS : public PKERNS {
    using ParmType = typename DCRTPoly::Params;
    using IntType  = typename DCRTPoly::Integer;
    using DugType  = typename DCRTPoly::DugType;

public:
    virtual ~PKEBGVRNS() {}

    /**
   * Method for decrypting plaintext using LBC

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PKERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PKERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-pre.h =====
//========================================
 */
namespace lbcrypto {

class PREBGVRNS : public PRERNS {
public:
    virtual ~PREBGVRNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PRERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PRERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-scheme.h =====
//========================================
 */
namespace lbcrypto {

class SchemeBGVRNS : public SchemeRNS {
public:
    SchemeBGVRNS() {
        this->m_ParamsGen = std::make_shared<ParameterGenerationBGVRNS>();
    }

    virtual ~SchemeBGVRNS() {}

    bool operator==(const SchemeBase<DCRTPoly>& sch) const override {
        return dynamic_cast<const SchemeBGVRNS*>(&sch) != nullptr;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<SchemeRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(cereal::base_class<SchemeRNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/bgvrns-ser.h =====
//========================================


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/gen-cryptocontext-bgvrns.h =====
//========================================

namespace lbcrypto {

template <typename Element>
class CryptoContextFactory;

class CryptoContextBGVRNS {
    using Element = DCRTPoly;

public:
    using ContextType               = CryptoContext<Element>;  // required by GenCryptoContext() in gen-cryptocontext.h
    using Factory                   = CryptoContextFactory<Element>;
    using PublicKeyEncryptionScheme = SchemeBGVRNS;

    static CryptoContext<Element> genCryptoContext(const CCParams<CryptoContextBGVRNS>& parameters) {
        validateParametersForCryptocontext(parameters);
        return genCryptoContextBGVRNSInternal<CryptoContextBGVRNS, Element>(parameters);
    }


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/gen-cryptocontext-bgvrns-internal.h =====
//========================================

namespace lbcrypto {

// forward declarations (don't include headers as compilation fails when you do)
template <typename T>
class CCParams;

template <typename ContextGeneratorType, typename Element>
typename ContextGeneratorType::ContextType genCryptoContextBGVRNSInternal(
    const CCParams<ContextGeneratorType>& parameters) {
    using ParmType                   = typename Element::Params;


//========================================
//===== File: ./src/pke/include/scheme/bgvrns/gen-cryptocontext-bgvrns-params.h =====
//========================================

namespace lbcrypto {

class CryptoContextBGVRNS;

// every CCParams class should include the following forward declaration as there is
// no general CCParams class template. This way we may create scheme specific classes
// derived from Params or have them completely independent.
template <typename T>
class CCParams;
//====================================================================================================================
template <>
class CCParams<CryptoContextBGVRNS> : public Params {
public:
    CCParams() : Params(BGVRNS_SCHEME) {}
    explicit CCParams(const std::vector<std::string>& vals) : Params(vals) {}
    CCParams(const CCParams& obj) = default;
    CCParams(CCParams&& obj)      = default;
    ~CCParams()                   = default;


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-advancedshe.h =====
//========================================
 */
namespace lbcrypto {

class AdvancedSHECKKSRNS : public AdvancedSHERNS {
public:
    virtual ~AdvancedSHECKKSRNS() {}

    //------------------------------------------------------------------------------
    // LINEAR WEIGHTED SUM

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<AdvancedSHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<AdvancedSHERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-cryptoparameters.h =====
//========================================
 */
namespace lbcrypto {

class CryptoParametersCKKSRNS : public CryptoParametersRNS {
    using ParmType = typename DCRTPoly::Params;

public:
    CryptoParametersCKKSRNS() : CryptoParametersRNS() {}

    CryptoParametersCKKSRNS(const CryptoParametersCKKSRNS& rhs) : CryptoParametersRNS(rhs) {}

    virtual ~CryptoParametersCKKSRNS() {}

    void PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech, EncryptionTechnique encTech,
                             MultiplicationTechnique multTech, uint32_t numPartQ, uint32_t auxBits,

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<CryptoParametersRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            std::string errMsg("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-fhe.h =====
//========================================
 */
namespace lbcrypto {

class CKKSBootstrapPrecom {
public:
    CKKSBootstrapPrecom() {}

    CKKSBootstrapPrecom(const CKKSBootstrapPrecom& rhs) {

    virtual ~CKKSBootstrapPrecom() {}
    // the inner dimension in the baby-step giant-step strategy
    uint32_t m_dim1 = 0;


    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::make_nvp("dim1_Enc", m_dim1));
        ar(cereal::make_nvp("dim1_Dec", m_paramsDec[CKKS_BOOT_PARAMS::GIANT_STEP]));

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::make_nvp("dim1_Enc", m_dim1));
        ar(cereal::make_nvp("dim1_Dec", m_paramsDec[CKKS_BOOT_PARAMS::GIANT_STEP]));

class FHECKKSRNS : public FHERNS {
    using ParmType = typename DCRTPoly::Params;

public:
    virtual ~FHECKKSRNS() {}

    //------------------------------------------------------------------------------
    // Bootstrap Wrapper

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<FHERNS>(this));
        ar(cereal::make_nvp("paramMap", m_bootPrecomMap));

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<FHERNS>(this));
        ar(cereal::make_nvp("paramMap", m_bootPrecomMap));
    // To be deprecated; left for backwards compatibility
    static uint32_t GetBootstrapDepth(uint32_t approxModDepth, const std::vector<uint32_t>& levelBudget,
                                      SecretKeyDist secretKeyDist);

    static uint32_t GetBootstrapDepth(const std::vector<uint32_t>& levelBudget, SecretKeyDist secretKeyDist);

    std::string SerializedObjectName() const {
        return "FHECKKSRNS";

private:
    //------------------------------------------------------------------------------
    // Auxiliary Bootstrap Functions
    //------------------------------------------------------------------------------
                                       const CryptoContextImpl<DCRTPoly>& cc);
    static uint32_t GetModDepthInternal(SecretKeyDist secretKeyDist);

    void AdjustCiphertext(Ciphertext<DCRTPoly>& ciphertext, double correction) const;

    const uint32_t K_UNIFORM = 512;  // upper bound for the number of overflows in the uniform secret case
    static const uint32_t R_UNIFORM =
        6;  // number of double-angle iterations in CKKS bootstrapping. Must be static because it is used in a static function.
    static const uint32_t R_SPARSE =
        3;  // number of double-angle iterations in CKKS bootstrapping. Must be static because it is used in a static function.
    uint32_t m_correctionFactor = 0;  // correction factor, which we scale the message by to improve precision

    // Chebyshev series coefficients for the SPARSE case
    static const inline std::vector<double> g_coefficientsSparse{
        -0.18646470117093214,   0.036680543700430925,    -0.20323558926782626,     0.029327390306199311,
        -0.24346234149506416,   0.011710240188138248,    -0.27023281815251715,     -0.017621188001030602,
        -0.21383614034992021,   -0.048567932060728937,   -0.013982336571484519,    -0.051097367628344978,
    // Chebyshev series coefficients for the OPTIMIZED/uniform case
    static const inline std::vector<double> g_coefficientsUniform{
        0.15421426400235561,    -0.0037671538417132409,  0.16032011744533031,      -0.0034539657223742453,
        0.17711481926851286,    -0.0027619720033372291,  0.19949802549604084,      -0.0015928034845171929,
        0.21756948616367638,    0.00010729951647566607,  0.21600427371240055,      0.0022171399198851363,


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-leveledshe.h =====
//========================================
 */
namespace lbcrypto {

class LeveledSHECKKSRNS : public LeveledSHERNS {
public:
    virtual ~LeveledSHECKKSRNS() {}

    /////////////////////////////////////////
    // SHE ADDITION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<LeveledSHERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<LeveledSHERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-multiparty.h =====
//========================================
 */
namespace lbcrypto {
class MultipartyCKKSRNS : public MultipartyRNS {
public:
    virtual ~MultipartyCKKSRNS() {}

    DecryptResult MultipartyDecryptFusion(const std::vector<Ciphertext<DCRTPoly>>& ciphertextVec,
                                          Poly* plaintext) const override;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-parametergeneration.h =====
//========================================
 */
namespace lbcrypto {

class ParameterGenerationCKKSRNS : public ParameterGenerationRNS {
public:
    virtual ~ParameterGenerationCKKSRNS() {}

    bool ParamsGenCKKSRNS(std::shared_ptr<CryptoParametersBase<DCRTPoly>> cryptoParams, usint cyclOrder,
                          usint numPrimes, usint scalingModSize, usint firstModSize, uint32_t mulPartQ,

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-pke.h =====
//========================================
 */
namespace lbcrypto {

class PKECKKSRNS : public PKERNS {
    using ParmType = typename DCRTPoly::Params;
    using IntType  = typename DCRTPoly::Integer;
    using DugType  = typename DCRTPoly::DugType;

public:
    virtual ~PKECKKSRNS() {}

    /**
   * Method for decrypting plaintext with noise flooding

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PKERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PKERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-pre.h =====
//========================================
 */
namespace lbcrypto {

class PRECKKSRNS : public PRERNS {
public:
    virtual ~PRECKKSRNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PRERNS>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PRERNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-scheme.h =====
//========================================
 */
namespace lbcrypto {

class SchemeCKKSRNS : public SchemeRNS {
public:
    SchemeCKKSRNS() {
        this->m_ParamsGen = std::make_shared<ParameterGenerationCKKSRNS>();
    }

    virtual ~SchemeCKKSRNS() {}

    bool operator==(const SchemeBase<DCRTPoly>& sch) const override {
        return dynamic_cast<const SchemeCKKSRNS*>(&sch) != nullptr;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<SchemeRNS>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(cereal::base_class<SchemeRNS>(this));
    }


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-schemeswitching.h =====
//========================================
 */
namespace lbcrypto {

class SWITCHCKKSRNS : public FHERNS {
    using ParmType = typename DCRTPoly::Params;

public:
    virtual ~SWITCHCKKSRNS() {}

    //------------------------------------------------------------------------------
    // Scheme Switching Wrappers

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<FHERNS>(this));
        ar(cereal::make_nvp("QLWE", m_modulus_LWE));

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<FHERNS>(this));
        ar(cereal::make_nvp("QLWE", m_modulus_LWE));

private:
    std::vector<ConstPlaintext> EvalLTPrecomputeSwitch(const CryptoContextImpl<DCRTPoly>& cc,
                                                       const std::vector<std::vector<std::complex<double>>>& A,
                                                       uint32_t dim1, uint32_t L, double scale) const;


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-ser.h =====
//========================================


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/ckksrns-utils.h =====
//========================================

namespace lbcrypto {

struct longDiv {
    std::vector<double> q;
    std::vector<double> r;


namespace CKKS_BOOT_PARAMS {
/**
   * Enums representing indices for the vector returned by GetCollapsedFFTParams()
   */
enum {
    LEVEL_BUDGET,  // the level budget
    LAYERS_COLL,   // the number of layers to collapse in one level
    LAYERS_REM,  // the number of layers remaining to be collapsed in one level to have exactly the number of levels specified in the level budget


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns.h =====
//========================================

namespace lbcrypto {

class CryptoContextCKKSRNS {
    using Element = DCRTPoly;

public:
    using ContextType               = CryptoContext<Element>;  // required by GenCryptoContext() in gen-cryptocontext.h
    using Factory                   = CryptoContextFactory<Element>;
    using PublicKeyEncryptionScheme = SchemeCKKSRNS;

    static CryptoContext<Element> genCryptoContext(const CCParams<CryptoContextCKKSRNS>& parameters) {
        validateParametersForCryptocontext(parameters);
        return genCryptoContextCKKSRNSInternal<CryptoContextCKKSRNS, Element>(parameters);
    }


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h =====
//========================================

namespace lbcrypto {

// forward declarations (don't include headers as compilation fails when you do)
template <typename T>
class CCParams;

template <typename ContextGeneratorType, typename Element>
typename ContextGeneratorType::ContextType genCryptoContextCKKSRNSInternal(
    const CCParams<ContextGeneratorType>& parameters) {
#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-params.h =====
//========================================

namespace lbcrypto {

class CryptoContextCKKSRNS;

// every CCParams class should include the following forward declaration as there is
// no general CCParams class template. This way we may create scheme specific classes
// derived from Params or have them completely independent.
template <typename T>
class CCParams;
//====================================================================================================================
template <>
class CCParams<CryptoContextCKKSRNS> : public Params {
public:
    CCParams() : Params(CKKSRNS_SCHEME) {}
    explicit CCParams(const std::vector<std::string>& vals) : Params(vals) {}
    CCParams(const CCParams& obj) = default;
    CCParams(CCParams&& obj)      = default;
    ~CCParams()                   = default;


//========================================
//===== File: ./src/pke/include/scheme/ckksrns/schemeswitching-data-serializer.h =====
//========================================

namespace lbcrypto {

class DataAndLocation {
protected:
    CryptoContext<DCRTPoly> cryptoContext{nullptr};
    PublicKey<DCRTPoly> publicKey{nullptr};
    std::shared_ptr<lbcrypto::BinFHEContext> binFHECryptoContext{nullptr};

public:
    void SetDataDirectory(const std::string& dir) {
        if (dir.empty()) {
            OPENFHE_THROW("dir is an empty string");

class SchemeSwitchingDataSerializer : public DataAndLocation {
public:
    SchemeSwitchingDataSerializer(CryptoContext<DCRTPoly> cryptoContext0, PublicKey<DCRTPoly> publicKey0,
                                  Ciphertext<DCRTPoly> RAWCiphertext0)
        : DataAndLocation(cryptoContext0, publicKey0, RAWCiphertext0) {}

class SchemeSwitchingDataDeserializer : public DataAndLocation {
public:
    SchemeSwitchingDataDeserializer() = default;

    CryptoContext<DCRTPoly> getCryptoContext() {


//========================================
//===== File: ./src/pke/include/scheme/gen-cryptocontext-params.h =====
//========================================

namespace lbcrypto {

//====================================================================================================================
class Params {
    // NOTE: if any data member (below) is added/removed then update
    // cryptocontextparams-case.cpp and cryptocontextparams-defaults.h


protected:
    // How to disable a particular setter for a particular scheme and get an exception thrown if a user tries to call it:
    // 1. The set function should be declared virtual in this file
    // 2. The same function should be re-defined in the scheme-specific derived file using macros DISABLED_FOR_xxxxRNS defined below.

public:
    explicit Params(SCHEME scheme0 = INVALID_SCHEME) {
        SetToDefaults(scheme0);
    }

     */
    explicit Params(const std::vector<std::string>& vals);

    Params(const Params& obj) = default;
    Params(Params&& obj)      = default;

    virtual ~Params() = default;

    /**
     * getAllParamsDataMembers() returns names of all data members of Params and the scheme enum ALWAYS goes first.
     */
    static const std::vector<std::string> getAllParamsDataMembers() {
        return {"scheme",
                "ptModulus",
                "digitSize",
    // They all must be virtual, so any of them can be disabled in the derived class
    virtual void SetPlaintextModulus(PlaintextModulus ptModulus0) {
        ptModulus = ptModulus0;
    }
    virtual void SetDigitSize(uint32_t digitSize0) {
        digitSize = digitSize0;
    }
    virtual void SetStandardDeviation(float standardDeviation0) {
        standardDeviation = standardDeviation0;
    }
    virtual void SetSecretKeyDist(SecretKeyDist secretKeyDist0) {
        secretKeyDist = secretKeyDist0;
    }
    virtual void SetMaxRelinSkDeg(uint32_t maxRelinSkDeg0) {
        maxRelinSkDeg = maxRelinSkDeg0;
    }
    virtual void SetPREMode(ProxyReEncryptionMode PREMode0) {
        PREMode = PREMode0;
    }
    virtual void SetMultipartyMode(MultipartyMode multipartyMode0) {
        multipartyMode = multipartyMode0;
    }
    virtual void SetExecutionMode(ExecutionMode executionMode0) {
        executionMode = executionMode0;
    }
    virtual void SetDecryptionNoiseMode(DecryptionNoiseMode decryptionNoiseMode0) {
        decryptionNoiseMode = decryptionNoiseMode0;
    }
    virtual void SetNoiseEstimate(double noiseEstimate0) {
        noiseEstimate = noiseEstimate0;
    }
    virtual void SetDesiredPrecision(double desiredPrecision0) {
        desiredPrecision = desiredPrecision0;
    }
    virtual void SetStatisticalSecurity(uint32_t statisticalSecurity0) {
        statisticalSecurity = statisticalSecurity0;
    }
    virtual void SetNumAdversarialQueries(uint32_t numAdversarialQueries0) {
        numAdversarialQueries = numAdversarialQueries0;
    }
    virtual void SetThresholdNumOfParties(uint32_t thresholdNumOfParties0) {
        thresholdNumOfParties = thresholdNumOfParties0;
    }
    virtual void SetKeySwitchTechnique(KeySwitchTechnique ksTech0) {
        ksTech = ksTech0;
    }
    virtual void SetScalingTechnique(ScalingTechnique scalTech0) {
        scalTech = scalTech0;
    }
    virtual void SetBatchSize(uint32_t batchSize0) {
        batchSize = batchSize0;
    }
    virtual void SetFirstModSize(uint32_t firstModSize0) {
        firstModSize = firstModSize0;
    }
    virtual void SetNumLargeDigits(uint32_t numLargeDigits0) {
        numLargeDigits = numLargeDigits0;
    }
    virtual void SetMultiplicativeDepth(uint32_t multiplicativeDepth0) {
        multiplicativeDepth = multiplicativeDepth0;
    }
    virtual void SetScalingModSize(uint32_t scalingModSize0) {
        scalingModSize = scalingModSize0;
    }
    virtual void SetSecurityLevel(SecurityLevel securityLevel0) {
        securityLevel = securityLevel0;
    }
    virtual void SetRingDim(uint32_t ringDim0) {
        ringDim = ringDim0;
    }
    virtual void SetEvalAddCount(uint32_t evalAddCount0) {
        evalAddCount = evalAddCount0;
    }
    virtual void SetKeySwitchCount(uint32_t keySwitchCount0) {
        keySwitchCount = keySwitchCount0;
    }
    virtual void SetEncryptionTechnique(EncryptionTechnique encryptionTechnique0) {
        encryptionTechnique = encryptionTechnique0;
    }
    virtual void SetMultiplicationTechnique(MultiplicationTechnique multiplicationTechnique0) {
        multiplicationTechnique = multiplicationTechnique0;
    }
    virtual void SetPRENumHops(uint32_t PRENumHops0) {
        PRENumHops = PRENumHops0;
    }
    virtual void SetInteractiveBootCompressionLevel(COMPRESSION_LEVEL interactiveBootCompressionLevel0) {
        interactiveBootCompressionLevel = interactiveBootCompressionLevel0;
    }



//========================================
//===== File: ./src/pke/include/scheme/gen-cryptocontext-params-defaults.h =====
//========================================

namespace lbcrypto {

namespace CKKSRNS_SCHEME_DEFAULTS {
constexpr SCHEME scheme               = CKKSRNS_SCHEME;
constexpr PlaintextModulus ptModulus  = 0;
constexpr uint32_t digitSize          = 0;

namespace BFVRNS_SCHEME_DEFAULTS {
constexpr SCHEME scheme                = BFVRNS_SCHEME;
constexpr PlaintextModulus ptModulus   = 0;
constexpr uint32_t digitSize           = 0;

namespace BGVRNS_SCHEME_DEFAULTS {
constexpr SCHEME scheme                                     = BGVRNS_SCHEME;
constexpr PlaintextModulus ptModulus                        = 0;
constexpr uint32_t digitSize                                = 0;


//========================================
//===== File: ./src/pke/include/scheme/gen-cryptocontext-params-validation.h =====
//========================================

namespace lbcrypto {
/**
 * @brief Validate parameters for generating cryptocontext. Doesn't validate the parameters which set functions
 *        are disabled as they cannot be set by users


//========================================
//===== File: ./src/pke/include/scheme/scheme-id.h =====
//========================================

namespace lbcrypto {

//====================================================================================================================
enum SCHEME {
    INVALID_SCHEME = 0,
    CKKSRNS_SCHEME,
    BFVRNS_SCHEME,


//========================================
//===== File: ./src/pke/include/scheme/scheme-swch-params.h =====
//========================================

namespace lbcrypto {

class SchSwchParams {
    // security level for CKKS cryptocontext
    SecurityLevel securityLevelCKKS{HEStd_128_classic};
    // security level for FHEW cryptocontext

public:
    friend std::ostream& operator<<(std::ostream& s, const SchSwchParams& obj);
    //=================================================================================================================
    void SetSecurityLevelCKKS(SecurityLevel securityLevelCKKS0) {


//========================================
//===== File: ./src/pke/include/scheme/scheme-utils.h =====
//========================================


//========================================
//===== File: ./src/pke/include/schemebase/base-advancedshe.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract base class for derived HE algorithms
 */
template <class Element>
class AdvancedSHEBase {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

public:
    virtual ~AdvancedSHEBase() {}

    /**
   * Virtual function for evaluating addition of a list of ciphertexts.
   */
    virtual Ciphertext<Element> EvalAddMany(const std::vector<Ciphertext<Element>>& ciphertextVec) const;

    /**
   * Virtual function for evaluating addition of a list of ciphertexts.
   */
    virtual Ciphertext<Element> EvalAddManyInPlace(std::vector<Ciphertext<Element>>& ciphertextVec) const;

    /**
   * Virtual function for evaluating multiplication of a ciphertext list which
   */
    virtual Ciphertext<Element> EvalMultMany(const std::vector<Ciphertext<Element>>& ciphertextVec,
                                             const std::vector<EvalKey<Element>>& evalKeyVec) const;

    //------------------------------------------------------------------------------
   */
    virtual Ciphertext<Element> EvalLinearWSum(std::vector<ConstCiphertext<Element>>& ciphertextVec,
                                               const std::vector<double>& weights) const {
        std::string errMsg = "EvalLinearWSum is not implemented for this scheme.";
        OPENFHE_THROW(errMsg);
   */
    virtual Ciphertext<Element> EvalLinearWSumMutable(std::vector<Ciphertext<Element>>& ciphertextVec,
                                                      const std::vector<double>& weights) const {
        std::string errMsg = "EvalLinearWSumMutable is not implemented for this scheme.";
        OPENFHE_THROW(errMsg);
   */
    virtual Ciphertext<Element> EvalPoly(ConstCiphertext<Element> ciphertext,
                                         const std::vector<double>& coefficients) const {
        OPENFHE_THROW("EvalPoly is not supported for the scheme.");
    }
   */
    virtual Ciphertext<Element> EvalPolyLinear(ConstCiphertext<Element> ciphertext,
                                               const std::vector<double>& coefficients) const {
        OPENFHE_THROW("EvalPolyLinear is not supported for the scheme.");
    }

    virtual Ciphertext<Element> EvalPolyPS(ConstCiphertext<Element> x, const std::vector<double>& coefficients) const {
        OPENFHE_THROW("EvalPolyPS is not supported for the scheme.");
    }

   */
    virtual Ciphertext<Element> EvalChebyshevSeries(ConstCiphertext<Element> ciphertext,
                                                    const std::vector<double>& coefficients, double a, double b) const {
        OPENFHE_THROW("EvalChebyshevSeries is not supported for the scheme.");
    }

    virtual Ciphertext<Element> EvalChebyshevSeriesLinear(ConstCiphertext<Element> ciphertext,
                                                          const std::vector<double>& coefficients, double a,
                                                          double b) const {
        OPENFHE_THROW("EvalChebyshevSeriesLinear is not supported for the scheme.");

    virtual Ciphertext<Element> EvalChebyshevSeriesPS(ConstCiphertext<Element> ciphertext,
                                                      const std::vector<double>& coefficients, double a,
                                                      double b) const {
        OPENFHE_THROW("EvalChebyshevSeriesPS is not supported for the scheme.");
   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalSumKeyGen(const PrivateKey<Element> privateKey,
                                                                             const PublicKey<Element> publicKey) const;

    /**
   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalSumRowsKeyGen(const PrivateKey<Element> privateKey,
                                                                                 usint rowSize, usint subringDim,
                                                                                 std::vector<usint>& indices) const;

   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalSumColsKeyGen(const PrivateKey<Element> privateKey,
                                                                                 std::vector<usint>& indices) const;

    /**
    */
    virtual Ciphertext<Element> EvalSum(ConstCiphertext<Element> ciphertext, usint batchSize,
                                        const std::map<usint, EvalKey<Element>>& evalSumKeyMap) const;

    /**
    */
    virtual Ciphertext<Element> EvalSumRows(ConstCiphertext<Element> ciphertext, uint32_t numRows,
                                            const std::map<uint32_t, EvalKey<Element>>& evalSumKeys,
                                            uint32_t subringDim) const;

    */
    virtual Ciphertext<Element> EvalSumCols(ConstCiphertext<Element> ciphertext, uint32_t numCols,
                                            const std::map<uint32_t, EvalKey<Element>>& evalSumKeys,
                                            const std::map<uint32_t, EvalKey<Element>>& rightEvalKeys) const;

    */
    virtual Ciphertext<Element> EvalInnerProduct(ConstCiphertext<Element> ciphertext1,
                                                 ConstCiphertext<Element> ciphertext2, usint batchSize,
                                                 const std::map<usint, EvalKey<Element>>& evalKeyMap,
                                                 const EvalKey<Element> evalMultKey) const;
    */
    virtual Ciphertext<Element> EvalInnerProduct(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext,
                                                 usint batchSize,
                                                 const std::map<usint, EvalKey<Element>>& evalKeyMap) const;

   */
    virtual Ciphertext<Element> AddRandomNoise(ConstCiphertext<Element> ciphertext) const;

    /**
   * Merges multiple ciphertexts with encrypted results in slot 0 into a
   */
    virtual Ciphertext<Element> EvalMerge(const std::vector<Ciphertext<Element>>& ciphertextVector,
                                          const std::map<usint, EvalKey<Element>>& evalKeyMap) const;

    //------------------------------------------------------------------------------

protected:
    std::set<uint32_t> GenerateIndices_2n(usint batchSize, usint m) const;

    std::set<uint32_t> GenerateIndices2nComplex(usint batchSize, usint m) const;


//========================================
//===== File: ./src/pke/include/schemebase/base-cryptoparameters.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief main implementation class to capture essential cryptoparameters of
 */
template <typename Element>
class CryptoParametersBase : public Serializable {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

public:
    CryptoParametersBase() {}

    virtual ~CryptoParametersBase() {}

    /**
   * Returns the value of plaintext modulus p
   */
    virtual const PlaintextModulus& GetPlaintextModulus() const {
        return m_encodingParams->GetPlaintextModulus();
    }

   */
    virtual const std::shared_ptr<typename Element::Params> GetElementParams() const {
        return m_params;
    }

    virtual const std::shared_ptr<typename Element::Params> GetParamsPK() const = 0;

    /**
   * Returns the reference to encoding params
   */
    virtual const EncodingParams GetEncodingParams() const {
        return m_encodingParams;
    }

   */
    virtual void SetPlaintextModulus(const PlaintextModulus& plaintextModulus) {
        m_encodingParams->SetPlaintextModulus(plaintextModulus);
    }

    virtual bool operator==(const CryptoParametersBase<Element>& cmp) const {
        return *m_encodingParams == *(cmp.GetEncodingParams()) && *m_params == *(cmp.GetElementParams());
    }
    virtual bool operator!=(const CryptoParametersBase<Element>& cmp) const {
        return !(*this == cmp);
    }


    virtual usint GetDigitSize() const {
        return 0;
    }

   */
    virtual uint32_t GetMaxRelinSkDeg() const {
        return 0;
    }

   */
    virtual void SetElementParams(std::shared_ptr<typename Element::Params> params) {
        m_params = params;
    }

   */
    virtual void SetEncodingParams(EncodingParams encodingParams) {
        m_encodingParams = encodingParams;
    }


    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::make_nvp("elp", m_params));
        ar(::cereal::make_nvp("enp", m_encodingParams));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }

protected:
    explicit CryptoParametersBase(const PlaintextModulus& plaintextModulus) {
        m_encodingParams = std::make_shared<EncodingParamsImpl>(plaintextModulus);
    }


    virtual void PrintParameters(std::ostream& out) const {
        out << "Element Parameters: " << *m_params << std::endl;
        out << "Encoding Parameters: " << *m_encodingParams << std::endl;
    }

protected:
    // element-specific parameters
    std::shared_ptr<typename Element::Params> m_params;



//========================================
//===== File: ./src/pke/include/schemebase/base-fhe.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface class for LBC PRE algorithms
 */
template <class Element>
class FHEBase {
public:
    virtual ~FHEBase() {}

    /**
   * Bootstrap functionality:
   */
    virtual void EvalBootstrapSetup(const CryptoContextImpl<Element>& cc, std::vector<uint32_t> levelBudget,
                                    std::vector<uint32_t> dim1, uint32_t slots, uint32_t correctionFactor,
                                    bool precompute) {
        OPENFHE_THROW("Not supported");
   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalBootstrapKeyGen(const PrivateKey<Element> privateKey,
                                                                                   uint32_t slots) {
        OPENFHE_THROW("Not supported");
    }
   */
    virtual void EvalBootstrapPrecompute(const CryptoContextImpl<Element>& cc, uint32_t slots) {
        OPENFHE_THROW("Not supported");
    }

   */
    virtual Ciphertext<Element> EvalBootstrap(ConstCiphertext<Element> ciphertext, uint32_t numIterations,
                                              uint32_t precision) const {
        OPENFHE_THROW("EvalBootstrap is not implemented for this scheme");
    }
   */
    virtual Ciphertext<Element> EvalStC(ConstCiphertext<Element> ciphertext) const {
        OPENFHE_THROW("EvalStC is not implemented for this scheme");
    }

   */
    virtual Ciphertext<Element> EvalCtS(ConstCiphertext<Element> ciphertext) const {
        OPENFHE_THROW("EvalCtS is not implemented for this scheme");
    }

   */
    virtual LWEPrivateKey EvalCKKStoFHEWSetup(const SchSwchParams& params) {
        OPENFHE_THROW("EvalCKKStoFHEWSetup is not supported for this scheme");
    }

   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalCKKStoFHEWKeyGen(const KeyPair<Element>& keyPair,
                                                                                    ConstLWEPrivateKey& lwesk) {
        OPENFHE_THROW("EvalCKKStoFHEWKeyGen is not supported for this scheme");
    }
   */
    virtual void EvalCKKStoFHEWPrecompute(const CryptoContextImpl<Element>& cc, double scale) {
        OPENFHE_THROW("EvalCKKStoFHEWPrecompute is not supported for this scheme");
    }

   */
    virtual std::vector<std::shared_ptr<LWECiphertextImpl>> EvalCKKStoFHEW(ConstCiphertext<Element> ciphertext,
                                                                           uint32_t numCtxts) {
        OPENFHE_THROW("EvalCKKStoFHEW is not implemented for this scheme");
    }
   */
    virtual void EvalFHEWtoCKKSSetup(const CryptoContextImpl<Element>& ccCKKS,
                                     const std::shared_ptr<BinFHEContext>& ccLWE, uint32_t numSlotsCKKS,
                                     uint32_t logQ) {
        OPENFHE_THROW("EvalFHEWtoCKKSSetup is not supported for this scheme");
   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalFHEWtoCKKSKeyGen(const KeyPair<Element>& keyPair,
                                                                                    ConstLWEPrivateKey& lwesk,
                                                                                    uint32_t numSlots = 0,
                                                                                    uint32_t numCtxts = 0,
   */
    virtual void EvalCompareSwitchPrecompute(const CryptoContextImpl<Element>& ccCKKS, uint32_t pLWE, double scaleSign,
                                             bool unit) {
        OPENFHE_THROW(not_implemented_error, "EvalCompareSwitchPrecompute is not supported for this scheme");
    }
   */
    virtual Ciphertext<Element> EvalFHEWtoCKKS(std::vector<std::shared_ptr<LWECiphertextImpl>>& LWECiphertexts,
                                               uint32_t numCtxts, uint32_t numSlots, uint32_t p, double pmin,
                                               double pmax, uint32_t dim1) const {
        OPENFHE_THROW("EvalFHEWtoCKKS is not implemented for this scheme");
   */
    virtual LWEPrivateKey EvalSchemeSwitchingSetup(const SchSwchParams& params) {
        OPENFHE_THROW("EvalSchemeSwitchingSetup is not supported for this scheme");
    }

   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalSchemeSwitchingKeyGen(
        const KeyPair<Element>& keyPair, ConstLWEPrivateKey& lwesk) {
        OPENFHE_THROW("EvalSchemeSwitchingKeyGen is not supported for this scheme");
    }
   */
    virtual Ciphertext<Element> EvalCompareSchemeSwitching(ConstCiphertext<Element> ciphertext1,
                                                           ConstCiphertext<Element> ciphertext2, uint32_t numCtxts,
                                                           uint32_t numSlots, uint32_t pLWE, double scaleSign,
                                                           bool unit) {
   */
    virtual std::vector<Ciphertext<Element>> EvalMinSchemeSwitching(ConstCiphertext<Element> ciphertext,
                                                                    PublicKey<Element> publicKey, uint32_t numValues,
                                                                    uint32_t numSlots, uint32_t pLWE,
                                                                    double scaleSign) {
    */
    virtual std::vector<Ciphertext<Element>> EvalMinSchemeSwitchingAlt(ConstCiphertext<Element> ciphertext,
                                                                       PublicKey<Element> publicKey, uint32_t numValues,
                                                                       uint32_t numSlots, uint32_t pLWE,
                                                                       double scaleSign) {
   */
    virtual std::vector<Ciphertext<Element>> EvalMaxSchemeSwitching(ConstCiphertext<Element> ciphertext,
                                                                    PublicKey<Element> publicKey, uint32_t numValues,
                                                                    uint32_t numSlots, uint32_t pLWE,
                                                                    double scaleSign) {
    */
    virtual std::vector<Ciphertext<Element>> EvalMaxSchemeSwitchingAlt(ConstCiphertext<Element> ciphertext,
                                                                       PublicKey<Element> publicKey, uint32_t numValues,
                                                                       uint32_t numSlots, uint32_t pLWE,
                                                                       double scaleSign) {
    */
    virtual std::shared_ptr<lbcrypto::BinFHEContext> GetBinCCForSchemeSwitch() {
        OPENFHE_THROW("GetBinCCForSchemeSwitch is not supported for this scheme");
    }
    virtual void SetBinCCForSchemeSwitch(std::shared_ptr<lbcrypto::BinFHEContext> ccLWE) {
        OPENFHE_THROW("SetBinCCForSchemeSwitch is not supported for this scheme");
    }

    */
    virtual Ciphertext<Element> GetSwkFC() {
        OPENFHE_THROW("GetSwkFC is not supported for this scheme");
    }
    virtual void SetSwkFC(Ciphertext<Element> FHEWtoCKKSswk) {
        OPENFHE_THROW("SetSwkFC is not supported for this scheme");
    }


    template <class Archive>
    void save(Archive& ar) const {}

    template <class Archive>
    void load(Archive& ar) {}
};



//========================================
//===== File: ./src/pke/include/schemebase/base-leveledshe.h =====
//========================================
 */
namespace lbcrypto {
/**
 * @brief Abstract interface class for LBC SHE algorithms
 * @tparam Element a ring element.
 */
template <class Element>
class LeveledSHEBase {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

public:
    virtual ~LeveledSHEBase() {}

    /////////////////////////////////////////
    // SHE NEGATION
   */
    virtual Ciphertext<Element> EvalNegate(ConstCiphertext<Element> ciphertext) const;

    /**
   * Virtual function to define the interface for homomorphic negation of
   */
    virtual void EvalNegateInPlace(Ciphertext<Element>& ciphertext) const;

    /////////////////////////////////////////
    // SHE ADDITION
   */
    virtual Ciphertext<Element> EvalAdd(ConstCiphertext<Element> ciphertext1,
                                        ConstCiphertext<Element> ciphertext2) const;

    /**
   */
    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext1, ConstCiphertext<Element> ciphertext2) const;

    /**
   * Virtual function to define the interface for homomorphic addition of
   */
    virtual Ciphertext<Element> EvalAddMutable(Ciphertext<Element>& ciphertext1,
                                               Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("EvalAddMutable is not implemented for this scheme");
    }

    virtual void EvalAddMutableInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("EvalAddMutable is not implemented for this scheme");
    }

   */
    virtual Ciphertext<Element> EvalAdd(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext) const;

    /**
   * Virtual function to define the interface for homomorphic addition of
   */
    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext, ConstPlaintext plaintext) const;

    /**
   * Virtual function to define the interface for homomorphic addition of
   */
    virtual Ciphertext<Element> EvalAddMutable(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        OPENFHE_THROW("EvalAddMutable is not implemented for this scheme");
    }

   */
    virtual void EvalAddMutableInPlace(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        OPENFHE_THROW("EvalAddMutable is not implemented for this scheme");
    }

    virtual Ciphertext<Element> EvalAdd(ConstCiphertext<Element> ciphertext, const NativeInteger& constant) const {
        OPENFHE_THROW("integer scalar addition is not implemented for this scheme");
    }

    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext, const NativeInteger& constant) const {
        OPENFHE_THROW("integer scalar addition is not implemented for this scheme");
    }

    virtual Ciphertext<Element> EvalAdd(ConstCiphertext<Element> ciphertext, double constant) const {
        OPENFHE_THROW("double scalar addition is not implemented for this scheme");
    }

    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext, double constant) const {
        OPENFHE_THROW("double scalar addition is not implemented for this scheme");
    }

   */
    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext1,
                                        ConstCiphertext<Element> ciphertext2) const;

    /**
   */
    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext1, ConstCiphertext<Element> ciphertext2) const;

    /**
   * Virtual function to define the interface for homomorphic subtraction of
   */
    virtual Ciphertext<Element> EvalSubMutable(Ciphertext<Element>& ciphertext1,
                                               Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("EvalSubMutable is not implemented for this scheme");
    }
   */
    virtual void EvalSubMutableInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("EvalSubMutable is not implemented for this scheme");
    }

   */
    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext) const;

    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext, ConstPlaintext plaintext) const;

    /**
   * Virtual function to define the interface for homomorphic subtraction of
   */
    virtual Ciphertext<Element> EvalSubMutable(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        OPENFHE_THROW("EvalSubMutable is not implemented for this scheme");
    }

    virtual void EvalSubMutableInPlace(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        OPENFHE_THROW("EvalSubMutable is not implemented for this scheme");
    }

    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext, const NativeInteger& constant) const {
        OPENFHE_THROW("integer scalar subtraction is not implemented for this scheme");
    }

    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext, const NativeInteger& constant) const {
        OPENFHE_THROW("integer scalar subtraction is not implemented for this scheme");
    }

    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext, double constant) const {
        OPENFHE_THROW("double scalar subtraction is not implemented for this scheme");
    }

    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext, double constant) const {
        OPENFHE_THROW("double scalar subtraction is not implemented for this scheme");
    }

   */
    virtual EvalKey<Element> EvalMultKeyGen(const PrivateKey<Element> privateKey) const;

    /**
   * Virtual function to define the interface for generating a evaluation key
   */
    virtual std::vector<EvalKey<Element>> EvalMultKeysGen(const PrivateKey<Element> privateKey) const;

    //------------------------------------------------------------------------------
    // EVAL MULTIPLICATION CIPHERTEXT & CIPHERTEXT
   */
    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext1,
                                         ConstCiphertext<Element> ciphertext2) const {
        OPENFHE_THROW("EvalMult is not implemented for this scheme");
    }
   */
    virtual Ciphertext<Element> EvalMultMutable(Ciphertext<Element>& ciphertext1,
                                                Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("EvalMultMutable is not implemented for this scheme");
    }
   */
    virtual Ciphertext<Element> EvalSquare(ConstCiphertext<Element> ciphertext1) const {
        OPENFHE_THROW("EvalSquare is not implemented for this scheme");
    }

   */
    virtual Ciphertext<Element> EvalSquareMutable(Ciphertext<Element>& ciphertext1) const {
        OPENFHE_THROW("EvalSquareMutable is not implemented for this scheme");
    }

   */
    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext) const;

    virtual void EvalMultInPlace(Ciphertext<Element>& ciphertext, ConstPlaintext plaintext) const;

    /**
   * Virtual function to define the interface（接口） for multiplication of ciphertext
   */
    virtual Ciphertext<Element> EvalMultMutable(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        OPENFHE_THROW("EvalMultMutable C,P is not implemented for this scheme");
    }

   */
    virtual void EvalMultMutableInPlace(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        OPENFHE_THROW("EvalMultMutableInPlace C P is not implemented for this scheme");
    }

    virtual Ciphertext<Element> MultByMonomial(ConstCiphertext<Element> ciphertext, usint power) const {
        OPENFHE_THROW("MultByMonomial is not implemented for this scheme");
    }

    virtual void MultByMonomialInPlace(Ciphertext<Element>& ciphertext, usint power) const {
        OPENFHE_THROW("MultByMonomialInPlace is not implemented for this scheme");
    }

    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext, const NativeInteger& constant) const {
        OPENFHE_THROW("integer scalar multiplication is not implemented for this scheme");
    }

    virtual void EvalMultInPlace(Ciphertext<Element>& ciphertext, const NativeInteger& constant) const {
        OPENFHE_THROW("integer scalar multiplication is not implemented for this scheme");
    }

    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext, double constant) const {
        OPENFHE_THROW("double scalar multiplication is not implemented for this scheme");
    }

    virtual void EvalMultInPlace(Ciphertext<Element>& ciphertext, double constant) const {
        OPENFHE_THROW("double scalar multiplication is not implemented for this scheme");
    }

    virtual Ciphertext<DCRTPoly> MultByInteger(ConstCiphertext<DCRTPoly> ciphertext, uint64_t integer) const {
        OPENFHE_THROW("MultByInteger is not implemented for this scheme");
    }

    virtual void MultByIntegerInPlace(Ciphertext<DCRTPoly>& ciphertext, uint64_t integer) const {
        OPENFHE_THROW("MultByIntegerInPlace is not implemented for this scheme");
    }

   */
    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext1, ConstCiphertext<Element> ciphertext2,
                                         const EvalKey<Element> evalKey) const;

    virtual void EvalMultInPlace(Ciphertext<Element>& ciphertext1, ConstCiphertext<Element> ciphertext2,
                                 const EvalKey<Element> evalKey) const;

    /**
   */
    virtual Ciphertext<Element> EvalMultMutable(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2,
                                                const EvalKey<Element> evalKey) const;

    /**
   */
    virtual void EvalMultMutableInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2,
                                        const EvalKey<Element> evalKey) const;

    virtual Ciphertext<Element> EvalSquare(ConstCiphertext<Element> ciphertext, const EvalKey<Element> evalKey) const;

    virtual void EvalSquareInPlace(Ciphertext<Element>& ciphertext1, const EvalKey<Element> evalKey) const;

    virtual Ciphertext<Element> EvalSquareMutable(Ciphertext<Element>& ciphertext,
                                                  const EvalKey<Element> evalKey) const;
    /**
   * Virtual function to define the interface for multiplicative homomorphic
   */
    virtual Ciphertext<Element> EvalMultAndRelinearize(ConstCiphertext<Element> ciphertext1,
                                                       ConstCiphertext<Element> ciphertext2,
                                                       const std::vector<EvalKey<Element>>& evalKeyVec) const;

   */
    virtual Ciphertext<Element> Relinearize(ConstCiphertext<Element> ciphertext,
                                            const std::vector<EvalKey<Element>>& evalKeyVec) const;

    /**
   */
    virtual void RelinearizeInPlace(Ciphertext<Element>& ciphertext,
                                    const std::vector<EvalKey<Element>>& evalKeyVec) const;

    //------------------------------------------------------------------------------
   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalAutomorphismKeyGen(
        const PrivateKey<Element> privateKey, const std::vector<usint>& indexList) const;

    /**
   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalAutomorphismKeyGen(
        const PublicKey<Element> publicKey, const PrivateKey<Element> privateKey,
        const std::vector<usint>& indexList) const {
        std::string errMsg = "EvalAutomorphismKeyGen is not implemented for this scheme.";
   */
    virtual Ciphertext<Element> EvalAutomorphism(ConstCiphertext<Element> ciphertext, usint i,
                                                 const std::map<usint, EvalKey<Element>>& evalKeyMap,
                                                 CALLER_INFO_ARGS_HDR) const;

   */
    virtual Ciphertext<Element> EvalFastRotation(ConstCiphertext<Element> ciphertext, const usint index, const usint m,
                                                 const std::shared_ptr<std::vector<Element>> digits) const;

    /**
   */
    virtual std::shared_ptr<std::vector<Element>> EvalFastRotationPrecompute(ConstCiphertext<Element> ciphertext) const;

    virtual Ciphertext<Element> EvalFastRotationExt(ConstCiphertext<Element> ciphertext, usint index,
                                                    const std::shared_ptr<std::vector<Element>> expandedCiphertext,
                                                    bool addFirst,
                                                    const std::map<usint, EvalKey<Element>>& evalKeys) const {
   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> EvalAtIndexKeyGen(
        const PublicKey<Element> publicKey, const PrivateKey<Element> privateKey,
        const std::vector<int32_t>& indexList) const;

   */
    virtual Ciphertext<Element> EvalAtIndex(ConstCiphertext<Element> ciphertext, int32_t index,
                                            const std::map<usint, EvalKey<Element>>& evalKeyMap) const;

    virtual usint FindAutomorphismIndex(usint index, usint m) const {
        OPENFHE_THROW("FindAutomorphismIndex is not supported for this scheme");
    }

   */
    virtual Ciphertext<Element> ModReduce(ConstCiphertext<Element> ciphertext, size_t levels) const {
        OPENFHE_THROW("ModReduce is not supported for this scheme");
    }

   */
    virtual void ModReduceInPlace(Ciphertext<Element>& ciphertext, size_t levels) const {
        OPENFHE_THROW("ModReduce is not supported for this scheme");
    }

   */
    virtual Ciphertext<Element> ComposedEvalMult(ConstCiphertext<Element> ciphertext1,
                                                 ConstCiphertext<Element> ciphertext2,
                                                 const EvalKey<Element> evalKey) const;

   */
    virtual Ciphertext<Element> LevelReduce(ConstCiphertext<Element> ciphertext1, const EvalKey<Element> evalKey,
                                            size_t levels) const;

    /**
   */
    virtual void LevelReduceInPlace(Ciphertext<Element>& ciphertext1, const EvalKey<Element> evalKey,
                                    size_t levels) const {
        OPENFHE_THROW("LevelReduceInPlace is not supported for this scheme");
    }

    virtual Ciphertext<Element> Compress(ConstCiphertext<Element> ciphertext, size_t towersLeft) const {
        OPENFHE_THROW("Compress is not supported for this scheme");
    }

   */
    virtual Ciphertext<Element> ModReduceInternal(ConstCiphertext<Element> ciphertext, size_t levels) const {
        OPENFHE_THROW("ModReduce is not supported for this scheme");
    }

   */
    virtual void ModReduceInternalInPlace(Ciphertext<Element>& ciphertext, size_t levels) const {
        OPENFHE_THROW("ModReduce is not supported for this scheme");
    }

   */
    virtual Ciphertext<Element> LevelReduceInternal(ConstCiphertext<Element> ciphertext, size_t levels) const {
        OPENFHE_THROW("LevelReduce is not supported for this scheme");
    }

   */
    virtual void LevelReduceInternalInPlace(Ciphertext<Element>& ciphertext, size_t levels) const {
        OPENFHE_THROW("LevelReduce is not supported for this scheme");
    }

    virtual void AdjustLevelsInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("Leveled Operations are not supported for this scheme");
    }

    virtual void AdjustLevelsAndDepthInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("Mutable Operations are not supported for this scheme");
    }

    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext<Element>& ciphertext1,
                                                  Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("Mutable Operations are not supported for this scheme");
    }
    // TODO (Andrey) : Move these functions to protected or to rns?
    virtual void AdjustForAddOrSubInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("Mutable Operations are not supported for this scheme");
    }

    virtual void AdjustForMultInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        OPENFHE_THROW("Mutable Operations are not supported for this scheme");
    }

    virtual Ciphertext<Element> MorphPlaintext(ConstPlaintext plaintext, ConstCiphertext<Element> ciphertext) const;

protected:
    /////////////////////////////////////////
    // CORE OPERATIONS
    /////////////////////////////////////////
   */
    virtual Ciphertext<Element> EvalAddCore(ConstCiphertext<Element> ciphertext1,
                                            ConstCiphertext<Element> ciphertext2) const;

    /**

    virtual Ciphertext<Element> EvalSubCore(ConstCiphertext<Element> ciphertext1,
                                            ConstCiphertext<Element> ciphertext2) const;

    /**

    virtual Ciphertext<Element> EvalAddCore(ConstCiphertext<Element> ciphertext, const Element& plaintext) const;

    void EvalAddCoreInPlace(Ciphertext<Element>& ciphertext, const Element& plaintext) const;

    virtual Ciphertext<Element> EvalSubCore(ConstCiphertext<Element> ciphertext1, const Element& plaintext) const;

    void EvalSubCoreInPlace(Ciphertext<Element>& ciphertext1, const Element& plaintext) const;



//========================================
//===== File: ./src/pke/include/schemebase/base-multiparty.h =====
//========================================
 */
namespace lbcrypto {
template <class Element>
class KeyPair;
/**
 * @brief Abstract interface class for LBC Multiparty algorithms based on
 * threshold FHE.  A version of this multiparty scheme built on the BGV scheme
 */
template <class Element>
class MultipartyBase {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

public:
    virtual ~MultipartyBase() {}

    /**
   * Threshold FHE: Generates a public key from a vector of secret shares.
   */
    virtual KeyPair<Element> MultipartyKeyGen(CryptoContext<Element> cc,
                                              const std::vector<PrivateKey<Element>>& privateKeyVec, bool makeSparse);

    /**
   */
    virtual KeyPair<Element> MultipartyKeyGen(CryptoContext<Element> cc, const PublicKey<Element> publicKey,
                                              bool makeSparse, bool fresh);

    /**
   */
    virtual EvalKey<Element> MultiKeySwitchGen(const PrivateKey<Element> oldPrivateKey,
                                               const PrivateKey<Element> newPrivateKey,
                                               const EvalKey<Element> evalKey) const;

   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> MultiEvalAutomorphismKeyGen(
        const PrivateKey<Element> privateKey, const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap,
        const std::vector<usint>& indexVec) const;

   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> MultiEvalAtIndexKeyGen(
        const PrivateKey<Element> privateKey, const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap,
        const std::vector<int32_t>& indexVec) const;

   */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> MultiEvalSumKeyGen(
        const PrivateKey<Element> privateKey,
        const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap) const;

   */
    virtual Ciphertext<Element> MultipartyDecryptMain(ConstCiphertext<Element> ciphertext,
                                                      const PrivateKey<Element> privateKey) const;

    /**
   */
    virtual Ciphertext<Element> MultipartyDecryptLead(ConstCiphertext<Element> ciphertext,
                                                      const PrivateKey<Element> privateKey) const;

    /**
   */
    virtual DecryptResult MultipartyDecryptFusion(const std::vector<Ciphertext<Element>>& ciphertextVec,
                                                  NativePoly* plaintext) const;

    /**
   */
    virtual DecryptResult MultipartyDecryptFusion(const std::vector<Ciphertext<Element>>& ciphertextVec,
                                                  Poly* plaintext) const {
        OPENFHE_THROW("Decryption to Poly is not supported");
    }
   */
    virtual PublicKey<Element> MultiAddPubKeys(PublicKey<Element> publicKey1, PublicKey<Element> publicKey2) const;

    /**
   * Threshold FHE: Adds two prior evaluation keys
   */
    virtual EvalKey<Element> MultiAddEvalKeys(EvalKey<Element> evalKey1, EvalKey<Element> evalKey2) const;

    /**
   * Threshold FHE: Adds two partial evaluation keys for multiplication
   */
    virtual EvalKey<Element> MultiAddEvalMultKeys(EvalKey<Element> evalKey1, EvalKey<Element> evalKey2) const;

    /**
    * Threshold FHE: Generates a partial evaluation key for homomorphic
    */
    virtual EvalKey<Element> MultiMultEvalKey(PrivateKey<Element> privateKey, EvalKey<Element> evalKey) const;
    /**
    *
    * Threshold FHE: Adds two prior evaluation key sets for automorphisms
    */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> MultiAddEvalAutomorphismKeys(
        const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap1,
        const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap2) const;

    */
    virtual std::shared_ptr<std::map<usint, EvalKey<Element>>> MultiAddEvalSumKeys(
        const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap1,
        const std::shared_ptr<std::map<usint, EvalKey<Element>>> evalKeyMap2) const;

    */
    virtual Ciphertext<Element> IntMPBootAdjustScale(ConstCiphertext<Element> ciphertext) const;

    /**
    * Threshold FHE: Generate a common random polynomial for Multi-Party Interactive Bootstrapping
    */
    virtual Ciphertext<Element> IntMPBootRandomElementGen(std::shared_ptr<CryptoParametersCKKSRNS> params,
                                                          const PublicKey<Element> publicKey) const;

    /**
    */
    virtual std::vector<Ciphertext<Element>> IntMPBootDecrypt(const PrivateKey<Element> privateKey,
                                                              ConstCiphertext<Element> ciphertext,
                                                              ConstCiphertext<Element> a) const;

    */
    virtual std::vector<Ciphertext<Element>> IntMPBootAdd(
        std::vector<std::vector<Ciphertext<Element>>>& sharesPairVec) const;

    /**
    */
    virtual Ciphertext<Element> IntMPBootEncrypt(const PublicKey<Element> publicKey,
                                                 const std::vector<Ciphertext<Element>>& sharesPair,
                                                 ConstCiphertext<Element> a, ConstCiphertext<Element> ciphertext) const;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/schemebase/base-parametergeneration.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface for parameter generation algorithm
 */
template <class Element>
class ParameterGenerationBase {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

public:
    virtual ~ParameterGenerationBase() {}

    /**
   * Method for computing all derived parameters based on chosen primitive
   */
    virtual bool ParamsGenBFVRNS(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t evalAddCount,
                                 uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrtBits, uint32_t n,
                                 uint32_t numPartQ) const {
        OPENFHE_THROW("This signature for ParamsGen is not supported for this scheme.");
   */
    virtual bool ParamsGenCKKSRNS(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t cyclOrder,
                                  uint32_t numPrimes, uint32_t scalingModSize, uint32_t firstModSize, uint32_t numPartQ,
                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel) const {
        OPENFHE_THROW("This signature for ParamsGen is not supported for this scheme.");
   */
    virtual bool ParamsGenBGVRNS(std::shared_ptr<CryptoParametersBase<DCRTPoly>> cryptoParams, uint32_t evalAddCount,
                                 uint32_t keySwitchCount, uint32_t cyclOrder, uint32_t numPrimes, uint32_t firstModSize,
                                 uint32_t dcrtBits, uint32_t numPartQ, uint32_t PRENumHops) const {
        OPENFHE_THROW("This signature for ParamsGen is not supported for this scheme.");

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/schemebase/base-pke.h =====
//========================================
 */
namespace lbcrypto {
template <class Element>
class KeyPair;

/**
 * @brief Abstract interface for encryption algorithm
 */
template <class Element>
class PKEBase {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

public:
    virtual ~PKEBase() {}

    /**
   * Function to generate public and private keys
   */
    virtual KeyPair<Element> KeyGenInternal(CryptoContext<Element> cc, bool makeSparse) const;

    //  virtual KeyPair<Element> KeyGen(CryptoContext<Element> cc,
    //                                    bool makeSparse,
   */
    virtual Ciphertext<Element> Encrypt(Element plaintext, const PrivateKey<Element> privateKey) const;

    /**
   * Method for encrypting plaintext using LBC
   */
    virtual Ciphertext<Element> Encrypt(Element plaintext, const PublicKey<Element> publicKey) const;

    /**
   * Method for decrypting plaintext using LBC
   */
    virtual DecryptResult Decrypt(ConstCiphertext<Element> ciphertext, const PrivateKey<Element> privateKey,
                                  NativePoly* plaintext) const {
        OPENFHE_THROW("Decryption to NativePoly is not supported");
    }
   */
    virtual DecryptResult Decrypt(ConstCiphertext<Element> ciphertext, const PrivateKey<Element> privateKey,
                                  Poly* plaintext) const {
        OPENFHE_THROW("Decryption to Poly is not supported");
    }

    virtual std::shared_ptr<std::vector<Element> > EncryptZeroCore(const PrivateKey<Element> privateKey,
                                                                   const std::shared_ptr<ParmType> params) const;

    virtual std::shared_ptr<std::vector<Element> > EncryptZeroCore(const PublicKey<Element> publicKey,
                                                                   const std::shared_ptr<ParmType> params) const;

    virtual Element DecryptCore(const std::vector<Element>& cv, const PrivateKey<Element> privateKey) const;
};

}  // namespace lbcrypto


//========================================
//===== File: ./src/pke/include/schemebase/base-pre.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface class for LBC PRE algorithms
 */
template <class Element>
class PREBase {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

public:
    virtual ~PREBase() {}

    /**
   * Virtual function to generate 1..log(q) encryptions for each bit of the
   */
    virtual EvalKey<Element> ReKeyGen(const PrivateKey<Element> oldPrivateKey,
                                      const PublicKey<Element> newPublicKey) const;

    /**
   */
    virtual Ciphertext<Element> ReEncrypt(ConstCiphertext<Element> ciphertext, const EvalKey<Element> evalKey,
                                          const PublicKey<Element> publicKey) const;
};



//========================================
//===== File: ./src/pke/include/schemebase/base-scheme.h =====
//========================================
 */
namespace lbcrypto {

template <typename Element>
class KeyPair;

// TODO: fix DCRTPoly passed by value

 */
template <typename Element>
class SchemeBase {
    using ParmType = typename Element::Params;
    using IntType  = typename Element::Integer;
    using DugType  = typename Element::DugType;

protected:
    inline void CheckMultipartyDecryptCompatibility(ConstCiphertext<Element>& ciphertext, CALLER_INFO_ARGS_HDR) const {
        if (ciphertext->NumberCiphertextElements() > 2) {
            std::string errorMsg(std::string("ciphertext's number of elements is [") +

public:
    SchemeBase() {}

    virtual ~SchemeBase() {}

    virtual bool operator==(const SchemeBase& sch) const {
        OPENFHE_THROW("operator== is not supported");
    }

    virtual bool operator!=(const SchemeBase& sch) const {
        return !(*this == sch);
    }

    // instantiated in the scheme implementation class
    virtual void Enable(PKESchemeFeature feature) {
        OPENFHE_THROW("Enable is not implemented");
    }


    virtual bool ParamsGenBFVRNS(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t evalAddCount,
                                 uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrtBits, uint32_t n,
                                 uint32_t numPartQ) const {
        if (!m_ParamsGen)

    virtual bool ParamsGenCKKSRNS(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t cyclOrder,
                                  uint32_t numPrimes, uint32_t scalingModSize, uint32_t firstModSize, uint32_t numPartQ,
                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel) const {
        if (!m_ParamsGen)

    virtual bool ParamsGenBGVRNS(std::shared_ptr<CryptoParametersBase<DCRTPoly>> cryptoParams, uint32_t evalAddCount,
                                 uint32_t keySwitchCount, uint32_t cyclOrder, uint32_t numPrimes, uint32_t firstModSize,
                                 uint32_t dcrtBits, uint32_t numPartQ, uint32_t PRENumHops) const {
        if (!m_ParamsGen)

    virtual KeyPair<Element> KeyGen(CryptoContext<Element> cc, bool makeSparse) const {
        VerifyPKEEnabled(__func__);
        return m_PKE->KeyGenInternal(cc, makeSparse);
    }

    virtual Ciphertext<Element> Encrypt(const Element& plaintext, const PrivateKey<Element> privateKey) const {
        VerifyPKEEnabled(__func__);
        //      if (!plaintext)
        //        OPENFHE_THROW( "Input plaintext is nullptr");

    virtual Ciphertext<Element> Encrypt(const Element& plaintext, const PublicKey<Element> publicKey) const {
        VerifyPKEEnabled(__func__);
        //      if (!plaintext)
        //        OPENFHE_THROW( "Input plaintext is nullptr");

    virtual DecryptResult Decrypt(ConstCiphertext<Element> ciphertext, const PrivateKey<Element> privateKey,
                                  NativePoly* plaintext) const {
        VerifyPKEEnabled(__func__);
        if (!ciphertext)

    virtual DecryptResult Decrypt(ConstCiphertext<Element> ciphertext, const PrivateKey<Element> privateKey,
                                  Poly* plaintext) const {
        VerifyPKEEnabled(__func__);
        if (!ciphertext)

    virtual EvalKey<Element> KeySwitchGen(const PrivateKey<Element> oldPrivateKey,
                                          const PrivateKey<Element> newPrivateKey) const {
        VerifyKeySwitchEnabled(__func__);
        if (!oldPrivateKey)

    virtual EvalKey<Element> KeySwitchGen(const PrivateKey<Element> oldPrivateKey,
                                          const PrivateKey<Element> newPrivateKey,
                                          const EvalKey<Element> evalKey) const {
        VerifyKeySwitchEnabled(__func__);

    virtual EvalKey<Element> KeySwitchGen(const PrivateKey<Element> oldPrivateKey,
                                          const PublicKey<Element> newPublicKey) const {
        VerifyKeySwitchEnabled(__func__);
        if (!oldPrivateKey)

    virtual Ciphertext<Element> KeySwitch(ConstCiphertext<Element> ciphertext, const EvalKey<Element> evalKey) const {
        VerifyKeySwitchEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void KeySwitchInPlace(Ciphertext<Element>& ciphertext, const EvalKey<Element> evalKey) const {
        VerifyKeySwitchEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> KeySwitchDown(ConstCiphertext<Element> ciphertext) const {
        VerifyKeySwitchEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual std::shared_ptr<std::vector<Element>> EvalKeySwitchPrecomputeCore(
        const Element& c, std::shared_ptr<CryptoParametersBase<Element>> cryptoParamsBase) const {
        VerifyKeySwitchEnabled(__func__);
        return m_KeySwitch->EvalKeySwitchPrecomputeCore(c, cryptoParamsBase);

    virtual std::shared_ptr<std::vector<Element>> EvalFastKeySwitchCoreExt(
        const std::shared_ptr<std::vector<Element>> digits, const EvalKey<Element> evalKey,
        const std::shared_ptr<ParmType> params) const {
        VerifyKeySwitchEnabled(__func__);

    virtual std::shared_ptr<std::vector<Element>> EvalFastKeySwitchCore(
        const std::shared_ptr<std::vector<Element>> digits, const EvalKey<Element> evalKey,
        const std::shared_ptr<ParmType> params) const {
        VerifyKeySwitchEnabled(__func__);

    virtual std::shared_ptr<std::vector<Element>> KeySwitchCore(const Element& a,
                                                                const EvalKey<Element> evalKey) const {
        VerifyKeySwitchEnabled(__func__);
        if (!evalKey)

    virtual EvalKey<Element> ReKeyGen(const PrivateKey<Element> oldPrivateKey,
                                      const PublicKey<Element> newPublicKey) const;

    virtual Ciphertext<Element> ReEncrypt(ConstCiphertext<Element> ciphertext, const EvalKey<Element> evalKey,
                                          const PublicKey<Element> publicKey) const;

    /////////////////////////////////////////

    virtual Ciphertext<Element> EvalNegate(ConstCiphertext<Element> ciphertext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalNegateInPlace(Ciphertext<Element>& ciphertext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalAdd(ConstCiphertext<Element> ciphertext1,
                                        ConstCiphertext<Element> ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext1, ConstCiphertext<Element> ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)
            OPENFHE_THROW("Input first ciphertext is nullptr");

    virtual Ciphertext<Element> EvalAddMutable(Ciphertext<Element>& ciphertext1,
                                               Ciphertext<Element>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual void EvalAddMutableInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)
            OPENFHE_THROW("Input first ciphertext is nullptr");

    virtual Ciphertext<Element> EvalAdd(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext, ConstPlaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalAddMutable(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext, const NativeInteger& constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalAdd(ConstCiphertext<Element> ciphertext, double constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalAddInPlace(Ciphertext<Element>& ciphertext, double constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext1,
                                        ConstCiphertext<Element> ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext1, ConstCiphertext<Element> ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)
            OPENFHE_THROW("Input first ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSubMutable(Ciphertext<Element>& ciphertext1,
                                               Ciphertext<Element>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual void EvalSubMutableInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)
            OPENFHE_THROW("Input first ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext, ConstPlaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSubMutable(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext, const NativeInteger& constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext, const NativeInteger& constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSub(ConstCiphertext<Element> ciphertext, double constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalSubInPlace(Ciphertext<Element>& ciphertext, double constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual EvalKey<Element> EvalMultKeyGen(const PrivateKey<Element> privateKey) const;

    virtual std::vector<EvalKey<Element>> EvalMultKeysGen(const PrivateKey<Element> privateKey) const;

    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext1,
                                         ConstCiphertext<Element> ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual Ciphertext<Element> EvalMultMutable(Ciphertext<Element>& ciphertext1,
                                                Ciphertext<Element>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual Ciphertext<Element> EvalSquare(ConstCiphertext<Element> ciphertext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSquareMutable(Ciphertext<Element>& ciphertext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext1, ConstCiphertext<Element> ciphertext2,
                                         const EvalKey<Element> evalKey) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual void EvalMultInPlace(Ciphertext<Element>& ciphertext1, ConstCiphertext<Element> ciphertext2,
                                 const EvalKey<Element> evalKey) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual Ciphertext<Element> EvalMultMutable(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2,
                                                const EvalKey<Element> evalKey) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual void EvalMultMutableInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2,
                                        const EvalKey<Element> evalKey) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual Ciphertext<Element> EvalSquare(ConstCiphertext<Element> ciphertext, const EvalKey<Element> evalKey) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalSquareInPlace(Ciphertext<Element>& ciphertext, const EvalKey<Element> evalKey) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalSquareMutable(Ciphertext<Element>& ciphertext,
                                                  const EvalKey<Element> evalKey) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)

    virtual Ciphertext<Element> EvalMultAndRelinearize(ConstCiphertext<Element> ciphertext1,
                                                       ConstCiphertext<Element> ciphertext2,
                                                       const std::vector<EvalKey<Element>>& evalKeyVec) const {
        VerifyLeveledSHEEnabled(__func__);

    virtual Ciphertext<Element> Relinearize(ConstCiphertext<Element> ciphertext,
                                            const std::vector<EvalKey<Element>>& evalKeyVec) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)

    virtual void RelinearizeInPlace(Ciphertext<Element>& ciphertext,
                                    const std::vector<EvalKey<Element>>& evalKeyVec) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)

    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalMultInPlace(Ciphertext<Element>& ciphertext, ConstPlaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalMultMutable(Ciphertext<Element>& ciphertext, Plaintext plaintext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> MultByMonomial(ConstCiphertext<Element> ciphertext, uint32_t power) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void MultByMonomialInPlace(Ciphertext<Element>& ciphertext, uint32_t power) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext, double constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void EvalMultInPlace(Ciphertext<Element>& ciphertext, double constant) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<DCRTPoly> MultByInteger(ConstCiphertext<DCRTPoly> ciphertext, uint64_t integer) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void MultByIntegerInPlace(Ciphertext<DCRTPoly>& ciphertext, uint64_t integer) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> EvalAutomorphismKeyGen(
        const PrivateKey<Element> privateKey, const std::vector<uint32_t>& indexList) const;

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> EvalAutomorphismKeyGen(
        const PublicKey<Element> publicKey, const PrivateKey<Element> privateKey,
        const std::vector<uint32_t>& indexList) const;

    virtual Ciphertext<Element> EvalAutomorphism(ConstCiphertext<Element> ciphertext, uint32_t i,
                                                 const std::map<uint32_t, EvalKey<Element>>& evalKeyMap,
                                                 CALLER_INFO_ARGS_HDR) const {
        if (m_LeveledSHE) {

    virtual Ciphertext<Element> EvalFastRotation(ConstCiphertext<Element> ciphertext, const uint32_t index,
                                                 const uint32_t m,
                                                 const std::shared_ptr<std::vector<Element>> digits) const {
        VerifyLeveledSHEEnabled(__func__);

    virtual std::shared_ptr<std::vector<Element>> EvalFastRotationPrecompute(
        ConstCiphertext<Element> ciphertext) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
   */
    virtual Ciphertext<Element> EvalFastRotationExt(ConstCiphertext<Element> ciphertext, uint32_t index,
                                                    const std::shared_ptr<std::vector<Element>> digits, bool addFirst,
                                                    const std::map<uint32_t, EvalKey<Element>>& evalKeys) const {
        VerifyLeveledSHEEnabled(__func__);

    virtual Ciphertext<Element> KeySwitchExt(ConstCiphertext<Element> ciphertext, bool addFirst) const {
        VerifyKeySwitchEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> EvalAtIndexKeyGen(
        const PublicKey<Element> publicKey, const PrivateKey<Element> privateKey,
        const std::vector<int32_t>& indexList) const;

    virtual Ciphertext<Element> EvalAtIndex(ConstCiphertext<Element> ciphertext, uint32_t i,
                                            const std::map<uint32_t, EvalKey<Element>>& evalKeyMap) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)

    virtual uint32_t FindAutomorphismIndex(uint32_t index, uint32_t m) {
        VerifyLeveledSHEEnabled(__func__);
        return m_LeveledSHE->FindAutomorphismIndex(index, m);
    }

    virtual Ciphertext<Element> ComposedEvalMult(ConstCiphertext<Element> ciphertext1,
                                                 ConstCiphertext<Element> ciphertext2,
                                                 const EvalKey<Element> evalKey) const;

    virtual Ciphertext<Element> ModReduce(ConstCiphertext<Element> ciphertext, size_t levels) const;

    virtual void ModReduceInPlace(Ciphertext<Element>& ciphertext, size_t levels) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> ModReduceInternal(ConstCiphertext<Element> ciphertext, size_t levels) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void ModReduceInternalInPlace(Ciphertext<Element>& ciphertext, size_t levels) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> LevelReduce(ConstCiphertext<Element> ciphertext, const EvalKey<Element> evalKey,
                                            size_t levels) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)

    virtual void LevelReduceInPlace(Ciphertext<Element>& ciphertext, const EvalKey<Element> evalKey,
                                    size_t levels) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)

    virtual Ciphertext<Element> LevelReduceInternal(ConstCiphertext<Element> ciphertext, size_t levels) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void LevelReduceInternalInPlace(Ciphertext<Element>& ciphertext, size_t levels) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> Compress(ConstCiphertext<Element> ciphertext, size_t towersLeft) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual void AdjustLevelsInPlace(Ciphertext<DCRTPoly>& ciphertext1, Ciphertext<DCRTPoly>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)
            OPENFHE_THROW("Input ciphertext1 is nullptr");

    virtual void AdjustLevelsAndDepthInPlace(Ciphertext<DCRTPoly>& ciphertext1,
                                             Ciphertext<DCRTPoly>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext<DCRTPoly>& ciphertext1,
                                                  Ciphertext<DCRTPoly>& ciphertext2) const {
        VerifyLeveledSHEEnabled(__func__);
        if (!ciphertext1)

    virtual Ciphertext<Element> EvalAddMany(const std::vector<Ciphertext<Element>>& ciphertextVec) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertextVec.size())
            OPENFHE_THROW("Input ciphertext vector is empty");

    virtual Ciphertext<Element> EvalAddManyInPlace(std::vector<Ciphertext<Element>>& ciphertextVec) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertextVec.size())
            OPENFHE_THROW("Input ciphertext vector is empty");

    virtual Ciphertext<Element> EvalMultMany(const std::vector<Ciphertext<Element>>& ciphertextVec,
                                             const std::vector<EvalKey<Element>>& evalKeyVec) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertextVec.size())

    virtual Ciphertext<Element> EvalLinearWSum(std::vector<ConstCiphertext<Element>>& ciphertextVec,
                                               const std::vector<double>& constantVec) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertextVec.size())

    virtual Ciphertext<Element> EvalLinearWSumMutable(std::vector<Ciphertext<Element>>& ciphertextVec,
                                                      const std::vector<double>& constantVec) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertextVec.size())

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> EvalSumKeyGen(
        const PrivateKey<Element> privateKey, const PublicKey<Element> publicKey) const;

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> EvalSumRowsKeyGen(
        const PrivateKey<Element> privateKey, uint32_t rowSize, uint32_t subringDim,
        std::vector<uint32_t>& indices) const;

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> EvalSumColsKeyGen(
        const PrivateKey<Element> privateKey, std::vector<uint32_t>& indices) const;

    virtual Ciphertext<Element> EvalSum(ConstCiphertext<Element> ciphertext, uint32_t batchSize,
                                        const std::map<uint32_t, EvalKey<Element>>& evalKeyMap) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertext)

    virtual Ciphertext<Element> EvalSumRows(ConstCiphertext<Element> ciphertext, uint32_t rowSize,
                                            const std::map<uint32_t, EvalKey<Element>>& evalKeyMap,
                                            uint32_t subringDim) const {
        VerifyAdvancedSHEEnabled(__func__);

    virtual Ciphertext<Element> EvalSumCols(ConstCiphertext<Element> ciphertext, uint32_t batchSize,
                                            const std::map<uint32_t, EvalKey<Element>>& evalKeyMap,
                                            const std::map<uint32_t, EvalKey<Element>>& rightEvalKeyMap) const {
        VerifyAdvancedSHEEnabled(__func__);

    virtual Ciphertext<Element> EvalInnerProduct(ConstCiphertext<Element> ciphertext1,
                                                 ConstCiphertext<Element> ciphertext2, uint32_t batchSize,
                                                 const std::map<uint32_t, EvalKey<Element>>& evalSumKeyMap,
                                                 const EvalKey<Element> evalMultKey) const;

    virtual Ciphertext<Element> EvalInnerProduct(ConstCiphertext<Element> ciphertext, ConstPlaintext plaintext,
                                                 uint32_t batchSize,
                                                 const std::map<uint32_t, EvalKey<Element>>& evalSumKeyMap) const {
        VerifyAdvancedSHEEnabled(__func__);

    virtual Ciphertext<Element> AddRandomNoise(ConstCiphertext<Element> ciphertext) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertext)
            OPENFHE_THROW("Input ciphertext is nullptr");

    virtual Ciphertext<Element> EvalMerge(const std::vector<Ciphertext<Element>>& ciphertextVec,
                                          const std::map<uint32_t, EvalKey<Element>>& evalKeyMap) const {
        VerifyAdvancedSHEEnabled(__func__);
        if (!ciphertextVec.size())

    virtual KeyPair<Element> MultipartyKeyGen(CryptoContext<Element> cc,
                                              const std::vector<PrivateKey<Element>>& privateKeyVec, bool makeSparse);

    virtual KeyPair<Element> MultipartyKeyGen(CryptoContext<Element> cc, const PublicKey<Element> publicKey,
                                              bool makeSparse, bool PRE);

    virtual Ciphertext<Element> MultipartyDecryptMain(ConstCiphertext<Element> ciphertext,
                                                      const PrivateKey<Element> privateKey) const;

    virtual Ciphertext<Element> MultipartyDecryptLead(ConstCiphertext<Element> ciphertext,
                                                      const PrivateKey<Element> privateKey) const;

    virtual DecryptResult MultipartyDecryptFusion(const std::vector<Ciphertext<Element>>& ciphertextVec,
                                                  NativePoly* plaintext) const {
        VerifyMultipartyEnabled(__func__);
        if (!ciphertextVec.size())

    virtual DecryptResult MultipartyDecryptFusion(const std::vector<Ciphertext<Element>>& ciphertextVec,
                                                  Poly* plaintext) const {
        VerifyMultipartyEnabled(__func__);
        if (!ciphertextVec.size())

    virtual EvalKey<Element> MultiKeySwitchGen(const PrivateKey<Element> oldPrivateKey,
                                               const PrivateKey<Element> newPrivateKey,
                                               const EvalKey<Element> evalKey) const;

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> MultiEvalAutomorphismKeyGen(
        const PrivateKey<Element> privateKey,
        const std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> evalAutoKeyMap,
        const std::vector<uint32_t>& indexList, const std::string& keyId);

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> MultiEvalAtIndexKeyGen(
        const PrivateKey<Element> privateKey,
        const std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> evalAutoKeyMap,
        const std::vector<int32_t>& indexList, const std::string& keyId);

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> MultiEvalSumKeyGen(
        const PrivateKey<Element> privateKey, const std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> evalSumKeyMap,
        const std::string& keyId = "");

    virtual EvalKey<Element> MultiAddEvalKeys(EvalKey<Element> evalKey1, EvalKey<Element> evalKey2,
                                              const std::string& keyId);

    virtual EvalKey<Element> MultiMultEvalKey(PrivateKey<Element> privateKey, EvalKey<Element> evalKey,
                                              const std::string& keyId);

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> MultiAddEvalSumKeys(
        const std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> evalSumKeyMap1,
        const std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> evalSumKeyMap2, const std::string& keyId);

    virtual std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> MultiAddEvalAutomorphismKeys(
        const std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> evalSumKeyMap1,
        const std::shared_ptr<std::map<uint32_t, EvalKey<Element>>> evalSumKeyMap2, const std::string& keyId);

    virtual PublicKey<Element> MultiAddPubKeys(PublicKey<Element> publicKey1, PublicKey<Element> publicKey2,
                                               const std::string& keyId);

    virtual EvalKey<Element> MultiAddEvalMultKeys(EvalKey<Element> evalKey1, EvalKey<Element> evalKey2,
                                                  const std::string& keyId);

    virtual Ciphertext<Element> IntMPBootAdjustScale(ConstCiphertext<Element> ciphertext) const {
        if (m_Multiparty) {
            return m_Multiparty->IntMPBootAdjustScale(ciphertext);
        }

    virtual Ciphertext<Element> IntMPBootRandomElementGen(std::shared_ptr<CryptoParametersCKKSRNS> cryptoParameters,
                                                          const PublicKey<Element> publicKey) const {
        if (m_Multiparty) {
            return m_Multiparty->IntMPBootRandomElementGen(cryptoParameters, publicKey);

    virtual std::vector<Ciphertext<Element>> IntMPBootDecrypt(const PrivateKey<Element> privateKey,
                                                              ConstCiphertext<Element> ciphertext,
                                                              ConstCiphertext<Element> a) const {
        if (m_Multiparty) {

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        // TODO (dsuponit): should we serialize all feature pointers???
        // if (IsFeatureEnabled()) {

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            OPENFHE_THROW("serialized object version " + std::to_string(version) +

    virtual std::string SerializedObjectName() const {
        return "SchemeBase";
    }

    static uint32_t SerializedVersion() {
        return 1;
    }


protected:
    std::shared_ptr<ParameterGenerationBase<Element>> m_ParamsGen;
    std::shared_ptr<PKEBase<Element>> m_PKE;
    std::shared_ptr<KeySwitchBase<Element>> m_KeySwitch;


//========================================
//===== File: ./src/pke/include/schemebase/base-ser.h =====
//========================================


//========================================
//===== File: ./src/pke/include/schemebase/decrypt-result.h =====
//========================================

namespace lbcrypto {

struct EncryptResult {
    EncryptResult() : isValid(false), numBytesEncrypted(0) {}

    explicit EncryptResult(size_t len) : isValid(true), numBytesEncrypted(len) {}

    bool isValid;  // whether the encryption was successful
    // count of the number of plaintext bytes that were encrypted
 */
struct DecryptResult {
    /**
   * Constructor that initializes all message lengths to 0.
   */
   */
    explicit DecryptResult(size_t len) : isValid(true), messageLength(len), scalingFactorInt(1) {}

    /**
   * Constructor that initializes all message lengths.
   */
    explicit DecryptResult(size_t len, NativeInteger scf) : isValid(true), messageLength(len), scalingFactorInt(scf) {}

    bool isValid;                   /**< whether the decryption was successful */
    usint messageLength;            /**< the length of the decrypted plaintext message */


//========================================
//===== File: ./src/pke/include/schemebase/rlwe-cryptoparameters.h =====
//========================================

namespace lbcrypto {

/**
 * @brief Template for crypto parameters.
 */
template <class Element>
class CryptoParametersRLWE : public CryptoParametersBase<Element> {
public:
    /**
   * Default Constructor
   */
   */
    virtual ~CryptoParametersRLWE() {}

    /**
   * Returns the value of standard deviation r for discrete Gaussian

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(::cereal::base_class<CryptoParametersBase<Element>>(this));
        ar(::cereal::make_nvp("dp", m_distributionParameter));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(::cereal::base_class<CryptoParametersBase<Element>>(this));
        ar(::cereal::make_nvp("dp", m_distributionParameter));

protected:
    // standard deviation in Discrete Gaussian Distribution
    float m_distributionParameter = 0;
    // standard deviation in Discrete Gaussian Distribution with Flooding


//========================================
//===== File: ./src/pke/include/schemerns/rns-advancedshe.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract base class for derived HE algorithms
 */
class AdvancedSHERNS : public AdvancedSHEBase<DCRTPoly> {
public:
    virtual ~AdvancedSHERNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<AdvancedSHEBase<DCRTPoly>>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<AdvancedSHEBase<DCRTPoly>>(this));
    }


//========================================
//===== File: ./src/pke/include/schemerns/rns-cryptoparameters.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief main implementation class to capture essential cryptoparameters of
 */
class CryptoParametersRNS : public CryptoParametersRLWE<DCRTPoly> {
    using ParmType = typename DCRTPoly::Params;

protected:
    CryptoParametersRNS()
        : CryptoParametersRLWE<DCRTPoly>(),
          m_ksTechnique(BV),

    virtual ~CryptoParametersRNS() {}

public:
    /**
   * Computes all tables needed for decryption, homomorphic multiplication and key switching.
   * Even though this is a pure virtual function and must be overriden in all derived classes,
   */
    virtual void PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech, EncryptionTechnique encTech,
                                     MultiplicationTechnique multTech, uint32_t numPartQ, uint32_t auxBits,
                                     uint32_t extraBits) = 0;

    virtual uint64_t FindAuxPrimeStep() const;

    /*
   * Estimates the extra modulus bitsize needed for hybrid key swithing (used for finding the minimum secure ring dimension).
   */
    static std::pair<double, uint32_t> EstimateLogP(uint32_t numPartQ, double firstModulusSize, double dcrtBits,
                                                    double extraModulusSize, uint32_t numPrimes, uint32_t auxBits,
                                                    bool addOne = false);

   */
    static constexpr double EstimateMultipartyFloodingLogQ() {
        return static_cast<double>(NoiseFlooding::MULTIPARTY_MOD_SIZE * NoiseFlooding::NUM_MODULI_MULTIPARTY);
    }

   */
    enum KeySwitchTechnique GetKeySwitchTechnique() const {
        return m_ksTechnique;
    }

   */
    enum ScalingTechnique GetScalingTechnique() const {
        return m_scalTechnique;
    }

   */
    enum EncryptionTechnique GetEncryptionTechnique() const {
        return m_encTechnique;
    }

   */
    enum MultiplicationTechnique GetMultiplicationTechnique() const {
        return m_multTechnique;
    }


protected:
    /////////////////////////////////////
    // PrecomputeCRTTables
    /////////////////////////////////////
    // Stores the technique to use for key switching
    enum KeySwitchTechnique m_ksTechnique;

    enum ScalingTechnique m_scalTechnique;

    enum EncryptionTechnique m_encTechnique;

    enum MultiplicationTechnique m_multTechnique;

    uint32_t m_auxBits = 0;


public:
    /////////////////////////////////////
    // SERIALIZATION
    /////////////////////////////////////

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<CryptoParametersRLWE<DCRTPoly>>(this));
        ar(cereal::make_nvp("ks", m_ksTechnique));

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        if (version > SerializedVersion()) {
            std::string errMsg("serialized object version " + std::to_string(version) +
    }
    static uint32_t SerializedVersion() {
        return 1;
    }
};


//========================================
//===== File: ./src/pke/include/schemerns/rns-fhe.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract base class for derived HE algorithms
 */
class FHERNS : public FHEBase<DCRTPoly> {
public:
    virtual ~FHERNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<FHEBase<DCRTPoly>>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<FHEBase<DCRTPoly>>(this));
    }


//========================================
//===== File: ./src/pke/include/schemerns/rns-leveledshe.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface class for LBC SHE algorithms
 */
class LeveledSHERNS : public LeveledSHEBase<DCRTPoly> {
public:
    virtual ~LeveledSHERNS() {}

    /////////////////////////////////////////
    // SHE NEGATION

protected:
    /////////////////////////////////////
    // RNS Core
    /////////////////////////////////////

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<LeveledSHEBase<DCRTPoly>>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<LeveledSHEBase<DCRTPoly>>(this));
    }


//========================================
//===== File: ./src/pke/include/schemerns/rns-multiparty.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface class for LBC Multiparty algorithms based on
 */
class MultipartyRNS : public MultipartyBase<DCRTPoly> {
    using ParmType = typename DCRTPoly::Params;
    using IntType  = typename DCRTPoly::Integer;
    using DugType  = typename DCRTPoly::DugType;

public:
    virtual ~MultipartyRNS() {}

    Ciphertext<DCRTPoly> MultipartyDecryptMain(ConstCiphertext<DCRTPoly> ciphertext,
                                               const PrivateKey<DCRTPoly> privateKey) const override;

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {


//========================================
//===== File: ./src/pke/include/schemerns/rns-parametergeneration.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface for parameter generation algorithm
 */
class ParameterGenerationRNS : public ParameterGenerationBase<DCRTPoly> {
public:
    virtual ~ParameterGenerationRNS() {}

    /**
   * Method for computing all derived parameters based on chosen primitive

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {}

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {}

    std::string SerializedObjectName() const {

protected:
    enum DCRT_MODULUS {
        DEFAULT_EXTRA_MOD_SIZE = 20,
        MIN_SIZE               = 14,
        MAX_SIZE               = 60,


//========================================
//===== File: ./src/pke/include/schemerns/rns-pke.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface for encryption algorithm
 */
class PKERNS : public PKEBase<DCRTPoly> {
    using ParmType = typename DCRTPoly::Params;
    using IntType  = typename DCRTPoly::Integer;
    using DugType  = typename DCRTPoly::DugType;

public:
    virtual ~PKERNS() {}

    /**
   * Method for encrypting plaintext using LBC

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PKEBase<DCRTPoly>>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PKEBase<DCRTPoly>>(this));
    }


//========================================
//===== File: ./src/pke/include/schemerns/rns-pre.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface class for LBC PRE algorithms
 */
class PRERNS : public PREBase<DCRTPoly> {
    using ParmType = typename DCRTPoly::Params;
    using IntType  = typename DCRTPoly::Integer;
    using DugType  = typename DCRTPoly::DugType;

public:
    virtual ~PRERNS() {}

    /////////////////////////////////////
    // SERIALIZATION

    template <class Archive>
    void save(Archive& ar) const {
        ar(cereal::base_class<PREBase<DCRTPoly>>(this));
    }

    template <class Archive>
    void load(Archive& ar) {
        ar(cereal::base_class<PREBase<DCRTPoly>>(this));
    }


//========================================
//===== File: ./src/pke/include/schemerns/rns-scheme.h =====
//========================================
 */
namespace lbcrypto {

/**
 * @brief Abstract interface class for LBC PRE algorithms
 */
class SchemeRNS : public SchemeBase<DCRTPoly> {
public:
    SchemeRNS() {}

    virtual ~SchemeRNS() {}

    void SetKeySwitchingTechnique(KeySwitchTechnique ksTech) {
        if (ksTech == BV) {

    template <class Archive>
    void save(Archive& ar, std::uint32_t const version) const {
        ar(cereal::base_class<SchemeBase<DCRTPoly>>(this));
    }

    template <class Archive>
    void load(Archive& ar, std::uint32_t const version) {
        ar(cereal::base_class<SchemeBase<DCRTPoly>>(this));
    }


//========================================
//===== File: ./src/pke/include/schemerns/rns-ser.h =====
//========================================


//========================================
//===== File: ./third-party/cereal/include/cereal/access.hpp =====
//========================================

namespace cereal
{
  // ######################################################################
  //! A class that allows cereal to load smart pointers to types that have no default constructor
      @code{.cpp}
      struct MyType
      {
        MyType( int x ); // note: no default ctor
        int myX;
        // Define a serialize or load/save pair as you normally would
        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( myX );
      // Provide a specialization for LoadAndConstruct for your type
      namespace cereal
      {
        template <> struct LoadAndConstruct<MyType>
        {
          // load_and_construct will be passed the archive that you will be loading
          // from as well as a construct object which you can use as if it were the
          // constructor for your type.  cereal will handle all memory management for you.
          template <class Archive>
          static void load_and_construct( Archive & ar, cereal::construct<MyType> & construct )
          {
            int x;
            ar( x );
      // generally Archive will be templated, but it can be specific if desired
      template <class Archive>
      static void load_and_construct( Archive & ar, cereal::construct<MyType> & construct );
      // with an optional last parameter specifying the version: const std::uint32_t version
      @endcode

      @ingroup Access */
  template <class T>
  struct LoadAndConstruct
  { };

  // forward decl for construct
  //! @cond PRIVATE_NEVERDEFINED
  namespace memory_detail{ template <class Ar, class T> struct LoadAndConstructLoadWrapper; }
  namespace boost_variant_detail{ template <class Ar, class T> struct LoadAndConstructLoadWrapper; }
  //! @endcond

  //! Used to construct types with no default constructor
      @code{.cpp}
      struct MyType
      {
        // note the lack of default constructor
        MyType( int xx, int yy );

        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( x, y );

        template <class Archive>
        static void load_and_construct( Archive & ar, cereal::construct<MyType> & construct )
        {
          int x, y;
          ar( x, y );
      */
  template <class T>
  class construct
  {
    public:
      //! Construct and initialize the type T with the given arguments
      /*! This will forward all arguments to the underlying type T,
          calling an appropriate constructor.
          @throw Exception If called more than once */
      template <class ... Args>
      void operator()( Args && ... args );
      // implementation deferred due to reliance on cereal::access


    private:
      template <class Ar, class TT> friend struct ::cereal::memory_detail::LoadAndConstructLoadWrapper;
      template <class Ar, class TT> friend struct ::cereal::boost_variant_detail::LoadAndConstructLoadWrapper;

      construct( T * p ) : itsPtr( p ), itsEnableSharedRestoreFunction( [](){} ), itsValid( false ) {}
      construct( T * p, std::function<void()> enableSharedFunc ) : // g++4.7 ice with default lambda to std func
      @code{.cpp}
      class MyClass
      {
        private:
          friend class cereal::access; // gives access to the private serialize

          template <class Archive>
          void serialize( Archive & ar )
          {
            // some code
      @ingroup Access */
  class access
  {
    public:
      // ####### Standard Serialization ########################################
      template<class Archive, class T> inline
      static auto member_serialize(Archive & ar, T & t) -> decltype(t.CEREAL_SERIALIZE_FUNCTION_NAME(ar))
      { return t.CEREAL_SERIALIZE_FUNCTION_NAME(ar); }

      template<class Archive, class T> inline
      static auto member_save(Archive & ar, T const & t) -> decltype(t.CEREAL_SAVE_FUNCTION_NAME(ar))
      { return t.CEREAL_SAVE_FUNCTION_NAME(ar); }

      template<class Archive, class T> inline
      static auto member_save_non_const(Archive & ar, T & t) -> decltype(t.CEREAL_SAVE_FUNCTION_NAME(ar))
      { return t.CEREAL_SAVE_FUNCTION_NAME(ar); }

      template<class Archive, class T> inline
      static auto member_load(Archive & ar, T & t) -> decltype(t.CEREAL_LOAD_FUNCTION_NAME(ar))
      { return t.CEREAL_LOAD_FUNCTION_NAME(ar); }

      template<class Archive, class T> inline
      static auto member_save_minimal(Archive const & ar, T const & t) -> decltype(t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar))
      { return t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar); }

      template<class Archive, class T> inline
      static auto member_save_minimal_non_const(Archive const & ar, T & t) -> decltype(t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar))
      { return t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar); }

      template<class Archive, class T, class U> inline
      static auto member_load_minimal(Archive const & ar, T & t, U && u) -> decltype(t.CEREAL_LOAD_MINIMAL_FUNCTION_NAME(ar, std::forward<U>(u)))
      { return t.CEREAL_LOAD_MINIMAL_FUNCTION_NAME(ar, std::forward<U>(u)); }

      // ####### Versioned Serialization #######################################
      template<class Archive, class T> inline
      static auto member_serialize(Archive & ar, T & t, const std::uint32_t version ) -> decltype(t.CEREAL_SERIALIZE_FUNCTION_NAME(ar, version))
      { return t.CEREAL_SERIALIZE_FUNCTION_NAME(ar, version); }

      template<class Archive, class T> inline
      static auto member_save(Archive & ar, T const & t, const std::uint32_t version ) -> decltype(t.CEREAL_SAVE_FUNCTION_NAME(ar, version))
      { return t.CEREAL_SAVE_FUNCTION_NAME(ar, version); }

      template<class Archive, class T> inline
      static auto member_save_non_const(Archive & ar, T & t, const std::uint32_t version ) -> decltype(t.CEREAL_SAVE_FUNCTION_NAME(ar, version))
      { return t.CEREAL_SAVE_FUNCTION_NAME(ar, version); }

      template<class Archive, class T> inline
      static auto member_load(Archive & ar, T & t, const std::uint32_t version ) -> decltype(t.CEREAL_LOAD_FUNCTION_NAME(ar, version))
      { return t.CEREAL_LOAD_FUNCTION_NAME(ar, version); }

      template<class Archive, class T> inline
      static auto member_save_minimal(Archive const & ar, T const & t, const std::uint32_t version) -> decltype(t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar, version))
      { return t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar, version); }

      template<class Archive, class T> inline
      static auto member_save_minimal_non_const(Archive const & ar, T & t, const std::uint32_t version) -> decltype(t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar, version))
      { return t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar, version); }

      template<class Archive, class T, class U> inline
      static auto member_load_minimal(Archive const & ar, T & t, U && u, const std::uint32_t version) -> decltype(t.CEREAL_LOAD_MINIMAL_FUNCTION_NAME(ar, std::forward<U>(u), version))
      { return t.CEREAL_LOAD_MINIMAL_FUNCTION_NAME(ar, std::forward<U>(u), version); }

      // ####### Other Functionality ##########################################
      // for detecting inheritance from enable_shared_from_this
      template <class T> inline
      static auto shared_from_this(T & t) -> decltype(t.shared_from_this());

      // for placement new
      template <class T, class ... Args> inline
      static void construct( T *& ptr, Args && ... args )
      {
        new (ptr) T( std::forward<Args>( args )... );
      }
      // for non-placement new with a default constructor
      template <class T> inline
      static T * construct()
      {
        return new T();
      }

      template <class T> inline
      static std::false_type load_and_construct(...)
      { return std::false_type(); }

      template<class T, class Archive> inline
      static auto load_and_construct(Archive & ar, ::cereal::construct<T> & construct) -> decltype(T::load_and_construct(ar, construct))
      {
        T::load_and_construct( ar, construct );
      }

      template<class T, class Archive> inline
      static auto load_and_construct(Archive & ar, ::cereal::construct<T> & construct, const std::uint32_t version) -> decltype(T::load_and_construct(ar, construct, version))
      {
        T::load_and_construct( ar, construct, version );
      }
  // Deferred Implementation, see construct for more information
  template <class T> template <class ... Args> inline
  void construct<T>::operator()( Args && ... args )
  {
    if( itsValid )


//========================================
//===== File: ./third-party/cereal/include/cereal/archives/adapters.hpp =====
//========================================

namespace cereal
{
  #ifdef CEREAL_FUTURE_EXPERIMENTAL

  // Forward declaration for friend access
  template <class U, class A> U & get_user_data( A & );

  //! Wraps an archive and gives access to user data
  /*! This adapter is useful if you require access to
      @code{.cpp}
      struct MyUserData
      {
        int * myRawPointer;
        std::reference_wrapper<MyOtherType> myReference;

      struct MyClass
      {
        // Note the raw pointer parameter
        MyClass( int xx, int * rawP );

        template <class Archive>
        void serialize( Archive & ar )
        { ar( x ); }

        template <class Archive>
        static void load_and_construct( Archive & ar, cereal::construct<MyClass> & construct )
        {
          int xx;
          ar( xx );
      @tparam Archive The archive to wrap */
  template <class UserData, class Archive>
  class UserDataAdapter : public Archive
  {
    public:
      //! Construct the archive with some user data struct
      /*! This will forward all arguments (other than the user
          data) to the wrapped archive type.  The UserDataAdapter
                       the archive. */
      template <class ... Args>
      UserDataAdapter( UserData & ud, Args && ... args ) :
        Archive( std::forward<Args>( args )... ),
        userdata( ud )

    private:
      //! Overload the rtti function to enable dynamic_cast
      void rtti() {}
      friend UserData & get_user_data<UserData>( Archive & ar );
                        UserDataAdapter. */
  template <class UserData, class Archive>
  UserData & get_user_data( Archive & ar )
  {
    try


//========================================
//===== File: ./third-party/cereal/include/cereal/archives/binary.hpp =====
//========================================

namespace cereal
{
  // ######################################################################
  //! An output archive designed to save data in a compact binary representation
      \ingroup Archives */
  class BinaryOutputArchive : public OutputArchive<BinaryOutputArchive, AllowEmptyClassElision>
  {
    public:
      //! Construct, outputting to the provided stream
      /*! @param stream The stream to output to.  Can be a stringstream, a file stream, or
                        even cout! */

    private:
      std::ostream & itsStream;
  };

      \ingroup Archives */
  class BinaryInputArchive : public InputArchive<BinaryInputArchive, AllowEmptyClassElision>
  {
    public:
      //! Construct, loading from the provided stream
      BinaryInputArchive(std::istream & stream) :
        InputArchive<BinaryInputArchive, AllowEmptyClassElision>(this),

    private:
      std::istream & itsStream;
  };

  //! Saving for POD types to binary
  template<class T> inline
  typename std::enable_if<std::is_arithmetic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME(BinaryOutputArchive & ar, T const & t)
  {
  //! Loading for POD types from binary
  template<class T> inline
  typename std::enable_if<std::is_arithmetic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME(BinaryInputArchive & ar, T & t)
  {
  //! Serializing NVP types to binary
  template <class Archive, class T> inline
  CEREAL_ARCHIVE_RESTRICT(BinaryInputArchive, BinaryOutputArchive)
  CEREAL_SERIALIZE_FUNCTION_NAME( Archive & ar, NameValuePair<T> & t )
  {
  //! Serializing SizeTags to binary
  template <class Archive, class T> inline
  CEREAL_ARCHIVE_RESTRICT(BinaryInputArchive, BinaryOutputArchive)
  CEREAL_SERIALIZE_FUNCTION_NAME( Archive & ar, SizeTag<T> & t )
  {
  //! Saving binary data
  template <class T> inline
  void CEREAL_SAVE_FUNCTION_NAME(BinaryOutputArchive & ar, BinaryData<T> const & bd)
  {
    ar.saveBinary( bd.data, static_cast<std::streamsize>( bd.size ) );
  //! Loading binary data
  template <class T> inline
  void CEREAL_LOAD_FUNCTION_NAME(BinaryInputArchive & ar, BinaryData<T> & bd)
  {
    ar.loadBinary(bd.data, static_cast<std::streamsize>( bd.size ) );


//========================================
//===== File: ./third-party/cereal/include/cereal/archives/json.hpp =====
//========================================

namespace cereal
{
  //! An exception thrown when rapidjson fails an internal assertion
  /*! @ingroup Utility */
  struct RapidJSONException : Exception
  { RapidJSONException( const char * what_ ) : Exception( what_ ) {} };
}


namespace cereal
{
  // ######################################################################
  //! An output archive designed to save data to JSON
#ifdef __SIZEOF_INT128__
  namespace int128_support {
      // In order to correctly identify GCC and clang we must either:
      // 1. use "#if defined(__GNUC__) && !defined(__clang__)" (preferred option)
      // 2. or check the condition "#if defined __clang__" first
#endif
  class JSONOutputArchive : public OutputArchive<JSONOutputArchive>, public traits::TextArchive
  {
    enum class NodeType { StartObject, InObject, StartArray, InArray };

    using WriteStream = CEREAL_RAPIDJSON_NAMESPACE::OStreamWrapper;
    using JSONWriter = CEREAL_RAPIDJSON_NAMESPACE::PrettyWriter<WriteStream>;

    public:
      /*! @name Common Functionality
          Common use cases for directly interacting with an JSONOutputArchive */
      //! @{
      //! A class containing various advanced options for the JSON archive
      class Options
      {
        public:
          //! Default options
          static Options Default(){ return Options(); }

          //! Default options with no indentation
          static Options NoIndent(){ return Options( JSONWriter::kDefaultMaxDecimalPlaces, IndentChar::space, 0 ); }

          //! The character to use for indenting
          enum class IndentChar : char
          {
            space = ' ',
            tab = '\t',
                             (0 corresponds to no indentation) */
          explicit Options( int precision = JSONWriter::kDefaultMaxDecimalPlaces,
                            IndentChar indentChar = IndentChar::space,
                            unsigned int indentLength = 4 ) :
            itsPrecision( precision ),

        private:
          friend class JSONOutputArchive;
          int itsPrecision;
          char itsIndentChar;

      template <class T> inline
      typename std::enable_if<!std::is_same<T, int64_t>::value && std::is_same<T, long long>::value, void>::type
      saveValue(T val)     { itsWriter.Int64(val); }
      template <class T> inline
      typename std::enable_if<!std::is_same<T, uint64_t>::value && std::is_same<T, unsigned long long>::value, void>::type
      saveValue(T val)     { itsWriter.Uint64(val); }

    private:
      // Some compilers/OS have difficulty disambiguating the above for various flavors of longs, so we provide
      // special overloads to handle these cases.

      //! 32 bit signed long saving to current node
      template <class T, traits::EnableIf<sizeof(T) == sizeof(std::int32_t),
                                          std::is_signed<T>::value> = traits::sfinae> inline
      void saveLong(T l){ saveValue( static_cast<std::int32_t>( l ) ); }

      //! non 32 bit signed long saving to current node
      template <class T, traits::EnableIf<sizeof(T) != sizeof(std::int32_t),
                                          std::is_signed<T>::value> = traits::sfinae> inline
      void saveLong(T l){ saveValue( static_cast<std::int64_t>( l ) ); }

      //! 32 bit unsigned long saving to current node
      template <class T, traits::EnableIf<sizeof(T) == sizeof(std::int32_t),
                                          std::is_unsigned<T>::value> = traits::sfinae> inline
      void saveLong(T lu){ saveValue( static_cast<std::uint32_t>( lu ) ); }

      //! non 32 bit unsigned long saving to current node
      template <class T, traits::EnableIf<sizeof(T) != sizeof(std::int32_t),
                                          std::is_unsigned<T>::value> = traits::sfinae> inline
      void saveLong(T lu){ saveValue( static_cast<std::uint64_t>( lu ) ); }

    public:
#if defined(_MSC_VER) && _MSC_VER < 1916
      //! MSVC only long overload to current node
      void saveValue( unsigned long lu ){ saveLong( lu ); };
      //! Serialize a long if it would not be caught otherwise
      template <class T, traits::EnableIf<std::is_same<T, long>::value,
                                          !std::is_same<T, int>::value,
                                          !std::is_same<T, std::int64_t>::value> = traits::sfinae> inline
      void saveValue( T t ){ saveLong( t ); }
      //! Serialize an unsigned long if it would not be caught otherwise
      template <class T, traits::EnableIf<std::is_same<T, unsigned long>::value,
                                          !std::is_same<T, unsigned>::value,
                                          !std::is_same<T, std::uint64_t>::value> = traits::sfinae> inline
      void saveValue( T t ){ saveLong( t ); }
      /*! Handles long long (if distinct from other types), unsigned long (if distinct), and long double */
      template <class T, traits::EnableIf<std::is_arithmetic<T>::value,
                                          !std::is_same<T, long>::value,
                                          !std::is_same<T, unsigned long>::value,
                                          !std::is_same<T, std::int64_t>::value,

    private:
      WriteStream itsWriteStream;          //!< Rapidjson write stream
      JSONWriter itsWriter;                //!< Rapidjson writer
      char const * itsNextName;            //!< The next name
      \ingroup Archives */
  class JSONInputArchive : public InputArchive<JSONInputArchive>, public traits::TextArchive
  {
    private:
      using ReadStream = CEREAL_RAPIDJSON_NAMESPACE::IStreamWrapper;
      typedef CEREAL_RAPIDJSON_NAMESPACE::GenericValue<CEREAL_RAPIDJSON_NAMESPACE::UTF8<>> JSONValue;
      typedef JSONValue::ConstMemberIterator MemberIterator;
      typedef JSONValue::ConstValueIterator ValueIterator;
      typedef CEREAL_RAPIDJSON_NAMESPACE::Document::GenericValue GenericValue;

    public:
      /*! @name Common Functionality
          Common use cases for directly interacting with an JSONInputArchive */
      //! @{

    private:
      //! @}
      /*! @name Internal Functionality
          Functionality designed for use by those requiring control over the inner mechanisms of
          rapidJSON supports - one for arrays and one for objects. */
      class Iterator
      {
        public:
          Iterator() : itsIndex( 0 ), itsType(Null_) {}

          Iterator(MemberIterator begin, MemberIterator end) :

        private:
          MemberIterator itsMemberItBegin, itsMemberItEnd; //!< The member iterator (object)
          ValueIterator itsValueItBegin;                   //!< The value iterator (array)
          size_t itsIndex, itsSize;                        //!< The current index of this iterator
          enum Type {Value, Member, Null_} itsType;        //!< Whether this holds values (array) or members (objects) or nothing
      };

      //! Searches for the expectedName node if it doesn't match the actualName

    public:
      //! Starts a new node, going into its proper iterator
      /*! This places an iterator for the next node to be parsed onto the iterator stack.  If the next
          node is an array, this will be a value iterator, otherwise it will be a member iterator.
      //! Loads a value from the current node - small signed overload
      template <class T, traits::EnableIf<std::is_signed<T>::value,
                                          sizeof(T) < sizeof(int64_t)> = traits::sfinae> inline
      void loadValue(T & val)
      {
      //! Loads a value from the current node - small unsigned overload
      template <class T, traits::EnableIf<std::is_unsigned<T>::value,
                                          sizeof(T) < sizeof(uint64_t),
                                          !std::is_same<bool, T>::value> = traits::sfinae> inline
      void loadValue(T & val)

      template <class T> inline
      typename std::enable_if<!std::is_same<T, int64_t>::value && std::is_same<T, long long>::value, void>::type
      loadValue(T & val)     { search(); val = itsIteratorStack.back().value().GetInt64(); ++itsIteratorStack.back(); }
      template <class T> inline
      typename std::enable_if<!std::is_same<T, uint64_t>::value && std::is_same<T, unsigned long long>::value, void>::type
      loadValue(T & val)     { search(); val = itsIteratorStack.back().value().GetUint64(); ++itsIteratorStack.back(); }
      // Special cases to handle various flavors of long, which tend to conflict with
      #ifndef _MSC_VER
    private:
      //! 32 bit signed long loading from current node
      template <class T> inline
      typename std::enable_if<sizeof(T) == sizeof(std::int32_t) && std::is_signed<T>::value, void>::type
      loadLong(T & l){ loadValue( reinterpret_cast<std::int32_t&>( l ) ); }

      //! non 32 bit signed long loading from current node
      template <class T> inline
      typename std::enable_if<sizeof(T) == sizeof(std::int64_t) && std::is_signed<T>::value, void>::type
      loadLong(T & l){ loadValue( reinterpret_cast<std::int64_t&>( l ) ); }

      //! 32 bit unsigned long loading from current node
      template <class T> inline
      typename std::enable_if<sizeof(T) == sizeof(std::uint32_t) && !std::is_signed<T>::value, void>::type
      loadLong(T & lu){ loadValue( reinterpret_cast<std::uint32_t&>( lu ) ); }

      //! non 32 bit unsigned long loading from current node
      template <class T> inline
      typename std::enable_if<sizeof(T) == sizeof(std::uint64_t) && !std::is_signed<T>::value, void>::type
      loadLong(T & lu){ loadValue( reinterpret_cast<std::uint64_t&>( lu ) ); }

    public:
      //! Serialize a long if it would not be caught otherwise
      template <class T> inline
      typename std::enable_if<std::is_same<T, long>::value &&
                              sizeof(T) >= sizeof(std::int64_t) &&
                              !std::is_same<T, std::int64_t>::value, void>::type
      //! Serialize an unsigned long if it would not be caught otherwise
      template <class T> inline
      typename std::enable_if<std::is_same<T, unsigned long>::value &&
                              sizeof(T) >= sizeof(std::uint64_t) &&
                              !std::is_same<T, std::uint64_t>::value, void>::type

    private:
      //! Convert a string to a long long
      void stringToNumber( std::string const & str, long long & val ) { val = std::stoll( str ); }
      //! Convert a string to an unsigned long long

    public:
      //! Loads a value from the current node - long double and long long overloads
      template <class T, traits::EnableIf<std::is_arithmetic<T>::value,
                                          !std::is_same<T, long>::value,
                                          !std::is_same<T, unsigned long>::value,
                                          !std::is_same<T, std::int64_t>::value,
#ifdef __SIZEOF_INT128__
      template<class T, traits::EnableIf<std::is_same<T,int128_support::int128>::value || std::is_same<T,int128_support::uint128>::value> = traits::sfinae>
      inline void loadValue(T & val) {
          std::string sval;
          loadValue( sval );

    private:
      const char * itsNextName;               //!< Next name set by NVP
      ReadStream itsReadStream;               //!< Rapidjson write stream
      std::vector<Iterator> itsIteratorStack; //!< 'Stack' of rapidJSON iterators
  /*! NVPs do not start or finish nodes - they just set up the names */
  template <class T> inline
  void prologue( JSONOutputArchive &, NameValuePair<T> const & )
  { }

  //! Prologue for NVPs for JSON archives
  template <class T> inline
  void prologue( JSONInputArchive &, NameValuePair<T> const & )
  { }

  /*! NVPs do not start or finish nodes - they just set up the names */
  template <class T> inline
  void epilogue( JSONOutputArchive &, NameValuePair<T> const & )
  { }

  /*! NVPs do not start or finish nodes - they just set up the names */
  template <class T> inline
  void epilogue( JSONInputArchive &, NameValuePair<T> const & )
  { }

  /*! Do nothing for the defer wrapper */
  template <class T> inline
  void prologue( JSONOutputArchive &, DeferredData<T> const & )
  { }

  //! Prologue for deferred data for JSON archives
  template <class T> inline
  void prologue( JSONInputArchive &, DeferredData<T> const & )
  { }

  /*! NVPs do not start or finish nodes - they just set up the names */
  template <class T> inline
  void epilogue( JSONOutputArchive &, DeferredData<T> const & )
  { }

  /*! Do nothing for the defer wrapper */
  template <class T> inline
  void epilogue( JSONInputArchive &, DeferredData<T> const & )
  { }

      that the current node should be made into an array */
  template <class T> inline
  void prologue( JSONOutputArchive & ar, SizeTag<T> const & )
  {
    ar.makeArray();
  //! Prologue for SizeTags for JSON archives
  template <class T> inline
  void prologue( JSONInputArchive &, SizeTag<T> const & )
  { }

  /*! SizeTags are strictly ignored for JSON */
  template <class T> inline
  void epilogue( JSONOutputArchive &, SizeTag<T> const & )
  { }

  //! Epilogue for SizeTags for JSON archives
  template <class T> inline
  void epilogue( JSONInputArchive &, SizeTag<T> const & )
  { }

      Minimal types do not start or finish nodes */
  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,
                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, JSONOutputArchive>::value,
                                      !traits::has_minimal_output_serialization<T, JSONOutputArchive>::value> = traits::sfinae>
  inline void prologue( JSONOutputArchive & ar, T const & )
  //! Prologue for all other types for JSON archives
  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,
                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, JSONInputArchive>::value,
                                      !traits::has_minimal_input_serialization<T, JSONInputArchive>::value> = traits::sfinae>
  inline void prologue( JSONInputArchive & ar, T const & )
      Minimal types do not start or finish nodes */
  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,
                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, JSONOutputArchive>::value,
                                      !traits::has_minimal_output_serialization<T, JSONOutputArchive>::value> = traits::sfinae>
  inline void epilogue( JSONOutputArchive & ar, T const & )
  //! Epilogue for all other types other for JSON archives
  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,
                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, JSONInputArchive>::value,
                                      !traits::has_minimal_input_serialization<T, JSONInputArchive>::value> = traits::sfinae>
  inline void epilogue( JSONInputArchive & ar, T const & )
  //! Prologue for arithmetic types for JSON archives
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void prologue( JSONOutputArchive & ar, T const & )
  {
    ar.writeName();
  //! Prologue for arithmetic types for JSON archives
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void prologue( JSONInputArchive &, T const & )
  { }

  //! Epilogue for arithmetic types for JSON archives
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void epilogue( JSONOutputArchive &, T const & )
  { }

  //! Epilogue for arithmetic types for JSON archives
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void epilogue( JSONInputArchive &, T const & )
  { }

  //! Prologue for strings for JSON archives
  template<class CharT, class Traits, class Alloc> inline
  void prologue(JSONOutputArchive & ar, std::basic_string<CharT, Traits, Alloc> const &)
  {
    ar.writeName();
  //! Prologue for strings for JSON archives
  template<class CharT, class Traits, class Alloc> inline
  void prologue(JSONInputArchive &, std::basic_string<CharT, Traits, Alloc> const &)
  { }

  //! Epilogue for strings for JSON archives
  template<class CharT, class Traits, class Alloc> inline
  void epilogue(JSONOutputArchive &, std::basic_string<CharT, Traits, Alloc> const &)
  { }

  //! Epilogue for strings for JSON archives
  template<class CharT, class Traits, class Alloc> inline
  void epilogue(JSONInputArchive &, std::basic_string<CharT, Traits, Alloc> const &)
  { }

  //! Serializing NVP types to JSON
  template <class T> inline
  void CEREAL_SAVE_FUNCTION_NAME( JSONOutputArchive & ar, NameValuePair<T> const & t )
  {
    ar.setNextName( t.name );

  template <class T> inline
  void CEREAL_LOAD_FUNCTION_NAME( JSONInputArchive & ar, NameValuePair<T> & t )
  {
    ar.setNextName( t.name );
  //! Saving for arithmetic to JSON
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void CEREAL_SAVE_FUNCTION_NAME(JSONOutputArchive & ar, T const & t)
  {
    ar.saveValue( t );
  //! Loading arithmetic from JSON
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void CEREAL_LOAD_FUNCTION_NAME(JSONInputArchive & ar, T & t)
  {
    ar.loadValue( t );
  //! saving string to JSON
  template<class CharT, class Traits, class Alloc> inline
  void CEREAL_SAVE_FUNCTION_NAME(JSONOutputArchive & ar, std::basic_string<CharT, Traits, Alloc> const & str)
  {
    ar.saveValue( str );
  //! loading string from JSON
  template<class CharT, class Traits, class Alloc> inline
  void CEREAL_LOAD_FUNCTION_NAME(JSONInputArchive & ar, std::basic_string<CharT, Traits, Alloc> & str)
  {
    ar.loadValue( str );
  //! Saving SizeTags to JSON
  template <class T> inline
  void CEREAL_SAVE_FUNCTION_NAME( JSONOutputArchive &, SizeTag<T> const & )
  {
    // nothing to do here, we don't explicitly save the size
  //! Loading SizeTags from JSON
  template <class T> inline
  void CEREAL_LOAD_FUNCTION_NAME( JSONInputArchive & ar, SizeTag<T> & st )
  {
    ar.loadSize( st.size );


//========================================
//===== File: ./third-party/cereal/include/cereal/archives/portable_binary.hpp =====
//========================================

namespace cereal
{
  namespace portable_binary_detail
  {
    //! Returns true if the current machine is little endian
    /*! @ingroup Internal */
    {
      static std::int32_t test = 1;
      return *reinterpret_cast<std::int8_t*>( &test ) == 1;
    }

        @ingroup Internal */
    template <std::size_t DataSize>
    inline void swap_bytes( std::uint8_t * data )
    {
      for( std::size_t i = 0, end = DataSize / 2; i < end; ++i )
    \ingroup Archives */
  class PortableBinaryOutputArchive : public OutputArchive<PortableBinaryOutputArchive, AllowEmptyClassElision>
  {
    public:
      //! A class containing various advanced options for the PortableBinaryOutput archive
      class Options
      {
        public:
          //! Represents desired endianness
          enum class Endianness : std::uint8_t
          { big, little };

          //! Default options, preserve system endianness
          static Options Default(){ return Options(); }

          //! Save as little endian
          static Options LittleEndian(){ return Options( Endianness::little ); }

          //! Save as big endian
          static Options BigEndian(){ return Options( Endianness::big ); }

          //! Specify specific options for the PortableBinaryOutputArchive
          /*! @param outputEndian The desired endianness of saved (output) data */
          explicit Options( Endianness outputEndian = getEndianness() ) :
            itsOutputEndianness( outputEndian ) { }

        private:
          //! Gets the endianness of the system
          inline static Endianness getEndianness()
          { return portable_binary_detail::is_little_endian() ? Endianness::little : Endianness::big; }
      //! Writes size bytes of data to the output stream
      template <std::streamsize DataSize> inline
      void saveBinary( const void * data, std::streamsize size )
      {
        std::streamsize writtenSize = 0;

    private:
      std::ostream & itsStream;
      const uint8_t itsConvertEndianness; //!< If set to true, we will need to swap bytes upon saving
  };
    \ingroup Archives */
  class PortableBinaryInputArchive : public InputArchive<PortableBinaryInputArchive, AllowEmptyClassElision>
  {
    public:
      //! A class containing various advanced options for the PortableBinaryInput archive
      class Options
      {
        public:
          //! Represents desired endianness
          enum class Endianness : std::uint8_t
          { big, little };

          //! Default options, preserve system endianness
          static Options Default(){ return Options(); }

          //! Load into little endian
          static Options LittleEndian(){ return Options( Endianness::little ); }

          //! Load into big endian
          static Options BigEndian(){ return Options( Endianness::big ); }

          //! Specify specific options for the PortableBinaryInputArchive
          /*! @param inputEndian The desired endianness of loaded (input) data */
          explicit Options( Endianness inputEndian = getEndianness() ) :
            itsInputEndianness( inputEndian ) { }

        private:
          //! Gets the endianness of the system
          inline static Endianness getEndianness()
          { return portable_binary_detail::is_little_endian() ? Endianness::little : Endianness::big; }
          @tparam DataSize T The size of the actual type of the data elements being loaded */
      template <std::streamsize DataSize> inline
      void loadBinary( void * const data, std::streamsize size )
      {
        // load data

    private:
      std::istream & itsStream;
      uint8_t itsConvertEndianness; //!< If set to true, we will need to swap bytes upon loading
  };
  //! Saving for POD types to portable binary
  template<class T> inline
  typename std::enable_if<std::is_arithmetic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME(PortableBinaryOutputArchive & ar, T const & t)
  {
    static_assert( !std::is_floating_point<T>::value ||
                   (std::is_floating_point<T>::value && std::numeric_limits<T>::is_iec559),
                   "Portable binary only supports IEEE 754 standardized floating point" );
    ar.template saveBinary<sizeof(T)>(std::addressof(t), sizeof(t));
  //! Loading for POD types from portable binary
  template<class T> inline
  typename std::enable_if<std::is_arithmetic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME(PortableBinaryInputArchive & ar, T & t)
  {
    static_assert( !std::is_floating_point<T>::value ||
                   (std::is_floating_point<T>::value && std::numeric_limits<T>::is_iec559),
                   "Portable binary only supports IEEE 754 standardized floating point" );
    ar.template loadBinary<sizeof(T)>(std::addressof(t), sizeof(t));
  //! Serializing NVP types to portable binary
  template <class Archive, class T> inline
  CEREAL_ARCHIVE_RESTRICT(PortableBinaryInputArchive, PortableBinaryOutputArchive)
  CEREAL_SERIALIZE_FUNCTION_NAME( Archive & ar, NameValuePair<T> & t )
  {
  //! Serializing SizeTags to portable binary
  template <class Archive, class T> inline
  CEREAL_ARCHIVE_RESTRICT(PortableBinaryInputArchive, PortableBinaryOutputArchive)
  CEREAL_SERIALIZE_FUNCTION_NAME( Archive & ar, SizeTag<T> & t )
  {
  //! Saving binary data to portable binary
  template <class T> inline
  void CEREAL_SAVE_FUNCTION_NAME(PortableBinaryOutputArchive & ar, BinaryData<T> const & bd)
  {
    typedef typename std::remove_pointer<T>::type TT;
    static_assert( !std::is_floating_point<TT>::value ||
                   (std::is_floating_point<TT>::value && std::numeric_limits<TT>::is_iec559),
                   "Portable binary only supports IEEE 754 standardized floating point" );

  //! Loading binary data from portable binary
  template <class T> inline
  void CEREAL_LOAD_FUNCTION_NAME(PortableBinaryInputArchive & ar, BinaryData<T> & bd)
  {
    typedef typename std::remove_pointer<T>::type TT;
    static_assert( !std::is_floating_point<TT>::value ||
                   (std::is_floating_point<TT>::value && std::numeric_limits<TT>::is_iec559),
                   "Portable binary only supports IEEE 754 standardized floating point" );



//========================================
//===== File: ./third-party/cereal/include/cereal/archives/xml.hpp =====
//========================================

namespace cereal
{
  namespace xml_detail
  {
    #ifndef CEREAL_XML_STRING_VALUE
    //! The default name for the root node in a cereal xml archive.
    //! The name given to the root node in a cereal xml archive
    static const char * CEREAL_XML_STRING = CEREAL_XML_STRING_VALUE;

    //! Returns true if the character is whitespace
    inline bool isWhitespace( char c )
      \ingroup Archives */
  class XMLOutputArchive : public OutputArchive<XMLOutputArchive>, public traits::TextArchive
  {
    public:
      /*! @name Common Functionality
          Common use cases for directly interacting with an XMLOutputArchive */
      //! @{
          modifier functions for an interface analogous to named parameters */
      class Options
      {
        public:
          //! Default options
          static Options Default(){ return Options(); }

          //! Specify specific options for the XMLOutputArchive
          /*! @param precision_ The precision used for floating point numbers
              @param sizeAttributes_ Whether dynamically sized containers output the size=dynamic attribute */
          explicit Options( int precision_ = std::numeric_limits<double>::max_digits10,
                            bool indent_ = true,
                            bool outputType_ = false,
                            bool sizeAttributes_ = true ) :

        private:
          friend class XMLOutputArchive;
          int itsPrecision;
          bool itsIndent;
          the parent node */
      template <class T> inline
      void saveValue( T const & value )
      {
        itsOS.clear(); itsOS.seekp( 0, std::ios::beg );
      //! Causes the type to be appended as an attribute to the most recently made node if output type is set to true
      template <class T> inline
      void insertType()
      {
        if( !itsOutputType )

    protected:
      //! A struct that contains metadata about a node
      struct NodeInfo
      {
        NodeInfo( rapidxml::xml_node<> * n = nullptr,
                  const char * nm = nullptr ) :

    private:
      std::ostream & itsStream;        //!< The output stream
      rapidxml::xml_document<> itsXML; //!< The XML document
      std::stack<NodeInfo> itsNodes;   //!< A stack of nodes added to the document
      \ingroup Archives */
  class XMLInputArchive : public InputArchive<XMLInputArchive>, public traits::TextArchive
  {
    public:
      /*! @name Common Functionality
          Common use cases for directly interacting with an XMLInputArchive */
      //! @{
      //! Loads a bool from the current top node
      template <class T, traits::EnableIf<std::is_unsigned<T>::value,
                                          std::is_same<T, bool>::value> = traits::sfinae> inline
      void loadValue( T & value )
      {
      //! Loads a char (signed or unsigned) from the current top node
      template <class T, traits::EnableIf<std::is_integral<T>::value,
                                          !std::is_same<T, bool>::value,
                                          sizeof(T) == sizeof(char)> = traits::sfinae> inline
      void loadValue( T & value )
      //! Loads a type best represented as an unsigned long from the current top node
      template <class T, traits::EnableIf<std::is_unsigned<T>::value,
                                          !std::is_same<T, bool>::value,
                                          !std::is_same<T, char>::value,
                                          !std::is_same<T, unsigned char>::value,
      //! Loads a type best represented as an unsigned long long from the current top node
      template <class T, traits::EnableIf<std::is_unsigned<T>::value,
                                          !std::is_same<T, bool>::value,
                                          sizeof(T) >= sizeof(long long)> = traits::sfinae> inline
      void loadValue( T & value )
      //! Loads a type best represented as an int from the current top node
      template <class T, traits::EnableIf<std::is_signed<T>::value,
                                          !std::is_same<T, char>::value,
                                          sizeof(T) <= sizeof(int)> = traits::sfinae> inline
      void loadValue( T & value )
      //! Loads a type best represented as a long from the current top node
      template <class T, traits::EnableIf<std::is_signed<T>::value,
                                          (sizeof(T) > sizeof(int)),
                                          sizeof(T) <= sizeof(long)> = traits::sfinae> inline
      void loadValue( T & value )
      //! Loads a type best represented as a long long from the current top node
      template <class T, traits::EnableIf<std::is_signed<T>::value,
                                          (sizeof(T) > sizeof(long)),
                                          sizeof(T) <= sizeof(long long)> = traits::sfinae> inline
      void loadValue( T & value )
      //! Loads a string from the current node from the current top node
      template<class CharT, class Traits, class Alloc> inline
      void loadValue( std::basic_string<CharT, Traits, Alloc> & str )
      {
        std::basic_istringstream<CharT, Traits> is( itsNodes.top().node->value() );
      //! Loads the size of the current top node
      template <class T> inline
      void loadSize( T & value )
      {
        value = getNumChildren( itsNodes.top().node );

    protected:
      //! Gets the number of children (usually interpreted as size) for the specified node
      static size_t getNumChildren( rapidxml::xml_node<> * node )
      {
        size_t size = 0;
        node = node->first_node(); // get first child
          remaining children, and the current active child node */
      struct NodeInfo
      {
        NodeInfo( rapidxml::xml_node<> * n = nullptr ) :
          node( n ),

    private:
      std::vector<char> itsData;       //!< The raw data loaded
      rapidxml::xml_document<> itsXML; //!< The XML document
      std::stack<NodeInfo> itsNodes;   //!< A stack of nodes read from the document
  /*! NVPs do not start or finish nodes - they just set up the names */
  template <class T> inline
  void prologue( XMLOutputArchive &, NameValuePair<T> const & )
  { }

  //! Prologue for NVPs for XML input archives
  template <class T> inline
  void prologue( XMLInputArchive &, NameValuePair<T> const & )
  { }

  /*! NVPs do not start or finish nodes - they just set up the names */
  template <class T> inline
  void epilogue( XMLOutputArchive &, NameValuePair<T> const & )
  { }

  //! Epilogue for NVPs for XML input archives
  template <class T> inline
  void epilogue( XMLInputArchive &, NameValuePair<T> const & )
  { }

  /*! Do nothing for the defer wrapper */
  template <class T> inline
  void prologue( XMLOutputArchive &, DeferredData<T> const & )
  { }

  //! Prologue for deferred data for XML archives
  template <class T> inline
  void prologue( XMLInputArchive &, DeferredData<T> const & )
  { }

  /*! NVPs do not start or finish nodes - they just set up the names */
  template <class T> inline
  void epilogue( XMLOutputArchive &, DeferredData<T> const & )
  { }

  /*! Do nothing for the defer wrapper */
  template <class T> inline
  void epilogue( XMLInputArchive &, DeferredData<T> const & )
  { }

  /*! SizeTags do not start or finish nodes */
  template <class T> inline
  void prologue( XMLOutputArchive & ar, SizeTag<T> const & )
  {
      if (ar.hasSizeAttributes())

  template <class T> inline
  void prologue( XMLInputArchive &, SizeTag<T> const & )
  { }

  /*! SizeTags do not start or finish nodes */
  template <class T> inline
  void epilogue( XMLOutputArchive &, SizeTag<T> const & )
  { }

  template <class T> inline
  void epilogue( XMLInputArchive &, SizeTag<T> const & )
  { }

      Minimal types do not start or end nodes */
  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, XMLOutputArchive>::value ||
                                       traits::has_minimal_output_serialization<T, XMLOutputArchive>::value> = traits::sfinae> inline
  void prologue( XMLOutputArchive & ar, T const & )
  {
  //! Prologue for all other types for XML input archives (except minimal types)
  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, XMLInputArchive>::value ||
                                       traits::has_minimal_input_serialization<T, XMLInputArchive>::value> = traits::sfinae> inline
  void prologue( XMLInputArchive & ar, T const & )
  {
      Minimal types do not start or end nodes */
  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, XMLOutputArchive>::value ||
                                       traits::has_minimal_output_serialization<T, XMLOutputArchive>::value> = traits::sfinae> inline
  void epilogue( XMLOutputArchive & ar, T const & )
  {
  //! Epilogue for all other types other for XML output archives (except minimal types)
  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, XMLInputArchive>::value ||
                                       traits::has_minimal_input_serialization<T, XMLInputArchive>::value> = traits::sfinae> inline
  void epilogue( XMLInputArchive & ar, T const & )
  {
  //! Saving NVP types to XML
  template <class T> inline
  void CEREAL_SAVE_FUNCTION_NAME( XMLOutputArchive & ar, NameValuePair<T> const & t )
  {
    ar.setNextName( t.name );
  //! Loading NVP types from XML
  template <class T> inline
  void CEREAL_LOAD_FUNCTION_NAME( XMLInputArchive & ar, NameValuePair<T> & t )
  {
    ar.setNextName( t.name );
  //! Saving SizeTags to XML
  template <class T> inline
  void CEREAL_SAVE_FUNCTION_NAME( XMLOutputArchive &, SizeTag<T> const & )
  { }

  //! Loading SizeTags from XML
  template <class T> inline
  void CEREAL_LOAD_FUNCTION_NAME( XMLInputArchive & ar, SizeTag<T> & st )
  {
    ar.loadSize( st.size );
  //! Saving for POD types to xml
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void CEREAL_SAVE_FUNCTION_NAME(XMLOutputArchive & ar, T const & t)
  {
    ar.saveValue( t );
  //! Loading for POD types from xml
  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline
  void CEREAL_LOAD_FUNCTION_NAME(XMLInputArchive & ar, T & t)
  {
    ar.loadValue( t );
  //! saving string to xml
  template<class CharT, class Traits, class Alloc> inline
  void CEREAL_SAVE_FUNCTION_NAME(XMLOutputArchive & ar, std::basic_string<CharT, Traits, Alloc> const & str)
  {
    ar.saveValue( str );
  //! loading string from xml
  template<class CharT, class Traits, class Alloc> inline
  void CEREAL_LOAD_FUNCTION_NAME(XMLInputArchive & ar, std::basic_string<CharT, Traits, Alloc> & str)
  {
    ar.loadValue( str );


//========================================
//===== File: ./third-party/cereal/include/cereal/cereal.hpp =====
//========================================

namespace cereal
{
  // ######################################################################
  //! Creates a name value pair
      @ingroup Utility */
  template <class T> inline
  NameValuePair<T> make_nvp( std::string const & name, T && value )
  {
    return {name.c_str(), std::forward<T>(value)};
      @ingroup Utility */
  template <class T> inline
  NameValuePair<T> make_nvp( const char * name, T && value )
  {
    return {name, std::forward<T>(value)};
      @ingroup Utility */
  template <class T> inline
  BinaryData<T> binary_data( T && data, size_t size )
  {
    return {std::forward<T>(data), size};
      @ingroup Utility */
  template <class T> inline
  SizeTag<T> make_size_tag( T && sz )
  {
    return {std::forward<T>(sz)};
      @code{.cpp}
      struct MyEdge
      {
        std::shared_ptr<MyNode> connection;
        int some_value;

        template<class Archive>
        void serialize(Archive & archive)
        {
          // when we serialize an edge, we'll defer serializing the associated node

      struct MyGraphStructure
      {
        std::vector<MyEdge> edges;
        std::vector<MyNodes> nodes;

        template<class Archive>
        void serialize(Archive & archive)
        {
          // because of the deferment, we ensure all nodes are fully serialized
      @ingroup Utility */
  template <class T> inline
  DeferredData<T> defer( T && value )
  {
    return {std::forward<T>(value)};
      @ingroup Internal */
  template <class Archive, class T> inline
  void prologue( Archive & /* archive */, T const & /* data */)
  { }

  /*! @ingroup Internal */
  template <class Archive, class T> inline
  void epilogue( Archive & /* archive */, T const & /* data */)
  { }

        empty class with improperly formed serialize or load/save functions, no
        static error will occur - the error will propogate silently and your
        intended serialization functions may not be called.  You can manually
        ensure that your classes that have custom serialization are correct
        by using the traits is_output_serializable and is_input_serializable
      @ingroup Internal */
  enum Flags { AllowEmptyClassElision = 1 };

  // ######################################################################
  //! Registers a specific Archive type with cereal
  #define CEREAL_REGISTER_ARCHIVE(Archive)                              \
  namespace cereal { namespace detail {                                 \
  template <class T, class BindingTag>                                  \
  typename polymorphic_serialization_support<Archive, T>::type          \
  instantiate_polymorphic_binding( T*, Archive*, BindingTag, adl_tag ); \
  } } /* end namespaces */

      template <class Archive>
      void serialize( Archive & ar, Mytype & t, const std::uint32_t version )
      {
        // When performing a load, the version associated with the class
  #define CEREAL_CLASS_VERSION(TYPE, VERSION_NUMBER)                             \
  namespace cereal { namespace detail {                                          \
    template <> struct Version<TYPE>                                             \
    {                                                                            \
      static std::uint32_t registerVersion()                                     \
      {                                                                          \
        ::cereal::detail::StaticObject<Versions>::getInstance().mapping.emplace( \
             std::type_index(typeid(TYPE)).hash_code(), VERSION_NUMBER );        \
      }                                                                          \
      static inline const std::uint32_t version = registerVersion();             \
      CEREAL_UNUSED_FUNCTION                                                     \
    }; /* end Version */                                                         \
  } } // end namespaces
  #define CEREAL_CLASS_VERSION(TYPE, VERSION_NUMBER)                             \
  namespace cereal { namespace detail {                                          \
    template <> struct Version<TYPE>                                             \
    {                                                                            \
      static const std::uint32_t version;                                        \
      static std::uint32_t registerVersion()                                     \
      {                                                                          \
        ::cereal::detail::StaticObject<Versions>::getInstance().mapping.emplace( \
             std::type_index(typeid(TYPE)).hash_code(), VERSION_NUMBER );        \
      @tparam Flags Flags to control advanced functionality.  See the Flags
                    enum for more information.
      @ingroup Internal */
  template<class ArchiveType, std::uint32_t Flags = 0>
  class OutputArchive : public detail::OutputArchiveBase
  {
    public:
      //! Construct the output archive
      /*! @param derived A pointer to the derived ArchiveType (pass this from the derived archive) */
      OutputArchive(ArchiveType * const derived) : self(derived), itsCurrentPointerId(1), itsCurrentPolymorphicTypeId(1)
      /*! This is the primary interface for serializing data with an archive */
      template <class ... Types> inline
      ArchiveType & operator()( Types && ... args )
      {
        self->process( std::forward<Types>( args )... );
          transition to the operator() overload */
      template <class T> inline
      ArchiveType & operator&( T && arg )
      {
        self->process( std::forward<T>( arg ) );
          transition to the operator() overload */
      template <class T> inline
      ArchiveType & operator<<( T && arg )
      {
        self->process( std::forward<T>( arg ) );

    private:
      //! Serializes data after calling prologue, then calls epilogue
      template <class T> inline
      void process( T && head )
      {
        prologue( *self, head );
      //! Unwinds to process all data
      template <class T, class ... Other> inline
      void process( T && head, Other && ... tail )
      {
        self->process( std::forward<T>( head ) );
      /*! \sa virtual_base_class */
      template <class T> inline
      ArchiveType & processImpl(virtual_base_class<T> const & b)
      {
        traits::detail::base_class_id id(b.base_ptr);
      /*! \sa base_class */
      template <class T> inline
      ArchiveType & processImpl(base_class<T> const & b)
      {
        self->processImpl( *b.base_ptr );

      template <class T> inline
      ArchiveType & processImpl(DeferredData<T> const & d)
      {
        std::function<void(void)> deferment( [this, d](){ self->process( d.value ); } );
      //! Member serialization
      template <class T, PROCESS_IF(member_serialize)> inline
      ArchiveType & processImpl(T const & t)
      {
        access::member_serialize(*self, const_cast<T &>(t));
      //! Non member serialization
      template <class T, PROCESS_IF(non_member_serialize)> inline
      ArchiveType & processImpl(T const & t)
      {
        CEREAL_SERIALIZE_FUNCTION_NAME(*self, const_cast<T &>(t));
      //! Member split (save)
      template <class T, PROCESS_IF(member_save)> inline
      ArchiveType & processImpl(T const & t)
      {
        access::member_save(*self, t);
      //! Non member split (save)
      template <class T, PROCESS_IF(non_member_save)> inline
      ArchiveType & processImpl(T const & t)
      {
        CEREAL_SAVE_FUNCTION_NAME(*self, t);
      //! Member split (save_minimal)
      template <class T, PROCESS_IF(member_save_minimal)> inline
      ArchiveType & processImpl(T const & t)
      {
        self->process( access::member_save_minimal(*self, t) );
      //! Non member split (save_minimal)
      template <class T, PROCESS_IF(non_member_save_minimal)> inline
      ArchiveType & processImpl(T const & t)
      {
        self->process( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(*self, t) );
      //! Empty class specialization
      template <class T, traits::EnableIf<(Flags & AllowEmptyClassElision),
                                          !traits::is_output_serializable<T, ArchiveType>::value,
                                          std::is_empty<T>::value> = traits::sfinae> inline
      ArchiveType & processImpl(T const &)
          don't allow empty class ellision or allow it but are not serializing an empty class */
      template <class T, traits::EnableIf<traits::has_invalid_output_versioning<T, ArchiveType>::value ||
                                          (!traits::is_output_serializable<T, ArchiveType>::value &&
                                           (!(Flags & AllowEmptyClassElision) || ((Flags & AllowEmptyClassElision) && !std::is_empty<T>::value)))> = traits::sfinae> inline
      ArchiveType & processImpl(T const &)
      {
        static_assert(traits::detail::count_output_serializers<T, ArchiveType>::value != 0,
            "cereal could not find any output serialization functions for the provided type and archive combination. \n\n "
            "Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \n "
            "Serialize functions generally have the following signature: \n\n "

        static_assert(traits::detail::count_output_serializers<T, ArchiveType>::value < 2,
            "cereal found more than one compatible output serialization function for the provided type and archive combination. \n\n "
            "Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \n "
            "Use specialization (see access.hpp) if you need to disambiguate between serialize vs load/save functions.  \n "
          @tparam T The type of the class being serialized */
      template <class T> inline
      std::uint32_t registerClassVersion()
      {
        static const auto hash = std::type_index(typeid(T)).hash_code();
        const auto insertResult = itsVersionedTypes.insert( hash );
        const auto lock = detail::StaticObject<detail::Versions>::lock();
        const auto version =
      /*! Versioning implementation */
      template <class T, PROCESS_IF(member_versioned_serialize)> inline
      ArchiveType & processImpl(T const & t)
      {
        access::member_serialize(*self, const_cast<T &>(t), registerClassVersion<T>());
      /*! Versioning implementation */
      template <class T, PROCESS_IF(non_member_versioned_serialize)> inline
      ArchiveType & processImpl(T const & t)
      {
        CEREAL_SERIALIZE_FUNCTION_NAME(*self, const_cast<T &>(t), registerClassVersion<T>());
      /*! Versioning implementation */
      template <class T, PROCESS_IF(member_versioned_save)> inline
      ArchiveType & processImpl(T const & t)
      {
        access::member_save(*self, t, registerClassVersion<T>());
      /*! Versioning implementation */
      template <class T, PROCESS_IF(non_member_versioned_save)> inline
      ArchiveType & processImpl(T const & t)
      {
        CEREAL_SAVE_FUNCTION_NAME(*self, t, registerClassVersion<T>());
      /*! Versioning implementation */
      template <class T, PROCESS_IF(member_versioned_save_minimal)> inline
      ArchiveType & processImpl(T const & t)
      {
        self->process( access::member_save_minimal(*self, t, registerClassVersion<T>()) );
      /*! Versioning implementation */
      template <class T, PROCESS_IF(non_member_versioned_save_minimal)> inline
      ArchiveType & processImpl(T const & t)
      {
        self->process( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(*self, t, registerClassVersion<T>()) );

    private:
      ArchiveType * const self;

      //! A set of all base classes that have been serialized
      @tparam Flags Flags to control advanced functionality.  See the Flags
                    enum for more information.
      @ingroup Internal */
  template<class ArchiveType, std::uint32_t Flags = 0>
  class InputArchive : public detail::InputArchiveBase
  {
    public:
      //! Construct the output archive
      /*! @param derived A pointer to the derived ArchiveType (pass this from the derived archive) */
      InputArchive(ArchiveType * const derived) :
      /*! This is the primary interface for serializing data with an archive */
      template <class ... Types> inline
      ArchiveType & operator()( Types && ... args )
      {
        process( std::forward<Types>( args )... );
          transition to the operator() overload */
      template <class T> inline
      ArchiveType & operator&( T && arg )
      {
        self->process( std::forward<T>( arg ) );
          transition to the operator() overload */
      template <class T> inline
      ArchiveType & operator>>( T && arg )
      {
        self->process( std::forward<T>( arg ) );

    private:
      //! Serializes data after calling prologue, then calls epilogue
      template <class T> inline
      void process( T && head )
      {
        prologue( *self, head );
      //! Unwinds to process all data
      template <class T, class ... Other> inline
      void process( T && head, Other && ... tail )
      {
        process( std::forward<T>( head ) );
      /*! \sa virtual_base_class */
      template <class T> inline
      ArchiveType & processImpl(virtual_base_class<T> & b)
      {
        traits::detail::base_class_id id(b.base_ptr);
      /*! \sa base_class */
      template <class T> inline
      ArchiveType & processImpl(base_class<T> & b)
      {
        self->processImpl( *b.base_ptr );

      template <class T> inline
      ArchiveType & processImpl(DeferredData<T> const & d)
      {
        std::function<void(void)> deferment( [this, d](){ self->process( d.value ); } );
      //! Member serialization
      template <class T, PROCESS_IF(member_serialize)> inline
      ArchiveType & processImpl(T & t)
      {
        access::member_serialize(*self, t);
      //! Non member serialization
      template <class T, PROCESS_IF(non_member_serialize)> inline
      ArchiveType & processImpl(T & t)
      {
        CEREAL_SERIALIZE_FUNCTION_NAME(*self, t);
      //! Member split (load)
      template <class T, PROCESS_IF(member_load)> inline
      ArchiveType & processImpl(T & t)
      {
        access::member_load(*self, t);
      //! Non member split (load)
      template <class T, PROCESS_IF(non_member_load)> inline
      ArchiveType & processImpl(T & t)
      {
        CEREAL_LOAD_FUNCTION_NAME(*self, t);
      //! Member split (load_minimal)
      template <class T, PROCESS_IF(member_load_minimal)> inline
      ArchiveType & processImpl(T & t)
      {
        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;
      //! Non member split (load_minimal)
      template <class T, PROCESS_IF(non_member_load_minimal)> inline
      ArchiveType & processImpl(T & t)
      {
        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;
      //! Empty class specialization
      template <class T, traits::EnableIf<(Flags & AllowEmptyClassElision),
                                          !traits::is_input_serializable<T, ArchiveType>::value,
                                          std::is_empty<T>::value> = traits::sfinae> inline
      ArchiveType & processImpl(T const &)
          don't allow empty class ellision or allow it but are not serializing an empty class */
      template <class T, traits::EnableIf<traits::has_invalid_input_versioning<T, ArchiveType>::value ||
                                          (!traits::is_input_serializable<T, ArchiveType>::value &&
                                           (!(Flags & AllowEmptyClassElision) || ((Flags & AllowEmptyClassElision) && !std::is_empty<T>::value)))> = traits::sfinae> inline
      ArchiveType & processImpl(T const &)
      {
        static_assert(traits::detail::count_input_serializers<T, ArchiveType>::value != 0,
            "cereal could not find any input serialization functions for the provided type and archive combination. \n\n "
            "Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \n "
            "Serialize functions generally have the following signature: \n\n "

        static_assert(traits::detail::count_input_serializers<T, ArchiveType>::value < 2,
            "cereal found more than one compatible input serialization function for the provided type and archive combination. \n\n "
            "Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \n "
            "Use specialization (see access.hpp) if you need to disambiguate between serialize vs load/save functions.  \n "
      //! Befriend for versioning in load_and_construct
      template <class A, class B, bool C, bool D, bool E, bool F> friend struct detail::Construct;

      //! Registers a class version with the archive and serializes it if necessary
      /*! If this is the first time this class has been serialized, we will record its
          @tparam T The type of the class being serialized */
      template <class T> inline
      std::uint32_t loadClassVersion()
      {
        static const auto hash = std::type_index(typeid(T)).hash_code();
        auto lookupResult = itsVersionedTypes.find( hash );

        if( lookupResult != itsVersionedTypes.end() ) // already exists
      /*! Versioning implementation */
      template <class T, PROCESS_IF(member_versioned_serialize)> inline
      ArchiveType & processImpl(T & t)
      {
        const auto version = loadClassVersion<T>();
      /*! Versioning implementation */
      template <class T, PROCESS_IF(non_member_versioned_serialize)> inline
      ArchiveType & processImpl(T & t)
      {
        const auto version = loadClassVersion<T>();
      /*! Versioning implementation */
      template <class T, PROCESS_IF(member_versioned_load)> inline
      ArchiveType & processImpl(T & t)
      {
        const auto version = loadClassVersion<T>();
      /*! Versioning implementation */
      template <class T, PROCESS_IF(non_member_versioned_load)> inline
      ArchiveType & processImpl(T & t)
      {
        const auto version = loadClassVersion<T>();
      /*! Versioning implementation */
      template <class T, PROCESS_IF(member_versioned_load_minimal)> inline
      ArchiveType & processImpl(T & t)
      {
        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;
      /*! Versioning implementation */
      template <class T, PROCESS_IF(non_member_versioned_load_minimal)> inline
      ArchiveType & processImpl(T & t)
      {
        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;

    private:
      ArchiveType * const self;

      //! A set of all base classes that have been serialized


//========================================
//===== File: ./third-party/cereal/include/cereal/details/helpers.hpp =====
//========================================

namespace cereal
{
  // ######################################################################
  //! An exception class thrown when things go wrong at runtime
  /*! @ingroup Utility */
  struct Exception : public std::runtime_error
  {
    explicit Exception( const std::string & what_ ) : std::runtime_error(what_) {}
    explicit Exception( const char * what_ ) : std::runtime_error(what_) {}
  };

  // ######################################################################
  // forward decls
  class BinaryOutputArchive;
  class BinaryInputArchive;

  // ######################################################################
  namespace detail
  {
    struct NameValuePairCore {}; //!< Traits struct for NVPs
    struct DeferredDataCore {}; //!< Traits struct for DeferredData
  }

  // ######################################################################
      @code{.cpp}
      struct MyStruct
      {
        int a, b, c, d, e;

        template<class Archive>
        void serialize(Archive & archive)
        {
          archive( CEREAL_NVP(a),
      @code{.cpp}
      struct MyStruct
      {
        int a, b, my_embarrassing_variable_name, d, e;

        template<class Archive>
        void serialize(Archive & archive)
        {
          archive( CEREAL_NVP(a),
      @code{.cpp}
      struct MyStruct
      {
        int a, b;

        template<class Archive>
        void serialize(Archive & archive)
        {
          archive( cereal::make_nvp<Archive>(a),
      support.  Users writing their own serialize functions will normally
      explicitly control whether they want to use NVPs or not.

      @internal */
  template <class T>
  class NameValuePair : detail::NameValuePairCore
  {
    private:
      // If we get passed an array, keep the type as is, otherwise store
      // a reference if we were passed an l value reference, else copy the value
      using Type = typename std::conditional<std::is_array<typename std::remove_reference<T>::type>::value,
      // prevent nested nvps
      static_assert( !std::is_base_of<detail::NameValuePairCore, T>::value,
                     "Cannot pair a name to a NameValuePair" );

      NameValuePair & operator=( NameValuePair const & ) = delete;

    public:
      //! Constructs a new NameValuePair
      /*! @param n The name of the pair
          @param v The value to pair.  Ideally this should be an l-value reference so that
      @internal */
  template<class Archive, class T> inline
  typename
  std::enable_if<std::is_same<Archive, ::cereal::BinaryInputArchive>::value ||
                 std::is_same<Archive, ::cereal::BinaryOutputArchive>::value,
      @internal */
  template<class Archive, class T> inline
  typename
  std::enable_if<!std::is_same<Archive, ::cereal::BinaryInputArchive>::value &&
                 !std::is_same<Archive, ::cereal::BinaryOutputArchive>::value,
      @internal */
  template <class T>
  struct BinaryData
  {
    //! Internally store the pointer as a void *, keeping const if created with
    //! a const pointer
      @internal */
  template <class T>
  class DeferredData : detail::DeferredDataCore
  {
    private:
      // If we get passed an array, keep the type as is, otherwise store
      // a reference if we were passed an l value reference, else copy the value
      using Type = typename std::conditional<std::is_array<typename std::remove_reference<T>::type>::value,
      // prevent nested nvps
      static_assert( !std::is_base_of<detail::DeferredDataCore, T>::value,
                     "Cannot defer DeferredData" );

      DeferredData & operator=( DeferredData const & ) = delete;

    public:
      //! Constructs a new NameValuePair
      /*! @param v The value to defer.  Ideally this should be an l-value reference so that
                   the value can be both loaded and saved to.  If you pass an r-value reference,
  // ######################################################################
  namespace detail
  {
    // base classes for type checking
    /* The rtti virtual function only exists to enable an archive to
       archive adapters for an example of this */
    class OutputArchiveBase
    {
      public:
        OutputArchiveBase() = default;
        OutputArchiveBase( OutputArchiveBase && ) CEREAL_NOEXCEPT {}
        OutputArchiveBase & operator=( OutputArchiveBase && ) CEREAL_NOEXCEPT { return *this; }
        virtual ~OutputArchiveBase() CEREAL_NOEXCEPT = default;

      private:
        virtual void rtti() {}
    };

    class InputArchiveBase
    {
      public:
        InputArchiveBase() = default;
        InputArchiveBase( InputArchiveBase && ) CEREAL_NOEXCEPT {}
        InputArchiveBase & operator=( InputArchiveBase && ) CEREAL_NOEXCEPT { return *this; }
        virtual ~InputArchiveBase() CEREAL_NOEXCEPT = default;

      private:
        virtual void rtti() {}
    };

    // forward decls for polymorphic support
    template <class Archive, class T> struct polymorphic_serialization_support;
    struct adl_tag;

    // used during saving pointers
    static const uint32_t msb_32bit  = 0x80000000;
    static const int32_t msb2_32bit = 0x40000000;
  }

  // ######################################################################
      @internal */
  template <class T>
  class SizeTag
  {
    private:
      // Store a reference if passed an lvalue reference, otherwise
      // make a copy of the data
      using Type = typename std::conditional<std::is_lvalue_reference<T>::value,

    public:
      SizeTag( T && sz ) : size(std::forward<T>(sz)) {}

      Type size;
      @internal */
  template <class Key, class Value>
  struct MapItem
  {
    using KeyType = typename std::conditional<
      std::is_lvalue_reference<Key>::value,
    //! Serialize the MapItem with the NVPs "key" and "value"
    template <class Archive> inline
    void CEREAL_SERIALIZE_FUNCTION_NAME(Archive & archive)
    {
      archive( make_nvp<Archive>("key",   key),
      @relates MapItem */
  template <class KeyType, class ValueType> inline
  MapItem<KeyType, ValueType> make_map_item(KeyType && key, ValueType && value)
  {
    return {std::forward<KeyType>(key), std::forward<ValueType>(value)};

  namespace detail
  {
    //! Tag for Version, which due to its anonymous namespace, becomes a different
    //! type in each translation unit
    /*! This allows CEREAL_CLASS_VERSION to be safely called in a header file */
    namespace{ struct version_binding_tag {}; }

    // ######################################################################
    //! Version information class
        registered */
    template <class T, class BindingTag = version_binding_tag> struct Version
    {
      static const std::uint32_t version = 0;
      // we don't need to explicitly register these types since they
      // always get a version number of 0
    };
    //! Holds all registered version information
    struct Versions
    {
      std::unordered_map<std::size_t, std::uint32_t> mapping;



//========================================
//===== File: ./third-party/cereal/include/cereal/details/polymorphic_impl.hpp =====
//========================================
#define CEREAL_BIND_TO_ARCHIVES(...)                                     \
    namespace cereal {                                                   \
    namespace detail {                                                   \
    template<>                                                           \
    struct init_binding<__VA_ARGS__> {                                   \
        static inline bind_to_archives<__VA_ARGS__> const & b=           \
        ::cereal::detail::StaticObject<                                  \
            bind_to_archives<__VA_ARGS__>                                \
        >::getInstance().bind();                                         \
#define CEREAL_BIND_TO_ARCHIVES(...)                                     \
    namespace cereal {                                                   \
    namespace detail {                                                   \
    template<>                                                           \
    struct init_binding<__VA_ARGS__> {                                   \
        static bind_to_archives<__VA_ARGS__> const& b;                   \
        CEREAL_BIND_TO_ARCHIVES_UNUSED_FUNCTION                          \
    };                                                                   \
    bind_to_archives<__VA_ARGS__> const & init_binding<__VA_ARGS__>::b = \

namespace cereal
{
  /* Polymorphic casting support */
  namespace detail
  {
    //! Base type for polymorphic void casting
    /*! Contains functions for casting between registered base and derived types.
        that cast between registered base and derived types. */
    struct PolymorphicCaster
    {
      PolymorphicCaster() = default;
      PolymorphicCaster( const PolymorphicCaster & ) = default;
      PolymorphicCaster & operator=( PolymorphicCaster && ) CEREAL_NOEXCEPT { return *this; }
      virtual ~PolymorphicCaster() CEREAL_NOEXCEPT = default;

      //! Downcasts to the proper derived type
      virtual void const * downcast( void const * const ptr ) const = 0;
      //! Upcast to proper base type
      virtual void * upcast( void * const ptr ) const = 0;
      //! Upcast to proper base type, shared_ptr version
      virtual std::shared_ptr<void> upcast( std::shared_ptr<void> const & ptr ) const = 0;
    };

    //! Holds registered mappings between base and derived types for casting
        all registered mappings between base and derived types. */
    struct PolymorphicCasters
    {
      //! Maps from a derived type index to a set of chainable casters
      using DerivedCasterMap = std::unordered_map<std::type_index, std::vector<PolymorphicCaster const *>>;
          reference should not be used. */
      static std::pair<bool, std::vector<PolymorphicCaster const *> const &>
      lookup_if_exists( std::type_index const & baseIndex, std::type_index const & derivedIndex )
      {
        // First phase of lookup - match base type index
          The returned PolymorphicCaster is capable of upcasting or downcasting between the two types. */
      template <class F> inline
      static std::vector<PolymorphicCaster const *> const & lookup( std::type_index const & baseIndex, std::type_index const & derivedIndex, F && exceptionFunc )
      {
        // First phase of lookup - match base type index
        auto const & baseMap = StaticObject<PolymorphicCasters>::getInstance().map;
      //! Performs a downcast to the derived type using a registered mapping
      template <class Derived> inline
      static const Derived * downcast( const void * dptr, std::type_info const & baseInfo )
      {
        auto const & mapping = lookup( baseInfo, typeid(Derived), [&](){ UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION(save) } );

          serialization function, where the type is known at compile time */
      template <class Derived> inline
      static void * upcast( Derived * const dptr, std::type_info const & baseInfo )
      {
        auto const & mapping = lookup( baseInfo, typeid(Derived), [&](){ UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION(load) } );

      //! Upcasts for shared pointers
      template <class Derived> inline
      static std::shared_ptr<void> upcast( std::shared_ptr<Derived> const & dptr, std::type_info const & baseInfo )
      {
        auto const & mapping = lookup( baseInfo, typeid(Derived), [&](){ UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION(load) } );

    //! Strongly typed derivation of PolymorphicCaster
    template <class Base, class Derived>
    struct PolymorphicVirtualCaster : PolymorphicCaster
    {
      //! Inserts an entry in the polymorphic casting map for this pairing
      /*! Creates an explicit mapping between Base and Derived in both upwards and
        macro */
    template <class Base, class Derived>
    struct RegisterPolymorphicCaster
    {
      static PolymorphicCaster const * bind( std::true_type /* is_polymorphic<Base> */)
      {
        return &StaticObject<PolymorphicVirtualCaster<Base, Derived>>::getInstance();
      }

      static PolymorphicCaster const * bind( std::false_type /* is_polymorphic<Base> */ )
      { return nullptr; }

      //! Performs registration (binding) between Base and Derived
      /*! If the type is not polymorphic, nothing will happen */
      static PolymorphicCaster const * bind()
      { return bind( typename std::is_polymorphic<Base>::type() ); }
    };
  }
  /* General polymorphism support */
  namespace detail
  {
    //! Binds a compile time type with a user defined string
    template <class T>
    struct binding_name {};

    //! A structure holding a map from type_indices to output serializer functions
    /*! A static object of this map should be created for each registered archive
        shared_ptr, weak_ptr, and unique_ptr. */
    template <class Archive>
    struct OutputBindingMap
    {
      //! A serializer function
      /*! Serializer functions return nothing and take an archive as
          as their final parameter */
      typedef std::function<void(void*, void const *, std::type_info const &)> Serializer;

      //! Struct containing the serializer functions for all pointer types
      struct Serializers
      {
        Serializer shared_ptr, //!< Serializer function for shared/weak pointers
                   unique_ptr; //!< Serializer function for unique pointers
    //! An empty noop deleter
    template<class T> struct EmptyDeleter { void operator()(T *) const {} };

    //! A structure holding a map from type name strings to input serializer functions
    /*! A static object of this map should be created for each registered archive
        shared_ptr, weak_ptr, and unique_ptr. */
    template <class Archive>
    struct InputBindingMap
    {
      //! Shared ptr serializer function
      /*! Serializer functions return nothing and take an archive as
          Internally it will properly be loaded and cast to the correct type. */
      typedef std::function<void(void*, std::shared_ptr<void> &, std::type_info const &)> SharedSerializer;
      //! Unique ptr serializer function
      typedef std::function<void(void*, std::unique_ptr<void, EmptyDeleter<void>> &, std::type_info const &)> UniqueSerializer;

      //! Struct containing the serializer functions for all pointer types
      struct Serializers
      {
        SharedSerializer shared_ptr; //!< Serializer function for shared/weak pointers
        UniqueSerializer unique_ptr; //!< Serializer function for unique pointers
    // forward decls for archives from cereal.hpp
    class InputArchiveBase;
    class OutputArchiveBase;

    //! Creates a binding (map entry) between an input archive type and a polymorphic type
    /*! Bindings are made when types are registered, assuming that at least one
        casting for serializing polymorphic objects */
    template <class Archive, class T> struct InputBindingCreator
    {
      //! Initialize the binding
      InputBindingCreator()
        casting for serializing polymorphic objects */
    template <class Archive, class T> struct OutputBindingCreator
    {
      //! Writes appropriate metadata to the archive for this polymorphic type
      static void writeMetadata(Archive & ar)
      {
        // Register the polymorphic type name with the archive, and get the id
        char const * name = binding_name<T>::name();
      //! Holds a properly typed shared_ptr to the polymorphic type
      class PolymorphicSharedPointerWrapper
      {
        public:
          /*! Wrap a raw polymorphic pointer in a shared_ptr to its true type

              The wrapped pointer will not be responsible for ownership of the held pointer

        private:
          std::shared_ptr<void> refCount;      //!< The ownership pointer
          std::shared_ptr<T const> wrappedPtr; //!< The wrapped pointer
      };
          @param dptr Pointer to the actual data held by the shared_ptr */
      static inline void savePolymorphicSharedPtr( Archive & ar, T const * dptr, std::true_type /* has_shared_from_this */ )
      {
        ::cereal::memory_detail::EnableSharedStateHelper<T> state( const_cast<T *>(dptr) );
        PolymorphicSharedPointerWrapper psptr( dptr );
          @param dptr Pointer to the actual data held by the shared_ptr */
      static inline void savePolymorphicSharedPtr( Archive & ar, T const * dptr, std::false_type /* has_shared_from_this */ )
      {
        PolymorphicSharedPointerWrapper psptr( dptr );
        ar( CEREAL_NVP_("ptr_wrapper", memory_detail::make_ptr_wrapper( psptr() ) ) );
    //! of instantiate_polymorphic_binding
    struct adl_tag {};

    //! Tag for init_binding, bind_to_archives and instantiate_polymorphic_binding.
    //! For C++14 and below, we must instantiate a unique StaticObject per TU that is
#ifdef CEREAL_HAS_CPP17
    struct polymorphic_binding_tag {};
#else
    namespace { struct polymorphic_binding_tag {}; }
#endif


    //! Causes the static object bindings between an archive type and a serializable type T
    template <class Archive, class T>
    struct create_bindings
    {
      static const InputBindingCreator<Archive, T> &
      load(std::true_type)
      {
        return cereal::detail::StaticObject<InputBindingCreator<Archive, T>>::getInstance();

      static const OutputBindingCreator<Archive, T> &
      save(std::true_type)
      {
        return cereal::detail::StaticObject<OutputBindingCreator<Archive, T>>::getInstance();
    //! When specialized, causes the compiler to instantiate its parameter
    template <void(*)()>
    struct instantiate_function {};

    /*! This struct is used as the return type of instantiate_polymorphic_binding
        for specific Archive types.  When the compiler looks for overloads of
        instantiate_polymorphic_binding, it will be forced to instantiate this
        struct during overload resolution, even though it will not be part of a valid
        overload */
    template <class Archive, class T>
    struct polymorphic_serialization_support
    {
      #if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
      //! Creates the appropriate bindings depending on whether the archive supports
      //! saving or loading
      virtual CEREAL_DLL_EXPORT void instantiate() CEREAL_USED;
      #else // NOT _MSC_VER
      //! Creates the appropriate bindings depending on whether the archive supports
      //! saving or loading
      static CEREAL_DLL_EXPORT void instantiate() CEREAL_USED;
      //! This typedef causes the compiler to instantiate this static function
      typedef instantiate_function<instantiate> unused;
      #endif // _MSC_VER
    };

    // instantiate implementation
    template <class Archive, class T>
    CEREAL_DLL_EXPORT void polymorphic_serialization_support<Archive,T>::instantiate()
    {
      create_bindings<Archive,T>::save( std::integral_constant<bool,
        registered archive types with the parameter type T. */
    template <class T, class Tag = polymorphic_binding_tag>
    struct bind_to_archives
    {
      //! Binding for non abstract types
      void bind(std::false_type) const
      {
        static_assert( std::is_polymorphic<T>::value,
                       "Attempting to register non polymorphic type" );
        bind( std::is_abstract<T>() );
        return *this;
    //! Used to hide the static object used to bind T to registered archives
    template <class T, class Tag = polymorphic_binding_tag>
    struct init_binding;

    //! Base case overload for instantiation
    /*! This will end up always being the best overload due to the second
        See the documentation for the other functions to try and understand this */
    template <class T, typename BindingTag>
    void instantiate_polymorphic_binding( T*, int, BindingTag, adl_tag ) {}
  } // namespace detail
} // namespace cereal


//========================================
//===== File: ./third-party/cereal/include/cereal/details/polymorphic_impl_fwd.hpp =====
//========================================

namespace cereal
{
  namespace detail
  {
    //! Forward declaration, see polymorphic_impl.hpp for more information
    template <class Base, class Derived>
    struct RegisterPolymorphicCaster;

    //! Forward declaration, see polymorphic_impl.hpp for more information
    struct PolymorphicCasters;

    //! Forward declaration, see polymorphic_impl.hpp for more information
    template <class Base, class Derived>
    struct PolymorphicRelation;
  } // namespace detail
} // namespace cereal



//========================================
//===== File: ./third-party/cereal/include/cereal/details/static_object.hpp =====
//========================================

namespace cereal
{
  namespace detail
  {
    //! A static, pre-execution object
    /*! This class will create a single copy (singleton) of some
        different polymorphic classes */
    template <class T>
    class CEREAL_DLL_EXPORT StaticObject
    {
      private:

        static T & create()
        {
          static T t;
          //! Forces instantiation at pre-execution time
          (void)instance;
          return t;

      public:
        static T & getInstance()
        {
          return create();
        }
        //! A class that acts like std::lock_guard
        class LockGuard
        {
          #if CEREAL_THREAD_SAFE
          public:
            LockGuard(std::mutex & m) : lock(m) {}
          private:
            std::unique_lock<std::mutex> lock;
          #else
          public:
            LockGuard() = default;
            LockGuard(LockGuard const &) = default; // prevents implicit copy ctor warning
            ~LockGuard() CEREAL_NOEXCEPT {} // prevents variable not used
            call will block until the lock is available. */
        static LockGuard lock()
        {
          #if CEREAL_THREAD_SAFE
          static std::mutex instanceMutex;
          return LockGuard{instanceMutex};
          #else
          return LockGuard{};

      private:
        static T & instance;
    };

    template <class T> T & StaticObject<T>::instance = StaticObject<T>::create();
  } // namespace detail
} // namespace cereal



//========================================
//===== File: ./third-party/cereal/include/cereal/details/traits.hpp =====
//========================================

namespace cereal
{
  namespace traits
  {
    using yes = std::true_type;
    using no  = std::false_type;

    namespace detail
    {
      // ######################################################################
      //! Used to delay a static_assert until template instantiation
      template <class T>
      struct delay_static_assert : std::false_type {};

      // ######################################################################
      // SFINAE Helpers
      #ifdef CEREAL_OLDER_GCC // when VS supports better SFINAE, we can use this as the default
      template<typename> struct Void { typedef void type; };
      #endif // CEREAL_OLDER_GCC

      //! Return type for SFINAE Enablers
      enum class sfinae {};

      // ######################################################################
      // Helper functionality for boolean integral constants and Enable/DisableIf
      template <bool H, bool ... T> struct meta_bool_and : std::integral_constant<bool, H && meta_bool_and<T...>::value> {};
      template <bool B> struct meta_bool_and<B> : std::integral_constant<bool, B> {};

      template <bool H, bool ... T> struct meta_bool_or : std::integral_constant<bool, H || meta_bool_or<T...>::value> {};
      template <bool B> struct meta_bool_or<B> : std::integral_constant<bool, B> {};

      // workaround needed due to bug in MSVC 2013, see
      // http://connect.microsoft.com/VisualStudio/feedback/details/800231/c-11-alias-template-issue
      template <bool ... Conditions>
      struct EnableIfHelper : std::enable_if<meta_bool_and<Conditions...>::value, sfinae> {};

      template <bool ... Conditions>
      struct DisableIfHelper : std::enable_if<!meta_bool_or<Conditions...>::value, sfinae> {};
    } // namespace detail

    //! Used as the default value for EnableIf and DisableIf template parameters
        @relates DisableIf */
    static const detail::sfinae sfinae = {};

    // ######################################################################
    //! Provides a way to enable a function if conditions are met
        // using by making the last template argument variadic
        template <class T, EnableIf<std::is_same<T, bool>::value> = sfinae>
        void func(T t );
        @endcode

        @tparam Conditions The conditions which will be logically ANDed to enable the function. */
    template <bool ... Conditions>
    using EnableIf = typename detail::EnableIfHelper<Conditions...>::type;

    // ######################################################################
        // using by making the last template argument variadic
        template <class T, DisableIf<std::is_same<T, bool>::value> = sfinae>
        void func(T t );
        @endcode

        @tparam Conditions The conditions which will be logically ANDed to disable the function. */
    template <bool ... Conditions>
    using DisableIf = typename detail::DisableIfHelper<Conditions...>::type;

    // ######################################################################
    namespace detail
    {
      template <class InputArchive>
      struct get_output_from_input : no
      {
        static_assert( detail::delay_static_assert<InputArchive>::value,
            "Could not find an associated output archive for input archive." );
      };

      template <class OutputArchive>
      struct get_input_from_output : no
      {
        static_assert( detail::delay_static_assert<OutputArchive>::value,
            "Could not find an associated input archive for output archive." );
      };
    }
    #define CEREAL_SETUP_ARCHIVE_TRAITS(InputArchive, OutputArchive)  \
    namespace cereal { namespace traits { namespace detail {          \
      template <> struct get_output_from_input<InputArchive>          \
      { using type = OutputArchive; };                                \
      template <> struct get_input_from_output<OutputArchive>         \
      { using type = InputArchive; }; } } } /* end namespaces */

    // ######################################################################
    #define CEREAL_MAKE_HAS_MEMBER_TEST(name, test_name, versioned)                                                                         \
    template <class T, class A, class SFINAE = void>                                                                                        \
    struct has_member_##test_name : no {};                                                                                                  \
    template <class T, class A>                                                                                                             \
    struct has_member_##test_name<T, A,                                                                                                     \
      typename detail::Void< decltype( cereal::access::member_##name( std::declval<A&>(), std::declval<T&>() versioned ) ) >::type> : yes {}
    #else // NOT CEREAL_OLDER_GCC
    #define CEREAL_MAKE_HAS_MEMBER_TEST(name, test_name, versioned)                                                                     \
    namespace detail                                                                                                                    \
    {                                                                                                                                   \
      template <class T, class A>                                                                                                       \
      struct has_member_##name##_##versioned##_impl                                                                                     \
      {                                                                                                                                 \
        template <class TT, class AA>                                                                                                   \
        static auto test(int) -> decltype( cereal::access::member_##name( std::declval<AA&>(), std::declval<TT&>() versioned ), yes()); \
        template <class, class>                                                                                                         \
        static no test(...);                                                                                                            \
        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                                    \
      };                                                                                                                                \
    } /* end namespace detail */                                                                                                        \
    template <class T, class A>                                                                                                         \
    struct has_member_##test_name : std::integral_constant<bool, detail::has_member_##name##_##versioned##_impl<T, A>::value> {}
    #endif // NOT CEREAL_OLDER_GCC

    // ######################################################################
    #define CEREAL_MAKE_HAS_NON_MEMBER_TEST(test_name, func, versioned)                                                         \
    namespace detail                                                                                                            \
    {                                                                                                                           \
      template <class T, class A>                                                                                               \
      struct has_non_member_##test_name##_impl                                                                                  \
      {                                                                                                                         \
        template <class TT, class AA>                                                                                           \
        static auto test(int) -> decltype( func( std::declval<AA&>(), std::declval<TT&>() versioned ), yes());                  \
        template <class, class>                                                                                                 \
        static no test( ... );                                                                                                  \
        static const bool value = std::is_same<decltype( test<T, A>( 0 ) ), yes>::value;                                        \
      };                                                                                                                        \
    } /* end namespace detail */                                                                                                \
    template <class T, class A>                                                                                                 \
    struct has_non_member_##test_name : std::integral_constant<bool, detail::has_non_member_##test_name##_impl<T, A>::value> {}

    // ######################################################################
    // Member Serialize
    #define CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL(test_name, versioned)                                                                  \
    namespace detail                                                                                                                \
    {                                                                                                                               \
    template <class T, class A>                                                                                                     \
    struct has_member_##test_name##_impl                                                                                            \
      {                                                                                                                             \
        template <class TT, class AA, class SFINAE = void> struct test : no {};                                                     \
        template <class TT, class AA>                                                                                               \
        struct test<TT, AA,                                                                                                         \
          typename detail::Void< decltype( cereal::access::member_save( std::declval<AA&>(),                                        \
                                                                        std::declval<TT const &>() versioned ) ) >::type> : yes {}; \
        static const bool value = test<T, A>();                                                                                     \
                                                                                                                                    \
        template <class TT, class AA, class SFINAE = void> struct test2 : no {};                                                    \
        template <class TT, class AA>                                                                                               \
        struct test2<TT, AA,                                                                                                        \
          typename detail::Void< decltype( cereal::access::member_save_non_const(                                                   \
                                            std::declval<AA&>(),                                                                    \
                                            std::declval<typename std::remove_const<TT>::type&>() versioned ) ) >::type> : yes {};  \
        static const bool not_const_type = test2<T, A>();                                                                           \
      };                                                                                                                            \
    } /* end namespace detail */
    #else /* NOT CEREAL_OLDER_GCC =================================== */
    #define CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL(test_name, versioned)                                                                  \
    namespace detail                                                                                                                \
    {                                                                                                                               \
    template <class T, class A>                                                                                                     \
    struct has_member_##test_name##_impl                                                                                            \
      {                                                                                                                             \
        template <class TT, class AA>                                                                                               \
        static auto test(int) -> decltype( cereal::access::member_save( std::declval<AA&>(),                                        \
                                                                        std::declval<TT const &>() versioned ), yes());             \
        template <class, class> static no test(...);                                                                                \
        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                                \
                                                                                                                                    \
        template <class TT, class AA>                                                                                               \
        static auto test2(int) -> decltype( cereal::access::member_save_non_const(                                                  \
                                              std::declval<AA &>(),                                                                 \
                                              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());            \
        template <class, class> static no test2(...);                                                                               \
        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value;                                      \
      };                                                                                                                            \
    } /* end namespace detail */
    #endif /* NOT CEREAL_OLDER_GCC */

    template <class T, class A>
    struct has_member_save : std::integral_constant<bool, detail::has_member_save_impl<T, A>::value>
    {
      typedef typename detail::has_member_save_impl<T, A> check;
      static_assert( check::value || !check::not_const_type,
        "cereal detected a non-const save. \n "
        "save member functions must always be const" );
    };

    template <class T, class A>
    struct has_member_versioned_save : std::integral_constant<bool, detail::has_member_versioned_save_impl<T, A>::value>
    {
      typedef typename detail::has_member_versioned_save_impl<T, A> check;
      static_assert( check::value || !check::not_const_type,
        "cereal detected a versioned non-const save. \n "
        "save member functions must always be const" );
    };
    #define CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST(test_name, versioned)                                                       \
    namespace detail                                                                                                         \
    {                                                                                                                        \
      template <class T, class A>                                                                                            \
      struct has_non_member_##test_name##_impl                                                                               \
      {                                                                                                                      \
        template <class TT, class AA>                                                                                        \
        static auto test(int) -> decltype( CEREAL_SAVE_FUNCTION_NAME(                                                        \
                                              std::declval<AA&>(),                                                           \
                                              std::declval<TT const &>() versioned ), yes());                                \
        template <class, class> static no test(...);                                                                         \
        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                         \
                                                                                                                             \
        template <class TT, class AA>                                                                                        \
        static auto test2(int) -> decltype( CEREAL_SAVE_FUNCTION_NAME(                                                       \
                                              std::declval<AA &>(),                                                          \
                                              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());     \
        template <class, class> static no test2(...);                                                                        \
        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value;                               \
      };                                                                                                                     \
    } /* end namespace detail */                                                                                             \
                                                                                                                             \
    template <class T, class A>                                                                                              \
    struct has_non_member_##test_name : std::integral_constant<bool, detail::has_non_member_##test_name##_impl<T, A>::value> \
    {                                                                                                                        \
      using check = typename detail::has_non_member_##test_name##_impl<T, A>;                                                \
      static_assert( check::value || !check::not_const_type,                                                                 \
        "cereal detected a non-const type parameter in non-member " #test_name ". \n "                                       \
        #test_name " non-member functions must always pass their types as const" );                                          \
    };
    // Minimal Utilities
    namespace detail
    {
      // Determines if the provided type is an std::string
      template <class> struct is_string : std::false_type {};

      template <class CharT, class Traits, class Alloc>
      struct is_string<std::basic_string<CharT, Traits, Alloc>> : std::true_type {};
    }

    // Determines if the type is valid for use with a minimal serialize function
    template <class T>
    struct is_minimal_type : std::integral_constant<bool,
      detail::is_string<T>::value || std::is_arithmetic<T>::value> {};

    // ######################################################################
    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL(test_name, versioned)                                                                        \
    namespace detail                                                                                                                              \
    {                                                                                                                                             \
      template <class T, class A>                                                                                                                 \
      struct has_member_##test_name##_impl                                                                                                        \
      {                                                                                                                                           \
        template <class TT, class AA, class SFINAE = void> struct test : no {};                                                                   \
        template <class TT, class AA>                                                                                                             \
        struct test<TT, AA, typename detail::Void< decltype(                                                                                      \
            cereal::access::member_save_minimal( std::declval<AA const &>(),                                                                      \
                                                 std::declval<TT const &>() versioned ) ) >::type> : yes {};                                      \
                                                                                                                                                  \
        static const bool value = test<T, A>();                                                                                                   \
                                                                                                                                                  \
        template <class TT, class AA, class SFINAE = void> struct test2 : no {};                                                                  \
        template <class TT, class AA>                                                                                                             \
        struct test2<TT, AA, typename detail::Void< decltype(                                                                                     \
            cereal::access::member_save_minimal_non_const( std::declval<AA const &>(),                                                            \
                                                           std::declval<typename std::remove_const<TT>::type&>() versioned ) ) >::type> : yes {}; \
        static const bool not_const_type = test2<T, A>();                                                                                         \
                                                                                                                                                  \
        static const bool valid = value || !not_const_type;                                                                                       \
      };                                                                                                                                          \
    } /* end namespace detail */
    #else /* NOT CEREAL_OLDER_GCC =================================== */
    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL(test_name, versioned)                     \
    namespace detail                                                                           \
    {                                                                                          \
      template <class T, class A>                                                              \
      struct has_member_##test_name##_impl                                                     \
      {                                                                                        \
        template <class TT, class AA>                                                          \
        static auto test(int) -> decltype( cereal::access::member_save_minimal(                \
              std::declval<AA const &>(),                                                      \
              std::declval<TT const &>() versioned ), yes());                                  \
        template <class, class> static no test(...);                                           \
        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;           \
                                                                                               \
        template <class TT, class AA>                                                          \
        static auto test2(int) -> decltype( cereal::access::member_save_minimal_non_const(     \
              std::declval<AA const &>(),                                                      \
              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());       \
        template <class, class> static no test2(...);                                          \
        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value; \
                                                                                               \
        static const bool valid = value || !not_const_type;                                    \
      };                                                                                       \
    } /* end namespace detail */
    #endif // NOT CEREAL_OLDER_GCC
    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL(test_name, versioned)                           \
    namespace detail                                                                                         \
    {                                                                                                        \
      template <class T, class A, bool Valid>                                                                \
      struct get_member_##test_name##_type { using type = void; };                                           \
                                                                                                             \
      template <class T, class A>                                                                            \
      struct get_member_##test_name##_type<T, A, true>                                                       \
      {                                                                                                      \
        using type = decltype( cereal::access::member_save_minimal( std::declval<A const &>(),               \
                                                                    std::declval<T const &>() versioned ) ); \
    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST(test_name)                                                      \
    template <class T, class A>                                                                                      \
    struct has_member_##test_name : std::integral_constant<bool, detail::has_member_##test_name##_impl<T, A>::value> \
    {                                                                                                                \
      using check = typename detail::has_member_##test_name##_impl<T, A>;                                            \
      static_assert( check::valid,                                                                                   \
        "cereal detected a non-const member " #test_name ". \n "                                                     \
        #test_name " member functions must always be const" );                                                       \
                                                                                                                     \
      using type = typename detail::get_member_##test_name##_type<T, A, check::value>::type;                         \
      static_assert( (check::value && is_minimal_type<type>::value) || !check::value,                                \
        "cereal detected a member " #test_name " with an invalid return type. \n "                                   \
        "return type must be arithmetic or string" );                                                                \
    };
    #define CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST(test_name, versioned)                                               \
    namespace detail                                                                                                         \
    {                                                                                                                        \
      template <class T, class A>                                                                                            \
      struct has_non_member_##test_name##_impl                                                                               \
      {                                                                                                                      \
        template <class TT, class AA>                                                                                        \
        static auto test(int) -> decltype( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(                                                \
              std::declval<AA const &>(),                                                                                    \
              std::declval<TT const &>() versioned ), yes());                                                                \
        template <class, class> static no test(...);                                                                         \
        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                         \
                                                                                                                             \
        template <class TT, class AA>                                                                                        \
        static auto test2(int) -> decltype( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(                                               \
              std::declval<AA const &>(),                                                                                    \
              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());                                     \
        template <class, class> static no test2(...);                                                                        \
        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value;                               \
                                                                                                                             \
        static const bool valid = value || !not_const_type;                                                                  \
      };                                                                                                                     \
                                                                                                                             \
      template <class T, class A, bool Valid>                                                                                \
      struct get_non_member_##test_name##_type { using type = void; };                                                       \
                                                                                                                             \
      template <class T, class A>                                                                                            \
      struct get_non_member_##test_name##_type <T, A, true>                                                                  \
      {                                                                                                                      \
        using type = decltype( CEREAL_SAVE_MINIMAL_FUNCTION_NAME( std::declval<A const &>(),                                 \
                                                                  std::declval<T const &>() versioned ) );                   \
                                                                                                                             \
    template <class T, class A>                                                                                              \
    struct has_non_member_##test_name : std::integral_constant<bool, detail::has_non_member_##test_name##_impl<T, A>::value> \
    {                                                                                                                        \
      using check = typename detail::has_non_member_##test_name##_impl<T, A>;                                                \
      static_assert( check::valid,                                                                                           \
        "cereal detected a non-const type parameter in non-member " #test_name ". \n "                                       \
        #test_name " non-member functions must always pass their types as const" );                                          \
                                                                                                                             \
      using type = typename detail::get_non_member_##test_name##_type<T, A, check::value>::type;                             \
      static_assert( (check::value && is_minimal_type<type>::value) || !check::value,                                        \
        "cereal detected a non-member " #test_name " with an invalid return type. \n "                                       \
        "return type must be arithmetic or string" );                                                                        \
    };
    // Load Minimal Utilities
    namespace detail
    {
      //! Used to help strip away conversion wrappers
      /*! If someone writes a non-member load/save minimal function that accepts its
          the underlying type, allowing traits to work properly */
      struct NoConvertBase {};

      //! A struct that prevents implicit conversion
      /*! Any type instantiated with this struct will be unable to implicitly convert
          @tparam Source the type of the original source */
      template <class Source>
      struct NoConvertConstRef : NoConvertBase
      {
        using type = Source; //!< Used to get underlying type easily

        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>
        operator Dest () = delete;

        //! only allow conversion if the types are the same and we are converting into a const reference
        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>
        operator Dest const & ();
      };

          @tparam Source the type of the original source */
      template <class Source>
      struct NoConvertRef : NoConvertBase
      {
        using type = Source; //!< Used to get underlying type easily

        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>
        operator Dest () = delete;

        #ifdef __clang__
        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>
        operator Dest const & () = delete;
        #endif // __clang__

        //! only allow conversion if the types are the same and we are converting into a const reference
        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>
        operator Dest & ();
      };

      //! A type that can implicitly convert to anything else
      struct AnyConvert
      {
        template <class Dest>
        operator Dest & ();

        template <class Dest>
        operator Dest const & () const;
      };
    } // namespace detail
    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL(test_name, versioned)                                                    \
    namespace detail                                                                                                          \
    {                                                                                                                         \
      template <class T, class A, class SFINAE = void> struct has_member_##test_name##_impl : no {};                          \
      template <class T, class A>                                                                                             \
      struct has_member_##test_name##_impl<T, A, typename detail::Void< decltype(                                             \
          cereal::access::member_load_minimal( std::declval<A const &>(),                                                     \
                                               std::declval<T &>(), AnyConvert() versioned ) ) >::type> : yes {};             \
                                                                                                                              \
        template <class T, class A, class U, class SFINAE = void> struct has_member_##test_name##_type_impl : no {};          \
        template <class T, class A, class U>                                                                                  \
        struct has_member_##test_name##_type_impl<T, A, U, typename detail::Void< decltype(                                   \
            cereal::access::member_load_minimal( std::declval<A const &>(),                                                   \
                                                 std::declval<T &>(), NoConvertConstRef<U>() versioned ) ) >::type> : yes {}; \
    } /* end namespace detail */
    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL(test_name, versioned)              \
    namespace detail                                                                    \
    {                                                                                   \
      template <class T, class A>                                                       \
      struct has_member_##test_name##_impl                                              \
      {                                                                                 \
        template <class TT, class AA>                                                   \
        static auto test(int) -> decltype( cereal::access::member_load_minimal(         \
              std::declval<AA const &>(),                                               \
              std::declval<TT &>(), AnyConvert() versioned ), yes());                   \
        template <class, class> static no test(...);                                    \
        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;    \
      };                                                                                \
      template <class T, class A, class U>                                              \
      struct has_member_##test_name##_type_impl                                         \
      {                                                                                 \
        template <class TT, class AA, class UU>                                         \
        static auto test(int) -> decltype( cereal::access::member_load_minimal(         \
              std::declval<AA const &>(),                                               \
              std::declval<TT &>(), NoConvertConstRef<UU>() versioned ), yes());        \
        template <class, class, class> static no test(...);                             \
        static const bool value = std::is_same<decltype(test<T, A, U>(0)), yes>::value; \
                                                                                        \
      };                                                                                \
    } /* end namespace detail */
    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL(load_test_name, save_test_name, save_test_prefix, versioned) \
    namespace detail                                                                                                      \
    {                                                                                                                     \
      template <class T, class A, bool Valid>                                                                             \
      struct has_member_##load_test_name##_wrapper : std::false_type {};                                                  \
                                                                                                                          \
      template <class T, class A>                                                                                         \
      struct has_member_##load_test_name##_wrapper<T, A, true>                                                            \
      {                                                                                                                   \
        using AOut = typename detail::get_output_from_input<A>::type;                                                     \
                                                                                                                          \
        static_assert( has_member_##save_test_prefix##_minimal<T, AOut>::value,                                           \
          "cereal detected member " #load_test_name " but no valid member " #save_test_name ". \n "                       \
          "cannot evaluate correctness of " #load_test_name " without valid " #save_test_name "." );                      \
                                                                                                                          \
                                                                                                                          \
        static_assert( valid || !value, "cereal detected different or invalid types in corresponding member "             \
            #load_test_name " and " #save_test_name " functions. \n "                                                     \
            "the paramater to " #load_test_name " must be a constant reference to the type that "                         \
            #save_test_name " returns." );                                                                                \
    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST(load_test_name, load_test_prefix)                                         \
    template <class T, class A>                                                                                                \
    struct has_member_##load_test_prefix##_minimal : std::integral_constant<bool,                                              \
      detail::has_member_##load_test_name##_wrapper<T, A, detail::has_member_##load_test_name##_impl<T, A>::value>::value> {};

    // ######################################################################
    // Non-Member Load Minimal
    namespace detail
    {
      #ifdef CEREAL_OLDER_GCC
      void CEREAL_LOAD_MINIMAL_FUNCTION_NAME(); // prevents nonsense complaining about not finding this
        @code
        static_assert( check::const_valid || !check::exists,
            "cereal detected an invalid serialization type parameter in non-member " #test_name ".  "
            #test_name " non-member functions must accept their serialization type by non-const reference" );
        @endcode
    #define CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST(test_name, save_name, versioned)                                    \
    namespace detail                                                                                                         \
    {                                                                                                                        \
      template <class T, class A, class U = void>                                                                            \
      struct has_non_member_##test_name##_impl                                                                               \
      {                                                                                                                      \
        template <class TT, class AA>                                                                                        \
        static auto test(int) -> decltype( CEREAL_LOAD_MINIMAL_FUNCTION_NAME(                                                \
              std::declval<AA const &>(), std::declval<TT&>(), AnyConvert() versioned ), yes() );                            \
        template <class, class> static no test( ... );                                                                       \
        static const bool exists = std::is_same<decltype( test<T, A>( 0 ) ), yes>::value;                                    \
                                                                                                                             \
        template <class TT, class AA, class UU>                                                                              \
        static auto test2(int) -> decltype( CEREAL_LOAD_MINIMAL_FUNCTION_NAME(                                               \
              std::declval<AA const &>(), std::declval<TT&>(), NoConvertConstRef<UU>() versioned ), yes() );                 \
        template <class, class, class> static no test2( ... );                                                               \
        static const bool valid = std::is_same<decltype( test2<T, A, U>( 0 ) ), yes>::value;                                 \
                                                                                                                             \
        template <class TT, class AA>                                                                                        \
        static auto test3(int) -> decltype( CEREAL_LOAD_MINIMAL_FUNCTION_NAME(                                               \
              std::declval<AA const &>(), NoConvertRef<TT>(), AnyConvert() versioned ), yes() );                             \
        template <class, class> static no test3( ... );                                                                      \
        static const bool const_valid = std::is_same<decltype( test3<T, A>( 0 ) ), yes>::value;                              \
      };                                                                                                                     \
                                                                                                                             \
      template <class T, class A, bool Valid>                                                                                \
      struct has_non_member_##test_name##_wrapper : std::false_type {};                                                      \
                                                                                                                             \
      template <class T, class A>                                                                                            \
      struct has_non_member_##test_name##_wrapper<T, A, true>                                                                \
      {                                                                                                                      \
        using AOut = typename detail::get_output_from_input<A>::type;                                                        \
                                                                                                                             \
        static_assert( detail::has_non_member_##save_name##_impl<T, AOut>::valid,                                            \
          "cereal detected non-member " #test_name " but no valid non-member " #save_name ". \n "                            \
          "cannot evaluate correctness of " #test_name " without valid " #save_name "." );                                   \
                                                                                                                             \
        using check = has_non_member_##test_name##_impl<T, A, SaveType>;                                                     \
        static const bool value = check::exists;                                                                             \
                                                                                                                             \
        static_assert( check::valid || !check::exists, "cereal detected different types in corresponding non-member "        \
            #test_name " and " #save_name " functions. \n "                                                                  \
            "the paramater to " #test_name " must be a constant reference to the type that " #save_name " returns." );       \
      };                                                                                                                     \
                                                                                                                             \
    template <class T, class A>                                                                                              \
    struct has_non_member_##test_name : std::integral_constant<bool,                                                         \
      detail::has_non_member_##test_name##_wrapper<T, A, detail::has_non_member_##test_name##_impl<T, A>::exists>::value> {};

    // ######################################################################
    // ######################################################################
    namespace detail
    {
      // const stripped away before reaching here, prevents errors on conversion from
      // construct<const T> to construct<T>
      template<typename T, typename A>
      struct has_member_load_and_construct_impl : std::integral_constant<bool,
        std::is_same<decltype( access::load_and_construct<T>( std::declval<A&>(), std::declval< ::cereal::construct<T>&>() ) ), void>::value>
      { };

      template<typename T, typename A>
      struct has_member_versioned_load_and_construct_impl : std::integral_constant<bool,
        std::is_same<decltype( access::load_and_construct<T>( std::declval<A&>(), std::declval< ::cereal::construct<T>&>(), 0 ) ), void>::value>
      { };
    } // namespace detail
    //! Member load and construct check
    template<typename T, typename A>
    struct has_member_load_and_construct : detail::has_member_load_and_construct_impl<typename std::remove_const<T>::type, A>
    { };

    //! Member load and construct check (versioned)
    template<typename T, typename A>
    struct has_member_versioned_load_and_construct : detail::has_member_versioned_load_and_construct_impl<typename std::remove_const<T>::type, A>
    { };

    // ######################################################################
    #define CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST(test_name, versioned)                                            \
    namespace detail                                                                                                            \
    {                                                                                                                           \
      template <class T, class A>                                                                                               \
      struct has_non_member_##test_name##_impl                                                                                  \
      {                                                                                                                         \
        template <class TT, class AA>                                                                                           \
        static auto test(int) -> decltype( LoadAndConstruct<TT>::load_and_construct(                                            \
                                           std::declval<AA&>(), std::declval< ::cereal::construct<TT>&>() versioned ), yes());  \
        template <class, class>                                                                                                 \
        static no test( ... );                                                                                                  \
        static const bool value = std::is_same<decltype( test<T, A>( 0 ) ), yes>::value;                                        \
      };                                                                                                                        \
    } /* end namespace detail */                                                                                                \
    template <class T, class A>                                                                                                 \
    struct has_non_member_##test_name :                                                                                         \
      std::integral_constant<bool, detail::has_non_member_##test_name##_impl<typename std::remove_const<T>::type, A>::value> {};

    // ######################################################################
    //! Has either a member or non member load and construct
    template<typename T, typename A>
    struct has_load_and_construct : std::integral_constant<bool,
      has_member_load_and_construct<T, A>::value || has_non_member_load_and_construct<T, A>::value ||
      has_member_versioned_load_and_construct<T, A>::value || has_non_member_versioned_load_and_construct<T, A>::value>
    { };
    // ######################################################################
    template <class T, class InputArchive, class OutputArchive>
    struct has_member_split : std::integral_constant<bool,
      (has_member_load<T, InputArchive>::value && has_member_save<T, OutputArchive>::value) ||
      (has_member_versioned_load<T, InputArchive>::value && has_member_versioned_save<T, OutputArchive>::value)> {};

    // ######################################################################
    template <class T, class InputArchive, class OutputArchive>
    struct has_non_member_split : std::integral_constant<bool,
      (has_non_member_load<T, InputArchive>::value && has_non_member_save<T, OutputArchive>::value) ||
      (has_non_member_versioned_load<T, InputArchive>::value && has_non_member_versioned_save<T, OutputArchive>::value)> {};

    // ######################################################################
    template <class T, class OutputArchive>
    struct has_invalid_output_versioning : std::integral_constant<bool,
      (has_member_versioned_save<T, OutputArchive>::value && has_member_save<T, OutputArchive>::value) ||
      (has_non_member_versioned_save<T, OutputArchive>::value && has_non_member_save<T, OutputArchive>::value) ||
      (has_member_versioned_serialize<T, OutputArchive>::value && has_member_serialize<T, OutputArchive>::value) ||
    // ######################################################################
    template <class T, class InputArchive>
    struct has_invalid_input_versioning : std::integral_constant<bool,
      (has_member_versioned_load<T, InputArchive>::value && has_member_load<T, InputArchive>::value) ||
      (has_non_member_versioned_load<T, InputArchive>::value && has_non_member_load<T, InputArchive>::value) ||
      (has_member_versioned_serialize<T, InputArchive>::value && has_member_serialize<T, InputArchive>::value) ||
    // ######################################################################
    namespace detail
    {
      //! Create a test for a cereal::specialization entry
      #define CEREAL_MAKE_IS_SPECIALIZED_IMPL(name)                                          \
      template <class T, class A>                                                            \
      struct is_specialized_##name : std::integral_constant<bool,                            \
        !std::is_base_of<std::false_type, specialize<A, T, specialization::name>>::value> {}

      CEREAL_MAKE_IS_SPECIALIZED_IMPL(member_serialize);
      //! Number of specializations detected
      template <class T, class A>
      struct count_specializations : std::integral_constant<int,
        is_specialized_member_serialize<T, A>::value +
        is_specialized_member_load_save<T, A>::value +
        is_specialized_member_load_save_minimal<T, A>::value +
    //! Check if any specialization exists for a type
    template <class T, class A>
    struct is_specialized : std::integral_constant<bool,
      detail::is_specialized_member_serialize<T, A>::value ||
      detail::is_specialized_member_load_save<T, A>::value ||
      detail::is_specialized_member_load_save_minimal<T, A>::value ||
    {
      static_assert(detail::count_specializations<T, A>::value <= 1, "More than one explicit specialization detected for type.");
    };

    //! Create the static assertion for some specialization
    #define CEREAL_MAKE_IS_SPECIALIZED_ASSERT(name, versioned_name, print_name, spec_name)                      \
    static_assert( (is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value &&           \
                   (has_##name<T, A>::value || has_##versioned_name<T, A>::value))                              \
                   || !(is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value),        \
                   "cereal detected " #print_name " specialization but no " #print_name " serialize function" )
    #define CEREAL_MAKE_IS_SPECIALIZED(name, versioned_name, spec_name)                     \
    template <class T, class A>                                                             \
    struct is_specialized_##name : std::integral_constant<bool,                             \
      is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value>       \
    { CEREAL_MAKE_IS_SPECIALIZED_ASSERT(name, versioned_name, name, spec_name); };          \
    template <class T, class A>                                                             \
    struct is_specialized_##versioned_name : std::integral_constant<bool,                   \
      is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value>       \
    { CEREAL_MAKE_IS_SPECIALIZED_ASSERT(name, versioned_name, versioned_name, spec_name); }

    // detects if a type has any active minimal output serialization
    template <class T, class OutputArchive>
    struct has_minimal_output_serialization : std::integral_constant<bool,
      is_specialized_member_save_minimal<T, OutputArchive>::value ||
      ((has_member_save_minimal<T, OutputArchive>::value ||
        has_non_member_save_minimal<T, OutputArchive>::value ||
    // detects if a type has any active minimal input serialization
    template <class T, class InputArchive>
    struct has_minimal_input_serialization : std::integral_constant<bool,
      is_specialized_member_load_minimal<T, InputArchive>::value ||
      ((has_member_load_minimal<T, InputArchive>::value ||
        has_non_member_load_minimal<T, InputArchive>::value ||
    // ######################################################################
    namespace detail
    {
      //! The number of output serialization functions available
      /*! If specialization is being used, we'll count only those; otherwise we'll count everything */
      template <class T, class OutputArchive>
      struct count_output_serializers : std::integral_constant<int,
        count_specializations<T, OutputArchive>::value ? count_specializations<T, OutputArchive>::value :
        has_member_save<T, OutputArchive>::value +
        has_non_member_save<T, OutputArchive>::value +

    template <class T, class OutputArchive>
    struct is_output_serializable : std::integral_constant<bool,
      detail::count_output_serializers<T, OutputArchive>::value == 1> {};

    // ######################################################################
    namespace detail
    {
      //! The number of input serialization functions available
      /*! If specialization is being used, we'll count only those; otherwise we'll count everything */
      template <class T, class InputArchive>
      struct count_input_serializers : std::integral_constant<int,
        count_specializations<T, InputArchive>::value ? count_specializations<T, InputArchive>::value :
        has_member_load<T, InputArchive>::value +
        has_non_member_load<T, InputArchive>::value +

    template <class T, class InputArchive>
    struct is_input_serializable : std::integral_constant<bool,
      detail::count_input_serializers<T, InputArchive>::value == 1> {};

    // ######################################################################
    // Base Class Support
    namespace detail
    {
      struct base_class_id
      {
        template<class T>
          base_class_id(T const * const t) :
          type(typeid(T)),
          ptr(t),
      };
      struct base_class_id_hash { size_t operator()(base_class_id const & id) const { return id.hash; }  };
    } // namespace detail

    namespace detail
    {
      //! Common base type for base class casting
      struct BaseCastBase {};

      template <class>
      struct get_base_class;

      template <template<typename> class Cast, class Base>
      struct get_base_class<Cast<Base>>
      {
        using type = Base;
      };
      //! Base class cast, behave as the test
      template <class Cast, template<class, class> class Test, class Archive,
                bool IsBaseCast = std::is_base_of<BaseCastBase, Cast>::value>
      struct has_minimal_base_class_serialization_impl : Test<typename get_base_class<Cast>::type, Archive>
      { };

      //! Not a base class cast
      template <class Cast, template<class, class> class Test, class Archive>
      struct has_minimal_base_class_serialization_impl<Cast,Test, Archive, false> : std::false_type
      { };
    }

        @tparam Archive The archive to use with the test */
    template <class Cast, template<class, class> class Test, class Archive>
    struct has_minimal_base_class_serialization : detail::has_minimal_base_class_serialization_impl<Cast, Test, Archive>
    { };


    // ######################################################################
    namespace detail
    {
      struct shared_from_this_wrapper
      {
        template <class U>
        static auto (check)( U const & t ) -> decltype( ::cereal::access::shared_from_this(t), std::true_type() );

        static auto (check)( ... ) -> decltype( std::false_type() );

        template <class U>
        static auto get( U const & t ) -> decltype( t.shared_from_this() );
      };
    }

    //! Determine if T or any base class of T has inherited from std::enable_shared_from_this
    template<class T>
    struct has_shared_from_this : decltype((detail::shared_from_this_wrapper::check)(std::declval<T>()))
    { };

    //! Get the type of the base class of T which inherited from std::enable_shared_from_this
    template <class T>
    struct get_shared_from_this_base
    {
      private:
        using PtrType = decltype(detail::shared_from_this_wrapper::get(std::declval<T>()));
      public:
        //! The type of the base of T that inherited from std::enable_shared_from_this
        using type = typename std::decay<typename PtrType::element_type>::type;
    };
        minimal load and save functions.  This can interfere with user type traits on
        templated load and save minimal functions.  To get to the correct underlying type,
        users should use strip_minimal when performing any enable_if type type trait checks.

        See the enum serialization in types/common.hpp for an example of using this */
    template <class T, bool IsCerealMinimalTrait = std::is_base_of<detail::NoConvertBase, T>::value>
    struct strip_minimal
    {
      using type = T;
    };
    //! Specialization for types wrapped in a NoConvert
    template <class T>
    struct strip_minimal<T, true>
    {
      using type = typename T::type;
    };
    //! Determines whether the class T can be default constructed by cereal::access
    template <class T>
    struct is_default_constructible
    {
      #ifdef CEREAL_OLDER_GCC
      template <class TT, class SFINAE = void>
      struct test : no {};
      template <class TT>
      struct test<TT, typename detail::Void< decltype( cereal::access::construct<TT>() ) >::type> : yes {};
      static const bool value = test<T>();
      #else // NOT CEREAL_OLDER_GCC =========================================
      template <class TT>
      static auto test(int) -> decltype( cereal::access::construct<TT>(), yes());
      template <class>
      static no test(...);
      static const bool value = std::is_same<decltype(test<T>(0)), yes>::value;
      #endif // NOT CEREAL_OLDER_GCC
    };

    // ######################################################################
    namespace detail
    {
      //! Removes all qualifiers and minimal wrappers from an archive
      template <class A>
      using decay_archive = typename std::decay<typename strip_minimal<A>::type>::type;
    }

        // example use to disable a serialization function
        template <class Archive, EnableIf<cereal::traits::is_same_archive<Archive, cereal::BinaryOutputArchive>::value> = sfinae>
        void save( Archive & ar, MyType const & mt );
        @endcode */
    template <class ArchiveT, class CerealArchiveT>
    struct is_same_archive : std::integral_constant<bool,
      std::is_same<detail::decay_archive<ArchiveT>, CerealArchiveT>::value>
    { };

        @code{.cpp}
        template <class Archive>
        CEREAL_ARCHIVE_RESTRICT(BinaryInputArchive, BinaryOutputArchive)
        serialize( Archive & ar, MyCoolType & m )
        {
        this struct */
    struct TextArchive {};

    //! Checks if an archive is a text archive (human readable)
    template <class A>
    struct is_text_archive : std::integral_constant<bool,
      std::is_base_of<TextArchive, detail::decay_archive<A>>::value>
    { };
  } // namespace traits
  // ######################################################################
  namespace detail
  {
    template <class T, class A,
              bool Member = traits::has_member_load_and_construct<T, A>::value,
              bool MemberVersioned = traits::has_member_versioned_load_and_construct<T, A>::value,
              bool NonMember = traits::has_non_member_load_and_construct<T, A>::value,
              bool NonMemberVersioned = traits::has_non_member_versioned_load_and_construct<T, A>::value>
    struct Construct
    {
      static_assert( cereal::traits::detail::delay_static_assert<T>::value,
        "cereal found more than one compatible load_and_construct function for the provided type and archive combination. \n\n "
        "Types must either have a member load_and_construct function or a non-member specialization of LoadAndConstruct (you may not mix these). \n "
        "In addition, you may not mix versioned with non-versioned load_and_construct functions. \n\n " );
      static T * load_andor_construct( A & /*ar*/, construct<T> & /*construct*/ )
      { return nullptr; }
    };

    // no load and construct case
    template <class T, class A>
    struct Construct<T, A, false, false, false, false>
    {
      static_assert( ::cereal::traits::is_default_constructible<T>::value,
                     "Trying to serialize a an object with no default constructor. \n\n "
                     "Types must either be default constructible or define either a member or non member Construct function. \n "
                     "Construct functions generally have the signature: \n\n "
                     "} \n\n" );
      static T * load_andor_construct()
      { return ::cereal::access::construct<T>(); }
    };

    // member non-versioned
    template <class T, class A>
    struct Construct<T, A, true, false, false, false>
    {
      static void load_andor_construct( A & ar, construct<T> & construct )
      {
        access::load_and_construct<T>( ar, construct );
      }
    // member versioned
    template <class T, class A>
    struct Construct<T, A, false, true, false, false>
    {
      static void load_andor_construct( A & ar, construct<T> & construct )
      {
        const auto version = ar.template loadClassVersion<T>();
        access::load_and_construct<T>( ar, construct, version );
    // non-member non-versioned
    template <class T, class A>
    struct Construct<T, A, false, false, true, false>
    {
      static void load_andor_construct( A & ar, construct<T> & construct )
      {
        LoadAndConstruct<T>::load_and_construct( ar, construct );
      }
    // non-member versioned
    template <class T, class A>
    struct Construct<T, A, false, false, false, true>
    {
      static void load_andor_construct( A & ar, construct<T> & construct )
      {
        const auto version = ar.template loadClassVersion<T>();
        LoadAndConstruct<T>::load_and_construct( ar, construct, version );


//========================================
//===== File: ./third-party/cereal/include/cereal/details/util.hpp =====
//========================================
#ifdef _MSC_VER
namespace cereal
{
  namespace util
  {
    //! Demangles the type encoded in a string
    /*! @internal */
    /*! @internal */
    template <class T> inline
    std::string demangledName()
    { return typeid( T ).name(); }
  } // namespace util
#include <cstdlib>
namespace cereal
{
  namespace util
  {
    //! Demangles the type encoded in a string
    /*! @internal */
    /*! @internal */
    template<class T> inline
    std::string demangledName()
    { return demangle(typeid(T).name()); }
  }


//========================================
//===== File: ./third-party/cereal/include/cereal/external/base64.hpp =====
//========================================

namespace cereal
{
  namespace base64
  {
    static const std::string chars =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      "abcdefghijklmnopqrstuvwxyz"
      "0123456789+/";

    static inline bool is_base64(unsigned char c) {
      return (isalnum(c) || (c == '+') || (c == '/'));
    }



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/allocators.h =====
//========================================
concept Allocator {
    static const bool kNeedFree;    //!< Whether this allocator needs to call Free().

    // Allocate a memory block.
    // \param size of the memory block in bytes.
    // \param pointer to the memory block. Null pointer is permitted.
    static void Free(void *ptr);
};
\endcode
*/
*/
class CrtAllocator {
public:
    static const bool kNeedFree = true;
    void* Malloc(size_t size) { 
        if (size) //  behavior of malloc(0) is implementation defined.
            return std::malloc(size);
    }
    static void Free(void *ptr) { std::free(ptr); }
};

///////////////////////////////////////////////////////////////////////////////
*/
template <typename BaseAllocator = CrtAllocator>
class MemoryPoolAllocator {
public:
    static const bool kNeedFree = false;    //!< Tell users that no need to call Free() with this allocator. (concept Allocator)

    //! Constructor with chunkSize.
    /*! \param chunkSize The size of memory chunk. The default is kDefaultChunkSize.
    //! Frees a memory block (concept Allocator)
    static void Free(void *ptr) { (void)ptr; } // Do nothing

private:
    //! Copy constructor is not permitted.
    MemoryPoolAllocator(const MemoryPoolAllocator& rhs) /* = delete */;
    //! Copy assignment operator is not permitted.

    static const int kDefaultChunkCapacity = CEREAL_RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY; //!< Default chunk capacity.

    //! Chunk header for perpending to each chunk.
    /*! Chunks are stored as a singly linked list.
    */
    struct ChunkHeader {
        size_t capacity;    //!< Capacity of the chunk in bytes (excluding the header itself).
        size_t size;        //!< Current size of allocated memory in bytes.
        ChunkHeader *next;  //!< Next chunk in the linked list.


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/cursorstreamwrapper.h =====
//========================================
*/
template <typename InputStream, typename Encoding = UTF8<> >
class CursorStreamWrapper : public GenericStreamWrapper<InputStream, Encoding> {
public:
    typedef typename Encoding::Ch Ch;

    CursorStreamWrapper(InputStream& is):
        GenericStreamWrapper<InputStream, Encoding>(is), line_(1), col_(0) {}

private:
    size_t line_;   //!< Current Line
    size_t col_;    //!< Current Column
};


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/document.h =====
//========================================
// Forward declaration.
template <typename Encoding, typename Allocator>
class GenericValue;

template <typename Encoding, typename Allocator, typename StackAllocator>
class GenericDocument;

//! Name-value pair in a JSON object value.
/*!
*/
template <typename Encoding, typename Allocator>
struct GenericMember {
    GenericValue<Encoding, Allocator> name;     //!< name of member (must be a string)
    GenericValue<Encoding, Allocator> value;    //!< value of member.

 */
template <bool Const, typename Encoding, typename Allocator>
class GenericMemberIterator {

    friend class GenericValue<Encoding,Allocator>;
    template <bool, typename, typename> friend class GenericMemberIterator;

    typedef GenericMember<Encoding,Allocator> PlainType;
    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;

public:
    //! Iterator type itself
    typedef GenericMemberIterator Iterator;
    //! Constant iterator type
    typedef GenericMemberIterator<true,Encoding,Allocator>  ConstIterator;
    //! Non-constant iterator type
    typedef GenericMemberIterator<false,Encoding,Allocator> NonConstIterator;

    /** \name std::iterator_traits support */
    //@{
    typedef ValueType      value_type;
    typedef ValueType *    pointer;
    typedef ValueType &    reference;
    typedef std::ptrdiff_t difference_type;
    typedef std::random_access_iterator_tag iterator_category;
    //@}

    //! Pointer to (const) GenericMember
    typedef pointer         Pointer;
    //! Reference to (const) GenericMember
    typedef reference       Reference;
    //! Signed integer type (e.g. \c ptrdiff_t)
    typedef difference_type DifferenceType;

    //! Default constructor (singular value)
    /*! Creates an iterator pointing to no element.
    //@{
    template <bool Const_> bool operator==(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ == that.ptr_; }
    template <bool Const_> bool operator!=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ != that.ptr_; }
    template <bool Const_> bool operator<=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <= that.ptr_; }
    template <bool Const_> bool operator>=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ >= that.ptr_; }
    template <bool Const_> bool operator< (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ < that.ptr_; }
    template <bool Const_> bool operator> (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ > that.ptr_; }

#ifdef __cpp_lib_three_way_comparison
    template <bool Const_> std::strong_ordering operator<=>(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <=> that.ptr_; }
#endif
    //@}


private:
    //! Internal constructor from plain pointer
    explicit GenericMemberIterator(Pointer p) : ptr_(p) {}

    Pointer ptr_; //!< raw pointer
};

template <bool Const, typename Encoding, typename Allocator>
class GenericMemberIterator;

//! non-const GenericMemberIterator
template <typename Encoding, typename Allocator>
class GenericMemberIterator<false,Encoding,Allocator> {
    //! use plain pointer as iterator type
    typedef GenericMember<Encoding,Allocator>* Iterator;
};
//! const GenericMemberIterator
template <typename Encoding, typename Allocator>
class GenericMemberIterator<true,Encoding,Allocator> {
    //! use plain const pointer as iterator type
    typedef const GenericMember<Encoding,Allocator>* Iterator;
};

#endif // CEREAL_RAPIDJSON_NOMEMBERITERATORCLASS
*/
template<typename CharType>
struct GenericStringRef {
    typedef CharType Ch; //!< character type of the string

    //! Create string reference from \c const character array
#ifndef __clang__ // -Wdocumentation
#endif
    template<SizeType N>
    GenericStringRef(const CharType (&str)[N]) CEREAL_RAPIDJSON_NOEXCEPT
        : s(str), length(N-1) {}

#endif
    explicit GenericStringRef(const CharType* str)
        : s(str), length(NotNullStrLen(str)) {}

    //! Create constant string reference from pointer and length

private:
    SizeType NotNullStrLen(const CharType* str) {
        CEREAL_RAPIDJSON_ASSERT(str != 0);
        return internal::StrLen(str);
    /// Empty string - used when passing in a NULL pointer
    static const Ch emptyString[];

    //! Disallow construction from non-const array
    template<SizeType N>
    GenericStringRef(CharType (&str)[N]) /* = delete */;
    //! Copy assignment operator not permitted - immutable type
    GenericStringRef& operator=(const GenericStringRef& rhs) /* = delete */;

template<typename CharType>
const CharType GenericStringRef<CharType>::emptyString[] = { CharType() };

//! Mark a character pointer as constant string
*/
template<typename CharType>
inline GenericStringRef<CharType> StringRef(const CharType* str) {
    return GenericStringRef<CharType>(str);
}
*/
template<typename CharType>
inline GenericStringRef<CharType> StringRef(const CharType* str, size_t length) {
    return GenericStringRef<CharType>(str, SizeType(length));
}
*/
template<typename CharType>
inline GenericStringRef<CharType> StringRef(const std::basic_string<CharType>& str) {
    return GenericStringRef<CharType>(str.data(), SizeType(str.size()));
}
// GenericValue type traits
namespace internal {

template <typename T, typename Encoding = void, typename Allocator = void>
struct IsGenericValueImpl : FalseType {};

// select candidates according to nested encoding and allocator types
template <typename T> struct IsGenericValueImpl<T, typename Void<typename T::EncodingType>::Type, typename Void<typename T::AllocatorType>::Type>
    : IsBaseOf<GenericValue<typename T::EncodingType, typename T::AllocatorType>, T>::Type {};

// helper to match arbitrary GenericValue instantiations, including derived classes
template <typename T> struct IsGenericValue : IsGenericValueImpl<T>::Type {};

} // namespace internal


namespace internal {

template <typename ValueType, typename T>
struct TypeHelper {};

template<typename ValueType>
struct TypeHelper<ValueType, bool> {
    static bool Is(const ValueType& v) { return v.IsBool(); }
    static bool Get(const ValueType& v) { return v.GetBool(); }
    static ValueType& Set(ValueType& v, bool data) { return v.SetBool(data); }
    static ValueType& Set(ValueType& v, bool data, typename ValueType::AllocatorType&) { return v.SetBool(data); }
};

template<typename ValueType>
struct TypeHelper<ValueType, int> {
    static bool Is(const ValueType& v) { return v.IsInt(); }
    static int Get(const ValueType& v) { return v.GetInt(); }
    static ValueType& Set(ValueType& v, int data) { return v.SetInt(data); }
    static ValueType& Set(ValueType& v, int data, typename ValueType::AllocatorType&) { return v.SetInt(data); }
};

template<typename ValueType>
struct TypeHelper<ValueType, unsigned> {
    static bool Is(const ValueType& v) { return v.IsUint(); }
    static unsigned Get(const ValueType& v) { return v.GetUint(); }
    static ValueType& Set(ValueType& v, unsigned data) { return v.SetUint(data); }
    static ValueType& Set(ValueType& v, unsigned data, typename ValueType::AllocatorType&) { return v.SetUint(data); }
};

#ifdef _MSC_VER
CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(long) == sizeof(int));
template<typename ValueType>
struct TypeHelper<ValueType, long> {
    static bool Is(const ValueType& v) { return v.IsInt(); }
    static long Get(const ValueType& v) { return v.GetInt(); }
    static ValueType& Set(ValueType& v, long data) { return v.SetInt(data); }
    static ValueType& Set(ValueType& v, long data, typename ValueType::AllocatorType&) { return v.SetInt(data); }
};

CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(unsigned long) == sizeof(unsigned));
template<typename ValueType>
struct TypeHelper<ValueType, unsigned long> {
    static bool Is(const ValueType& v) { return v.IsUint(); }
    static unsigned long Get(const ValueType& v) { return v.GetUint(); }
    static ValueType& Set(ValueType& v, unsigned long data) { return v.SetUint(data); }
    static ValueType& Set(ValueType& v, unsigned long data, typename ValueType::AllocatorType&) { return v.SetUint(data); }
};
#endif

template<typename ValueType>
struct TypeHelper<ValueType, int64_t> {
    static bool Is(const ValueType& v) { return v.IsInt64(); }
    static int64_t Get(const ValueType& v) { return v.GetInt64(); }
    static ValueType& Set(ValueType& v, int64_t data) { return v.SetInt64(data); }
    static ValueType& Set(ValueType& v, int64_t data, typename ValueType::AllocatorType&) { return v.SetInt64(data); }
};

template<typename ValueType>
struct TypeHelper<ValueType, uint64_t> {
    static bool Is(const ValueType& v) { return v.IsUint64(); }
    static uint64_t Get(const ValueType& v) { return v.GetUint64(); }
    static ValueType& Set(ValueType& v, uint64_t data) { return v.SetUint64(data); }
    static ValueType& Set(ValueType& v, uint64_t data, typename ValueType::AllocatorType&) { return v.SetUint64(data); }
};

template<typename ValueType>
struct TypeHelper<ValueType, double> {
    static bool Is(const ValueType& v) { return v.IsDouble(); }
    static double Get(const ValueType& v) { return v.GetDouble(); }
    static ValueType& Set(ValueType& v, double data) { return v.SetDouble(data); }
    static ValueType& Set(ValueType& v, double data, typename ValueType::AllocatorType&) { return v.SetDouble(data); }
};

template<typename ValueType>
struct TypeHelper<ValueType, float> {
    static bool Is(const ValueType& v) { return v.IsFloat(); }
    static float Get(const ValueType& v) { return v.GetFloat(); }
    static ValueType& Set(ValueType& v, float data) { return v.SetFloat(data); }
    static ValueType& Set(ValueType& v, float data, typename ValueType::AllocatorType&) { return v.SetFloat(data); }
};

template<typename ValueType>
struct TypeHelper<ValueType, const typename ValueType::Ch*> {
    typedef const typename ValueType::Ch* StringType;
    static bool Is(const ValueType& v) { return v.IsString(); }
    static StringType Get(const ValueType& v) { return v.GetString(); }
    static ValueType& Set(ValueType& v, const StringType data) { return v.SetString(typename ValueType::StringRefType(data)); }
    static ValueType& Set(ValueType& v, const StringType data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }
};

#if CEREAL_RAPIDJSON_HAS_STDSTRING
template<typename ValueType>
struct TypeHelper<ValueType, std::basic_string<typename ValueType::Ch> > {
    typedef std::basic_string<typename ValueType::Ch> StringType;
    static bool Is(const ValueType& v) { return v.IsString(); }
    static StringType Get(const ValueType& v) { return StringType(v.GetString(), v.GetStringLength()); }
    static ValueType& Set(ValueType& v, const StringType& data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }
};
#endif

template<typename ValueType>
struct TypeHelper<ValueType, typename ValueType::Array> {
    typedef typename ValueType::Array ArrayType;
    static bool Is(const ValueType& v) { return v.IsArray(); }
    static ArrayType Get(ValueType& v) { return v.GetArray(); }
    static ValueType& Set(ValueType& v, ArrayType data) { return v = data; }
    static ValueType& Set(ValueType& v, ArrayType data, typename ValueType::AllocatorType&) { return v = data; }
};

template<typename ValueType>
struct TypeHelper<ValueType, typename ValueType::ConstArray> {
    typedef typename ValueType::ConstArray ArrayType;
    static bool Is(const ValueType& v) { return v.IsArray(); }
    static ArrayType Get(const ValueType& v) { return v.GetArray(); }
};

template<typename ValueType>
struct TypeHelper<ValueType, typename ValueType::Object> {
    typedef typename ValueType::Object ObjectType;
    static bool Is(const ValueType& v) { return v.IsObject(); }
    static ObjectType Get(ValueType& v) { return v.GetObject(); }
    static ValueType& Set(ValueType& v, ObjectType data) { return v = data; }
    static ValueType& Set(ValueType& v, ObjectType data, typename ValueType::AllocatorType&) { return v = data; }
};

template<typename ValueType>
struct TypeHelper<ValueType, typename ValueType::ConstObject> {
    typedef typename ValueType::ConstObject ObjectType;
    static bool Is(const ValueType& v) { return v.IsObject(); }
    static ObjectType Get(const ValueType& v) { return v.GetObject(); }
};

} // namespace internal
// Forward declarations
template <bool, typename> class GenericArray;
template <bool, typename> class GenericObject;

///////////////////////////////////////////////////////////////////////////////
// GenericValue
*/
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >
class GenericValue {
public:
    //! Name-value pair in an object.
    typedef GenericMember<Encoding, Allocator> Member;
    typedef Encoding EncodingType;                  //!< Encoding type from template parameter.
    typedef Allocator AllocatorType;                //!< Allocator type from template parameter.
    typedef typename Encoding::Ch Ch;               //!< Character type derived from Encoding.
    typedef GenericStringRef<Ch> StringRefType;     //!< Reference to a constant string
    typedef typename GenericMemberIterator<false,Encoding,Allocator>::Iterator MemberIterator;  //!< Member iterator for iterating in object.
    typedef typename GenericMemberIterator<true,Encoding,Allocator>::Iterator ConstMemberIterator;  //!< Constant member iterator for iterating in object.
    typedef GenericValue* ValueIterator;            //!< Value iterator for iterating in array.
    typedef const GenericValue* ConstValueIterator; //!< Constant value iterator for iterating in array.
    typedef GenericValue<Encoding, Allocator> ValueType;    //!< Value type of itself.
    typedef GenericArray<false, ValueType> Array;
    typedef GenericArray<true, ValueType> ConstArray;
    typedef GenericObject<false, ValueType> Object;
    typedef GenericObject<true, ValueType> ConstObject;

    //!@name Constructors and destructor.
    //@{

private:
    //! Copy constructor is not permitted.
    GenericValue(const GenericValue& rhs);

    //! Moving from a GenericDocument is not permitted.
    template <typename StackAllocator>
    GenericValue(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);

    //! Move assignment from a GenericDocument is not permitted.
    template <typename StackAllocator>
    GenericValue& operator=(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);
#endif

public:

    //! Constructor with JSON value type.
    /*! This creates a Value of specified type with default content.
    */
    explicit GenericValue(Type type) CEREAL_RAPIDJSON_NOEXCEPT : data_() {
        static const uint16_t defaultFlags[] = {
            kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kShortStringFlag,
            kNumberAnyFlag
        };
    */
    template <typename SourceAllocator>
    GenericValue(const GenericValue<Encoding,SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {
        switch (rhs.GetType()) {
        case kObjectType: {
#ifndef CEREAL_RAPIDJSON_DOXYGEN_RUNNING // hide SFINAE from Doxygen
    template <typename T>
    explicit GenericValue(T b, CEREAL_RAPIDJSON_ENABLEIF((internal::IsSame<bool, T>))) CEREAL_RAPIDJSON_NOEXCEPT  // See #472
#else
    explicit GenericValue(bool b) CEREAL_RAPIDJSON_NOEXCEPT
#endif
        : data_() {
            // safe-guard against failing SFINAE
    //! Constructor for int value.
    explicit GenericValue(int i) CEREAL_RAPIDJSON_NOEXCEPT : data_() {
        data_.n.i64 = i;
        data_.f.flags = (i >= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag;
    }
    //! Constructor for unsigned value.
    explicit GenericValue(unsigned u) CEREAL_RAPIDJSON_NOEXCEPT : data_() {
        data_.n.u64 = u;
        data_.f.flags = (u & 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag);
    }
    //! Constructor for int64_t value.
    explicit GenericValue(int64_t i64) CEREAL_RAPIDJSON_NOEXCEPT : data_() {
        data_.n.i64 = i64;
        data_.f.flags = kNumberInt64Flag;
        if (i64 >= 0) {
    //! Constructor for uint64_t value.
    explicit GenericValue(uint64_t u64) CEREAL_RAPIDJSON_NOEXCEPT : data_() {
        data_.n.u64 = u64;
        data_.f.flags = kNumberUint64Flag;
        if (!(u64 & CEREAL_RAPIDJSON_UINT64_C2(0x80000000, 0x00000000)))
    //! Constructor for double value.
    explicit GenericValue(double d) CEREAL_RAPIDJSON_NOEXCEPT : data_() { data_.n.d = d; data_.f.flags = kNumberDoubleFlag; }

    //! Constructor for float value.
    explicit GenericValue(float f) CEREAL_RAPIDJSON_NOEXCEPT : data_() { data_.n.d = static_cast<double>(f); data_.f.flags = kNumberDoubleFlag; }

    //! Constructor for constant string (i.e. do not make a copy of string)
    GenericValue(const Ch* s, SizeType length) CEREAL_RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(StringRef(s, length)); }
    //! Constructor for constant string (i.e. do not make a copy of string)
    explicit GenericValue(StringRefType s) CEREAL_RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(s); }

    //! Constructor for copy-string (i.e. do make a copy of string)
    GenericValue(const Ch* s, SizeType length, Allocator& allocator) : data_() { SetStringRaw(StringRef(s, length), allocator); }
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsPointer<T>), (GenericValue&))
    operator=(T value) {
        GenericValue v(value);
     */
    template <typename SourceAllocator>
    GenericValue& CopyFrom(const GenericValue<Encoding, SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {
        CEREAL_RAPIDJSON_ASSERT(static_cast<void*>(this) != static_cast<void const*>(&rhs));
        this->~GenericValue();
    */
    template <typename SourceAllocator>
    bool operator==(const GenericValue<Encoding, SourceAllocator>& rhs) const {
        typedef GenericValue<Encoding, SourceAllocator> RhsType;
        if (GetType() != rhs.GetType())
            return false;

    */
    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>,internal::IsGenericValue<T> >), (bool)) operator==(const T& rhs) const { return *this == GenericValue(rhs); }

    //! Not-equal-to operator
    /*! \return !(*this == rhs)
     */
    template <typename SourceAllocator>
    bool operator!=(const GenericValue<Encoding, SourceAllocator>& rhs) const { return !(*this == rhs); }

    //! Not-equal-to operator with const C-string pointer
     */
    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& rhs) const { return !(*this == rhs); }

    //! Equal-to operator with arbitrary types (symmetric version)
    /*! \return (rhs == lhs)
     */
    template <typename T> friend CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator==(const T& lhs, const GenericValue& rhs) { return rhs == lhs; }

    //! Not-Equal-to operator with arbitrary types (symmetric version)
    /*! \return !(rhs == lhs)
     */
    template <typename T> friend CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& lhs, const GenericValue& rhs) { return !(rhs == lhs); }
    //@}

    //!@name Type
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(GenericValue&)) operator[](T* name) {
        GenericValue n(StringRef(name));
        return (*this)[n];
    }
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(const GenericValue&)) operator[](T* name) const { return const_cast<GenericValue&>(*this)[name]; }

    //! Get a value from an object associated with the name.
    */
    template <typename SourceAllocator>
    GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) {
        MemberIterator member = FindMember(name);
        if (member != MemberEnd())
            // Use static buffer and placement-new to prevent destruction
            static char buffer[sizeof(GenericValue)];
            return *new (buffer) GenericValue();
        }
    }
    template <typename SourceAllocator>
    const GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this)[name]; }

#if CEREAL_RAPIDJSON_HAS_STDSTRING
    */
    template <typename SourceAllocator>
    bool HasMember(const GenericValue<Encoding, SourceAllocator>& name) const { return FindMember(name) != MemberEnd(); }

    //! Find member by name.
    */
    template <typename SourceAllocator>
    MemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) {
        CEREAL_RAPIDJSON_ASSERT(IsObject());
        CEREAL_RAPIDJSON_ASSERT(name.IsString());
    }
    template <typename SourceAllocator> ConstMemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this).FindMember(name); }

#if CEREAL_RAPIDJSON_HAS_STDSTRING
    //! Find member by string object name.
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
    AddMember(GenericValue& name, T value, Allocator& allocator) {
        GenericValue v(value);
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
    AddMember(StringRefType name, T value, Allocator& allocator) {
        GenericValue n(name);

    template <typename SourceAllocator>
    bool RemoveMember(const GenericValue<Encoding, SourceAllocator>& name) {
        MemberIterator m = FindMember(name);
        if (m != MemberEnd()) {

    template <typename SourceAllocator>
    bool EraseMember(const GenericValue<Encoding, SourceAllocator>& name) {
        MemberIterator m = FindMember(name);
        if (m != MemberEnd()) {
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
    PushBack(T value, Allocator& allocator) {
        GenericValue v(value);
    */
    template <typename T>
    bool Is() const { return internal::TypeHelper<ValueType, T>::Is(*this); }

    template <typename T>
    T Get() const { return internal::TypeHelper<ValueType, T>::Get(*this); }

    template <typename T>
    T Get() { return internal::TypeHelper<ValueType, T>::Get(*this); }

    template<typename T>
    ValueType& Set(const T& data) { return internal::TypeHelper<ValueType, T>::Set(*this, data); }

    template<typename T>
    ValueType& Set(const T& data, AllocatorType& allocator) { return internal::TypeHelper<ValueType, T>::Set(*this, data, allocator); }

    //@}
    */
    template <typename Handler>
    bool Accept(Handler& handler) const {
        switch(GetType()) {
        case kNullType:     return handler.Null();

private:
    template <typename, typename> friend class GenericValue;
    template <typename, typename, typename> friend class GenericDocument;

    enum {
        kBoolFlag       = 0x0008,
        kNumberFlag     = 0x0010,
        kIntFlag        = 0x0020,

    static const SizeType kDefaultArrayCapacity = 16;
    static const SizeType kDefaultObjectCapacity = 16;

    struct Flag {
#if CEREAL_RAPIDJSON_48BITPOINTER_OPTIMIZATION
        char payload[sizeof(SizeType) * 2 + 6];     // 2 x SizeType + lower 48-bit pointer
#elif CEREAL_RAPIDJSON_64BIT

    struct String {
        SizeType length;
        SizeType hashcode;  //!< reserved
        const Ch* str;
    // 13-chars strings for CEREAL_RAPIDJSON_48BITPOINTER_OPTIMIZATION=1 inline (for `UTF8`-encoded strings).
    struct ShortString {
        enum { MaxChars = sizeof(static_cast<Flag*>(0)->payload) / sizeof(Ch), MaxSize = MaxChars - 1, LenPos = MaxSize };
        Ch str[MaxChars];

        inline static bool Usable(SizeType len) { return                       (MaxSize >= len); }
#if CEREAL_RAPIDJSON_ENDIAN == CEREAL_RAPIDJSON_LITTLEENDIAN
        struct I {
            int i;
            char padding[4];
        }i;
        struct U {
            unsigned u;
            char padding2[4];
        }u;
#else
        struct I {
            char padding[4];
            int i;
        }i;
        struct U {
            char padding2[4];
            unsigned u;
        }u;

    struct ObjectData {
        SizeType size;
        SizeType capacity;
        Member* members;

    struct ArrayData {
        SizeType size;
        SizeType capacity;
        GenericValue* elements;

    template <typename SourceAllocator>
    bool StringEqual(const GenericValue<Encoding, SourceAllocator>& rhs) const {
        CEREAL_RAPIDJSON_ASSERT(IsString());
        CEREAL_RAPIDJSON_ASSERT(rhs.IsString());
//! GenericValue with UTF8 encoding
typedef GenericValue<UTF8<> > Value;

///////////////////////////////////////////////////////////////////////////////
// GenericDocument
*/
template <typename Encoding, typename Allocator = MemoryPoolAllocator<>, typename StackAllocator = CrtAllocator>
class GenericDocument : public GenericValue<Encoding, Allocator> {
public:
    typedef typename Encoding::Ch Ch;                       //!< Character type derived from Encoding.
    typedef GenericValue<Encoding, Allocator> ValueType;    //!< Value type of the document.
    typedef Allocator AllocatorType;                        //!< Allocator type from template parameter.

    //! Constructor
    /*! Creates an empty document of specified type.
    */
    explicit GenericDocument(Type type, Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
        GenericValue<Encoding, Allocator>(type),  allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
    {
        if (!allocator_)
    */
    template <typename Generator>
    GenericDocument& Populate(Generator& g) {
        ClearStackOnExit scope(*this);
        if (g(*this)) {
    */
    template <unsigned parseFlags, typename SourceEncoding, typename InputStream>
    GenericDocument& ParseStream(InputStream& is) {
        GenericReader<SourceEncoding, Encoding, StackAllocator> reader(
            stack_.HasAllocator() ? &stack_.GetAllocator() : 0);
    */
    template <unsigned parseFlags, typename InputStream>
    GenericDocument& ParseStream(InputStream& is) {
        return ParseStream<parseFlags, Encoding, InputStream>(is);
    }
    */
    template <typename InputStream>
    GenericDocument& ParseStream(InputStream& is) {
        return ParseStream<kParseDefaultFlags, Encoding, InputStream>(is);
    }
    */
    template <unsigned parseFlags>
    GenericDocument& ParseInsitu(Ch* str) {
        GenericInsituStringStream<Encoding> s(str);
        return ParseStream<parseFlags | kParseInsituFlag>(s);
    */
    template <unsigned parseFlags, typename SourceEncoding>
    GenericDocument& Parse(const typename SourceEncoding::Ch* str) {
        CEREAL_RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));
        GenericStringStream<SourceEncoding> s(str);
    */
    template <unsigned parseFlags>
    GenericDocument& Parse(const Ch* str) {
        return Parse<parseFlags, Encoding>(str);
    }

    template <unsigned parseFlags, typename SourceEncoding>
    GenericDocument& Parse(const typename SourceEncoding::Ch* str, size_t length) {
        CEREAL_RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));
        MemoryStream ms(reinterpret_cast<const char*>(str), length * sizeof(typename SourceEncoding::Ch));

    template <unsigned parseFlags>
    GenericDocument& Parse(const Ch* str, size_t length) {
        return Parse<parseFlags, Encoding>(str, length);
    }
#if CEREAL_RAPIDJSON_HAS_STDSTRING
    template <unsigned parseFlags, typename SourceEncoding>
    GenericDocument& Parse(const std::basic_string<typename SourceEncoding::Ch>& str) {
        // c_str() is constant complexity according to standard. Should be faster than Parse(const char*, size_t)
        return Parse<parseFlags, SourceEncoding>(str.c_str());

    template <unsigned parseFlags>
    GenericDocument& Parse(const std::basic_string<Ch>& str) {
        return Parse<parseFlags, Encoding>(str.c_str());
    }

private:
    // clear stack on any exit from ParseStream, e.g. due to exception
    struct ClearStackOnExit {
        explicit ClearStackOnExit(GenericDocument& d) : d_(d) {}
        ~ClearStackOnExit() { d_.ClearStack(); }
    private:
        ClearStackOnExit(const ClearStackOnExit&);
        ClearStackOnExit& operator=(const ClearStackOnExit&);
        GenericDocument& d_;
    // template <typename,typename,typename> friend class GenericReader; // for parsing
    template <typename, typename> friend class GenericValue; // for deep copying

public:
    // Implementation of Handler
    bool Null() { new (stack_.template Push<ValueType>()) ValueType(); return true; }
    bool Bool(bool b) { new (stack_.template Push<ValueType>()) ValueType(b); return true; }

private:
    //! Prohibit copying
    GenericDocument(const GenericDocument&);
    //! Prohibit assignment

    static const size_t kDefaultStackCapacity = 1024;
    Allocator* allocator_;
    Allocator* ownAllocator_;
    internal::Stack<StackAllocator> stack_;
//! GenericDocument with UTF8 encoding
typedef GenericDocument<UTF8<> > Document;

//! Helper class for accessing Value of array type.
/*!
*/
template <bool Const, typename ValueT>
class GenericArray {
public:
    typedef GenericArray<true, ValueT> ConstArray;
    typedef GenericArray<false, ValueT> Array;
    typedef ValueT PlainType;
    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
    typedef ValueType* ValueIterator;  // This may be const or non-const iterator
    typedef const ValueT* ConstValueIterator;
    typedef typename ValueType::AllocatorType AllocatorType;
    typedef typename ValueType::StringRefType StringRefType;

    template <typename, typename>
    friend class GenericValue;

    GenericArray(const GenericArray& rhs) : value_(rhs.value_) {}
    GenericArray PushBack(StringRefType value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (const GenericArray&)) PushBack(T value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
    GenericArray PopBack() const { value_.PopBack(); return *this; }
    ValueIterator Erase(ConstValueIterator pos) const { return value_.Erase(pos); }
    ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) const { return value_.Erase(first, last); }

private:
    GenericArray();
    GenericArray(ValueType& value) : value_(value) {}
    ValueType& value_;
*/
template <bool Const, typename ValueT>
class GenericObject {
public:
    typedef GenericObject<true, ValueT> ConstObject;
    typedef GenericObject<false, ValueT> Object;
    typedef ValueT PlainType;
    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
    typedef GenericMemberIterator<Const, typename ValueT::EncodingType, typename ValueT::AllocatorType> MemberIterator;  // This may be const or non-const iterator
    typedef GenericMemberIterator<true, typename ValueT::EncodingType, typename ValueT::AllocatorType> ConstMemberIterator;
    typedef typename ValueType::AllocatorType AllocatorType;
    typedef typename ValueType::StringRefType StringRefType;
    typedef typename ValueType::EncodingType EncodingType;
    typedef typename ValueType::Ch Ch;

    template <typename, typename>
    friend class GenericValue;

    GenericObject(const GenericObject& rhs) : value_(rhs.value_) {}
    bool ObjectEmpty() const { return value_.ObjectEmpty(); }
    template <typename T> ValueType& operator[](T* name) const { return value_[name]; }
    template <typename SourceAllocator> ValueType& operator[](const GenericValue<EncodingType, SourceAllocator>& name) const { return value_[name]; }
#if CEREAL_RAPIDJSON_HAS_STDSTRING
    ValueType& operator[](const std::basic_string<Ch>& name) const { return value_[name]; }
#endif
#endif
    template <typename SourceAllocator> bool HasMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.HasMember(name); }
    MemberIterator FindMember(const Ch* name) const { return value_.FindMember(name); }
    template <typename SourceAllocator> MemberIterator FindMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.FindMember(name); }
#if CEREAL_RAPIDJSON_HAS_STDSTRING
    MemberIterator FindMember(const std::basic_string<Ch>& name) const { return value_.FindMember(name); }
#endif
#endif
    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&)) AddMember(ValueType& name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS
    GenericObject AddMember(ValueType&& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(ValueType&& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(StringRefType name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericObject)) AddMember(StringRefType name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    void RemoveAllMembers() { value_.RemoveAllMembers(); }
    bool RemoveMember(const Ch* name) const { return value_.RemoveMember(name); }
#if CEREAL_RAPIDJSON_HAS_STDSTRING
#endif
    template <typename SourceAllocator> bool RemoveMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.RemoveMember(name); }
    MemberIterator RemoveMember(MemberIterator m) const { return value_.RemoveMember(m); }
    MemberIterator EraseMember(ConstMemberIterator pos) const { return value_.EraseMember(pos); }
    MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) const { return value_.EraseMember(first, last); }
#endif
    template <typename SourceAllocator> bool EraseMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.EraseMember(name); }

#if CEREAL_RAPIDJSON_HAS_CXX11_RANGE_FOR
    MemberIterator begin() const { return value_.MemberBegin(); }

private:
    GenericObject();
    GenericObject(ValueType& value) : value_(value) {}
    ValueType& value_;


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/encodedstream.h =====
//========================================
*/
template <typename Encoding, typename InputByteStream>
class EncodedInputStream {
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
public:
    typedef typename Encoding::Ch Ch;

    EncodedInputStream(InputByteStream& is) : is_(is) { 
        current_ = Encoding::TakeBOM(is_);

private:
    EncodedInputStream(const EncodedInputStream&);
    EncodedInputStream& operator=(const EncodedInputStream&);

//! Specialized for UTF8 MemoryStream.
template <>
class EncodedInputStream<UTF8<>, MemoryStream> {
public:
    typedef UTF8<>::Ch Ch;

    EncodedInputStream(MemoryStream& is) : is_(is) {
        if (static_cast<unsigned char>(is_.Peek()) == 0xEFu) is_.Take();

private:
    EncodedInputStream(const EncodedInputStream&);
    EncodedInputStream& operator=(const EncodedInputStream&);
};
*/
template <typename Encoding, typename OutputByteStream>
class EncodedOutputStream {
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
public:
    typedef typename Encoding::Ch Ch;

    EncodedOutputStream(OutputByteStream& os, bool putBOM = true) : os_(os) { 
        if (putBOM)

private:
    EncodedOutputStream(const EncodedOutputStream&);
    EncodedOutputStream& operator=(const EncodedOutputStream&);

*/
template <typename CharType, typename InputByteStream>
class AutoUTFInputStream {
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
public:
    typedef CharType Ch;

    //! Constructor.
    /*!
        DetectType();
        static const TakeFunc f[] = { CEREAL_RAPIDJSON_ENCODINGS_FUNC(Take) };
        takeFunc_ = f[type_];
        current_ = takeFunc_(*is_);
    }

private:
    AutoUTFInputStream(const AutoUTFInputStream&);
    AutoUTFInputStream& operator=(const AutoUTFInputStream&);


    typedef Ch (*TakeFunc)(InputByteStream& is);
    InputByteStream* is_;
    UTFType type_;
    Ch current_;
*/
template <typename CharType, typename OutputByteStream>
class AutoUTFOutputStream {
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
public:
    typedef CharType Ch;

    //! Constructor.
    /*!

        static const PutFunc f[] = { CEREAL_RAPIDJSON_ENCODINGS_FUNC(Put) };
        putFunc_ = f[type_];

        if (putBOM)

private:
    AutoUTFOutputStream(const AutoUTFOutputStream&);
    AutoUTFOutputStream& operator=(const AutoUTFOutputStream&);

    void PutBOM() { 
        typedef void (*PutBOMFunc)(OutputByteStream&);
        static const PutBOMFunc f[] = { CEREAL_RAPIDJSON_ENCODINGS_FUNC(PutBOM) };
        f[type_](*os_);
    }

    typedef void (*PutFunc)(OutputByteStream&, Ch);

    OutputByteStream* os_;
    UTFType type_;


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/encodings.h =====
//========================================

    enum { supportUnicode = 1 }; // or 0 if not supporting unicode

    //! \brief Encode a Unicode codepoint to an output stream.
    //! \param os Output stream.
    //! \param codepoint An unicode codepoint, ranging from 0x0 to 0x10FFFF inclusively.
    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint);

    //! \brief Decode a Unicode codepoint from an input stream.
    //! \param is Input stream.
    //! \return true if a valid codepoint can be decoded from the stream.
    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint);

    //! \brief Validate one Unicode codepoint from an encoded stream.
    //! \param is Input stream to obtain codepoint.
    //! \note This function just validating and copying the codepoint without actually decode it.
    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os);

    // The following functions are deal with byte streams.

    //! Take a character from input byte stream, skip BOM if exist.
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is);

    //! Take a character from input byte stream.
    template <typename InputByteStream>
    static Ch Take(InputByteStream& is);

    //! Put BOM to output byte stream.
    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os);

    //! Put a character to output byte stream.
    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, Ch c);
};
\endcode
*/
*/
template<typename CharType = char>
struct UTF8 {
    typedef CharType Ch;

    enum { supportUnicode = 1 };

    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        if (codepoint <= 0x7F) 
            os.Put(static_cast<Ch>(codepoint & 0xFF));
        else if (codepoint <= 0x7FF) {

    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        if (codepoint <= 0x7F) 
            PutUnsafe(os, static_cast<Ch>(codepoint & 0xFF));
        else if (codepoint <= 0x7FF) {

    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
#define CEREAL_RAPIDJSON_COPY() c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu)
#define CEREAL_RAPIDJSON_TRANS(mask) result &= ((GetRange(static_cast<unsigned char>(c)) & mask) != 0)
#define CEREAL_RAPIDJSON_TAIL() CEREAL_RAPIDJSON_COPY(); CEREAL_RAPIDJSON_TRANS(0x70)

    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
#define CEREAL_RAPIDJSON_COPY() os.Put(c = is.Take())
#define CEREAL_RAPIDJSON_TRANS(mask) result &= ((GetRange(static_cast<unsigned char>(c)) & mask) != 0)
#define CEREAL_RAPIDJSON_TAIL() CEREAL_RAPIDJSON_COPY(); CEREAL_RAPIDJSON_TRANS(0x70)

    static unsigned char GetRange(unsigned char c) {
        // Referring to DFA of http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
        // With new mapping 1 -> 0x10, 7 -> 0x20, 9 -> 0x40, such that AND operation can test multiple types.
        static const unsigned char type[] = {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        typename InputByteStream::Ch c = Take(is);
        if (static_cast<unsigned char>(c) != 0xEFu) return c;

    template <typename InputByteStream>
    static Ch Take(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        return static_cast<Ch>(is.Take());
    }

    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(0xEFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xBBu));

    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, Ch c) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(c));
    }
*/
template<typename CharType = wchar_t>
struct UTF16 {
    typedef CharType Ch;
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(Ch) >= 2);

    enum { supportUnicode = 1 };

    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputStream::Ch) >= 2);
        if (codepoint <= 0xFFFF) {
            CEREAL_RAPIDJSON_ASSERT(codepoint < 0xD800 || codepoint > 0xDFFF); // Code point itself cannot be surrogate pair 

    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputStream::Ch) >= 2);
        if (codepoint <= 0xFFFF) {
            CEREAL_RAPIDJSON_ASSERT(codepoint < 0xD800 || codepoint > 0xDFFF); // Code point itself cannot be surrogate pair 

    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputStream::Ch) >= 2);
        typename InputStream::Ch c = is.Take();
        if (c < 0xD800 || c > 0xDFFF) {

    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputStream::Ch) >= 2);
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputStream::Ch) >= 2);
        typename InputStream::Ch c;
//! UTF-16 little endian encoding.
template<typename CharType = wchar_t>
struct UTF16LE : UTF16<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        CharType c = Take(is);
        return static_cast<uint16_t>(c) == 0xFEFFu ? Take(is) : c;

    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        unsigned c = static_cast<uint8_t>(is.Take());
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 8;

    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFEu));

    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(static_cast<unsigned>(c) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((static_cast<unsigned>(c) >> 8) & 0xFFu));
//! UTF-16 big endian encoding.
template<typename CharType = wchar_t>
struct UTF16BE : UTF16<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        CharType c = Take(is);
        return static_cast<uint16_t>(c) == 0xFEFFu ? Take(is) : c;

    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        unsigned c = static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 8;
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take()));

    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFEu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFFu));

    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>((static_cast<unsigned>(c) >> 8) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(static_cast<unsigned>(c) & 0xFFu));
*/
template<typename CharType = unsigned>
struct UTF32 {
    typedef CharType Ch;
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(Ch) >= 4);

    enum { supportUnicode = 1 };

    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputStream::Ch) >= 4);
        CEREAL_RAPIDJSON_ASSERT(codepoint <= 0x10FFFF);
        os.Put(codepoint);

    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputStream::Ch) >= 4);
        CEREAL_RAPIDJSON_ASSERT(codepoint <= 0x10FFFF);
        PutUnsafe(os, codepoint);

    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputStream::Ch) >= 4);
        Ch c = is.Take();
        *codepoint = c;

    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputStream::Ch) >= 4);
        Ch c;
        os.Put(c = is.Take());
//! UTF-32 little endian enocoding.
template<typename CharType = unsigned>
struct UTF32LE : UTF32<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        CharType c = Take(is);
        return static_cast<uint32_t>(c) == 0x0000FEFFu ? Take(is) : c;

    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        unsigned c = static_cast<uint8_t>(is.Take());
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 8;

    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFEu));

    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(c & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 8) & 0xFFu));
//! UTF-32 big endian encoding.
template<typename CharType = unsigned>
struct UTF32BE : UTF32<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        CharType c = Take(is);
        return static_cast<uint32_t>(c) == 0x0000FEFFu ? Take(is) : c; 

    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        unsigned c = static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 24;
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 16;

    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(0x00u));
        os.Put(static_cast<typename OutputByteStream::Ch>(0x00u));

    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 24) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 16) & 0xFFu));
*/
template<typename CharType = char>
struct ASCII {
    typedef CharType Ch;

    enum { supportUnicode = 0 };

    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        CEREAL_RAPIDJSON_ASSERT(codepoint <= 0x7F);
        os.Put(static_cast<Ch>(codepoint & 0xFF));
    }

    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        CEREAL_RAPIDJSON_ASSERT(codepoint <= 0x7F);
        PutUnsafe(os, static_cast<Ch>(codepoint & 0xFF));
    }

    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
        uint8_t c = static_cast<uint8_t>(is.Take());
        *codepoint = c;
        return c <= 0X7F;

    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
        uint8_t c = static_cast<uint8_t>(is.Take());
        os.Put(static_cast<typename OutputStream::Ch>(c));
        return c <= 0x7F;

    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        uint8_t c = static_cast<uint8_t>(Take(is));
        return static_cast<Ch>(c);

    template <typename InputByteStream>
    static Ch Take(InputByteStream& is) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch) == 1);
        return static_cast<Ch>(is.Take());
    }

    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        (void)os;
    }

    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, Ch c) {
        CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch) == 1);
        os.Put(static_cast<typename OutputByteStream::Ch>(c));
    }
//! Runtime-specified UTF encoding type of a stream.
enum UTFType {
    kUTF8 = 0,      //!< UTF-8.
    kUTF16LE = 1,   //!< UTF-16 little endian.
    kUTF16BE = 2,   //!< UTF-16 big endian.
*/
template<typename CharType>
struct AutoUTF {
    typedef CharType Ch;

    enum { supportUnicode = 1 };

#define CEREAL_RAPIDJSON_ENCODINGS_FUNC(x) UTF8<Ch>::x, UTF16LE<Ch>::x, UTF16BE<Ch>::x, UTF32LE<Ch>::x, UTF32BE<Ch>::x

    template<typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE void Encode(OutputStream& os, unsigned codepoint) {
        typedef void (*EncodeFunc)(OutputStream&, unsigned);
        static const EncodeFunc f[] = { CEREAL_RAPIDJSON_ENCODINGS_FUNC(Encode) };
        (*f[os.GetType()])(os, codepoint);
    }

    template<typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        typedef void (*EncodeFunc)(OutputStream&, unsigned);
        static const EncodeFunc f[] = { CEREAL_RAPIDJSON_ENCODINGS_FUNC(EncodeUnsafe) };
        (*f[os.GetType()])(os, codepoint);
    }

    template <typename InputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool Decode(InputStream& is, unsigned* codepoint) {
        typedef bool (*DecodeFunc)(InputStream&, unsigned*);
        static const DecodeFunc f[] = { CEREAL_RAPIDJSON_ENCODINGS_FUNC(Decode) };
        return (*f[is.GetType()])(is, codepoint);
    }

    template <typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool Validate(InputStream& is, OutputStream& os) {
        typedef bool (*ValidateFunc)(InputStream&, OutputStream&);
        static const ValidateFunc f[] = { CEREAL_RAPIDJSON_ENCODINGS_FUNC(Validate) };
        return (*f[is.GetType()])(is, os);
    }

//! Encoding conversion.
template<typename SourceEncoding, typename TargetEncoding>
struct Transcoder {
    //! Take one Unicode codepoint from source encoding, convert it to target encoding and put it to the output stream.
    template<typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool Transcode(InputStream& is, OutputStream& os) {
        unsigned codepoint;
        if (!SourceEncoding::Decode(is, &codepoint))
            return false;

    template<typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool TranscodeUnsafe(InputStream& is, OutputStream& os) {
        unsigned codepoint;
        if (!SourceEncoding::Decode(is, &codepoint))
            return false;
    //! Validate one Unicode codepoint from an encoded stream.
    template<typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool Validate(InputStream& is, OutputStream& os) {
        return Transcode(is, os);   // Since source/target encoding is different, must transcode.
    }
};
// Forward declaration.
template<typename Stream>
inline void PutUnsafe(Stream& stream, typename Stream::Ch c);

//! Specialization of Transcoder with same source and target encoding.
template<typename Encoding>
struct Transcoder<Encoding, Encoding> {
    template<typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool Transcode(InputStream& is, OutputStream& os) {
        os.Put(is.Take());  // Just copy one code unit. This semantic is different from primary template class.
        return true;
    }
    
    template<typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool TranscodeUnsafe(InputStream& is, OutputStream& os) {
        PutUnsafe(os, is.Take());  // Just copy one code unit. This semantic is different from primary template class.
        return true;
    }
    
    template<typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE bool Validate(InputStream& is, OutputStream& os) {
        return Encoding::Validate(is, os);  // source/target encoding are the same
    }
};


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/error/en.h =====
//========================================


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/error/error.h =====
//========================================
*/
enum ParseErrorCode {
    kParseErrorNone = 0,                        //!< No error.

    kParseErrorDocumentEmpty,                   //!< The document is empty.
*/
struct ParseResult {
    //!! Unspecified boolean type
    typedef bool (ParseResult::*BooleanType)() const;
public:
    //! Default constructor, no error.
    ParseResult() : code_(kParseErrorNone), offset_(0) {}
    //! Constructor to set an error.

private:
    ParseErrorCode code_;
    size_t offset_;
};
*/
typedef const CEREAL_RAPIDJSON_ERROR_CHARTYPE* (*GetParseErrorFunc)(ParseErrorCode);

CEREAL_RAPIDJSON_NAMESPACE_END



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/filereadstream.h =====
//========================================
*/
class FileReadStream {
public:
    typedef char Ch;    //!< Character type (byte).

    //! Constructor.
    /*!

private:
    void Read() {
        if (current_ < bufferLast_)
            ++current_;


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/fwd.h =====
//========================================

template<typename CharType> struct UTF8;
template<typename CharType> struct UTF16;
template<typename CharType> struct UTF16BE;
template<typename CharType> struct UTF16LE;
template<typename CharType> struct UTF32;
template<typename CharType> struct UTF32BE;
template<typename CharType> struct UTF32LE;
template<typename CharType> struct ASCII;
template<typename CharType> struct AutoUTF;

template<typename SourceEncoding, typename TargetEncoding>
struct Transcoder;

// allocators.h

class CrtAllocator;

template <typename BaseAllocator>
class MemoryPoolAllocator;

// stream.h

template <typename Encoding>
struct GenericStringStream;

typedef GenericStringStream<UTF8<char> > StringStream;

template <typename Encoding>
struct GenericInsituStringStream;

typedef GenericInsituStringStream<UTF8<char> > InsituStringStream;

// stringbuffer.h

template <typename Encoding, typename Allocator>
class GenericStringBuffer;

typedef GenericStringBuffer<UTF8<char>, CrtAllocator> StringBuffer;

// filereadstream.h

class FileReadStream;

// filewritestream.h

class FileWriteStream;

// memorybuffer.h

template <typename Allocator>
struct GenericMemoryBuffer;

typedef GenericMemoryBuffer<CrtAllocator> MemoryBuffer;

// memorystream.h

struct MemoryStream;

// reader.h

template<typename Encoding, typename Derived>
struct BaseReaderHandler;

template <typename SourceEncoding, typename TargetEncoding, typename StackAllocator>
class GenericReader;

typedef GenericReader<UTF8<char>, UTF8<char>, CrtAllocator> Reader;

// writer.h

template<typename OutputStream, typename SourceEncoding, typename TargetEncoding, typename StackAllocator, unsigned writeFlags>
class Writer;

// prettywriter.h

template<typename OutputStream, typename SourceEncoding, typename TargetEncoding, typename StackAllocator, unsigned writeFlags>
class PrettyWriter;

// document.h

template <typename Encoding, typename Allocator> 
struct GenericMember;

template <bool Const, typename Encoding, typename Allocator>
class GenericMemberIterator;

template<typename CharType>
struct GenericStringRef;

template <typename Encoding, typename Allocator> 
class GenericValue;

typedef GenericValue<UTF8<char>, MemoryPoolAllocator<CrtAllocator> > Value;

template <typename Encoding, typename Allocator, typename StackAllocator>
class GenericDocument;

typedef GenericDocument<UTF8<char>, MemoryPoolAllocator<CrtAllocator>, CrtAllocator> Document;

// pointer.h

template <typename ValueType, typename Allocator>
class GenericPointer;

typedef GenericPointer<Value, CrtAllocator> Pointer;

// schema.h

template <typename SchemaDocumentType>
class IGenericRemoteSchemaDocumentProvider;

template <typename ValueT, typename Allocator>
class GenericSchemaDocument;

typedef GenericSchemaDocument<Value, CrtAllocator> SchemaDocument;
typedef IGenericRemoteSchemaDocumentProvider<SchemaDocument> IRemoteSchemaDocumentProvider;

template <
    typename SchemaDocumentType,
    typename OutputHandler,
    typename StateAllocator>
class GenericSchemaValidator;

typedef GenericSchemaValidator<SchemaDocument, BaseReaderHandler<UTF8<char>, void>, CrtAllocator> SchemaValidator;

CEREAL_RAPIDJSON_NAMESPACE_END



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/biginteger.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

class BigInteger {
public:
    typedef uint64_t Type;

    BigInteger(const BigInteger& rhs) : count_(rhs.count_) {
        std::memcpy(digits_, rhs.digits_, count_ * sizeof(Type));

    explicit BigInteger(uint64_t u) : count_(1) {
        digits_[0] = u;
    }

    BigInteger& MultiplyPow5(unsigned exp) {
        static const uint32_t kPow5[12] = {
            5,
            5 * 5,
            5 * 5 * 5,

private:
    void AppendDecimal64(const char* begin, const char* end) {
        uint64_t u = ParseUint64(begin, end);
        if (IsZero())

    static uint64_t ParseUint64(const char* begin, const char* end) {
        uint64_t r = 0;
        for (const char* p = begin; p != end; ++p) {
            CEREAL_RAPIDJSON_ASSERT(*p >= '0' && *p <= '9');
    // Assume a * b + k < 2^128
    static uint64_t MulAdd64(uint64_t a, uint64_t b, uint64_t k, uint64_t* outHigh) {
#if defined(_MSC_VER) && defined(_M_AMD64)
        uint64_t low = _umul128(a, b, outHigh) + k;
        if (low < k)

    static const size_t kBitCount = 3328;  // 64bit * 54 > 10^1000
    static const size_t kCapacity = kBitCount / sizeof(Type);
    static const size_t kTypeBit = sizeof(Type) * 8;

    Type digits_[kCapacity];
    size_t count_;


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/diyfp.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

#ifdef __GNUC__
CEREAL_RAPIDJSON_DIAG_PUSH

struct DiyFp {
    DiyFp() : f(), e() {}

    DiyFp(uint64_t fp, int exp) : f(fp), e(exp) {}

    explicit DiyFp(double d) {
        union {
            double d;
            uint64_t u64;
        const uint64_t be = (e == kDpDenormalExponent && (f & kDpHiddenBit) == 0) ? 0 :
            static_cast<uint64_t>(e + kDpExponentBias);
        u.u64 = (f & kDpSignificandMask) | (be << kDpSignificandSize);
        return u.d;
    }

    static const int kDiySignificandSize = 64;
    static const int kDpSignificandSize = 52;
    static const int kDpExponentBias = 0x3FF + kDpSignificandSize;
    static const int kDpMaxExponent = 0x7FF - kDpExponentBias;
    static const int kDpMinExponent = -kDpExponentBias;
    static const int kDpDenormalExponent = -kDpExponentBias + 1;
    static const uint64_t kDpExponentMask = CEREAL_RAPIDJSON_UINT64_C2(0x7FF00000, 0x00000000);
    static const uint64_t kDpSignificandMask = CEREAL_RAPIDJSON_UINT64_C2(0x000FFFFF, 0xFFFFFFFF);
    static const uint64_t kDpHiddenBit = CEREAL_RAPIDJSON_UINT64_C2(0x00100000, 0x00000000);

    uint64_t f;
    int e;
    // 10^-348, 10^-340, ..., 10^340
    static const uint64_t kCachedPowers_F[] = {
        CEREAL_RAPIDJSON_UINT64_C2(0xfa8fd5a0, 0x081c0288), CEREAL_RAPIDJSON_UINT64_C2(0xbaaee17f, 0xa23ebf76),
        CEREAL_RAPIDJSON_UINT64_C2(0x8b16fb20, 0x3055ac76), CEREAL_RAPIDJSON_UINT64_C2(0xcf42894a, 0x5dce35ea),
        CEREAL_RAPIDJSON_UINT64_C2(0x9a6bb0aa, 0x55653b2d), CEREAL_RAPIDJSON_UINT64_C2(0xe61acf03, 0x3d1a45df),
    };
    static const int16_t kCachedPowers_E[] = {
        -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,
        -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,
        -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/dtoa.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

#ifdef __GNUC__
CEREAL_RAPIDJSON_DIAG_PUSH
inline void DigitGen(const DiyFp& W, const DiyFp& Mp, uint64_t delta, char* buffer, int* len, int* K) {
    static const uint32_t kPow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };
    const DiyFp one(uint64_t(1) << -Mp.e, Mp.e);
    const DiyFp wp_w = Mp - W;
    uint32_t p1 = static_cast<uint32_t>(Mp.f >> -one.e);


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/ieee754.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

class Double {
public:
    Double() {}
    Double(double d) : d_(d) {}
    Double(uint64_t u) : u_(u) {}

    static int EffectiveSignificandSize(int order) {
        if (order >= -1021)
            return 53;
        else if (order <= -1074)

private:
    static const int kSignificandSize = 52;
    static const int kExponentBias = 0x3FF;
    static const int kDenormalExponent = 1 - kExponentBias;
    static const uint64_t kSignMask = CEREAL_RAPIDJSON_UINT64_C2(0x80000000, 0x00000000);
    static const uint64_t kExponentMask = CEREAL_RAPIDJSON_UINT64_C2(0x7FF00000, 0x00000000);
    static const uint64_t kSignificandMask = CEREAL_RAPIDJSON_UINT64_C2(0x000FFFFF, 0xFFFFFFFF);
    static const uint64_t kHiddenBit = CEREAL_RAPIDJSON_UINT64_C2(0x00100000, 0x00000000);

    union {
        double d_;


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/itoa.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

inline const char* GetDigitsLut() {
    static const char cDigitsLut[200] = {
        '0','0','0','1','0','2','0','3','0','4','0','5','0','6','0','7','0','8','0','9',
        '1','0','1','1','1','2','1','3','1','4','1','5','1','6','1','7','1','8','1','9',
        '2','0','2','1','2','2','2','3','2','4','2','5','2','6','2','7','2','8','2','9',


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/meta.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

// Helper to wrap/convert arbitrary types to void, useful for arbitrary type matching
template <typename T> struct Void { typedef void Type; };

///////////////////////////////////////////////////////////////////////////////
// BoolType, TrueType, FalseType
//
template <bool Cond> struct BoolType {
    static const bool Value = Cond;
    typedef BoolType Type;
};
typedef BoolType<true> TrueType;
typedef BoolType<false> FalseType;


///////////////////////////////////////////////////////////////////////////////

template <bool C> struct SelectIfImpl { template <typename T1, typename T2> struct Apply { typedef T1 Type; }; };
template <> struct SelectIfImpl<false> { template <typename T1, typename T2> struct Apply { typedef T2 Type; }; };
template <bool C, typename T1, typename T2> struct SelectIfCond : SelectIfImpl<C>::template Apply<T1,T2> {};
template <typename C, typename T1, typename T2> struct SelectIf : SelectIfCond<C::Value, T1, T2> {};

template <bool Cond1, bool Cond2> struct AndExprCond : FalseType {};
template <> struct AndExprCond<true, true> : TrueType {};
template <bool Cond1, bool Cond2> struct OrExprCond : TrueType {};
template <> struct OrExprCond<false, false> : FalseType {};

template <typename C> struct BoolExpr : SelectIf<C,TrueType,FalseType>::Type {};
template <typename C> struct NotExpr  : SelectIf<C,FalseType,TrueType>::Type {};
template <typename C1, typename C2> struct AndExpr : AndExprCond<C1::Value, C2::Value>::Type {};
template <typename C1, typename C2> struct OrExpr  : OrExprCond<C1::Value, C2::Value>::Type {};


///////////////////////////////////////////////////////////////////////////////
// AddConst, MaybeAddConst, RemoveConst
template <typename T> struct AddConst { typedef const T Type; };
template <bool Constify, typename T> struct MaybeAddConst : SelectIfCond<Constify, const T, T> {};
template <typename T> struct RemoveConst { typedef T Type; };
template <typename T> struct RemoveConst<const T> { typedef T Type; };


///////////////////////////////////////////////////////////////////////////////
//
template <typename T, typename U> struct IsSame : FalseType {};
template <typename T> struct IsSame<T, T> : TrueType {};

template <typename T> struct IsConst : FalseType {};
template <typename T> struct IsConst<const T> : TrueType {};

template <typename CT, typename T>
struct IsMoreConst
    : AndExpr<IsSame<typename RemoveConst<CT>::Type, typename RemoveConst<T>::Type>,
              BoolType<IsConst<CT>::Value >= IsConst<T>::Value> >::Type {};

template <typename T> struct IsPointer : FalseType {};
template <typename T> struct IsPointer<T*> : TrueType {};

///////////////////////////////////////////////////////////////////////////////
// IsBaseOf

template <typename B, typename D> struct IsBaseOf
    : BoolType< ::std::is_base_of<B,D>::value> {};

#else // simplified version adopted from Boost

template<typename B, typename D> struct IsBaseOfImpl {
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(B) != 0);
    CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(D) != 0);

    typedef char (&Yes)[1];
    typedef char (&No) [2];

    template <typename T>
    static Yes Check(const D*, T);
    static No  Check(const B*, int);

    struct Host {
        operator const B*() const;
        operator const D*();
    };

    enum { Value = (sizeof(Check(Host(), 0)) == sizeof(Yes)) };
};

template <typename B, typename D> struct IsBaseOf
    : OrExpr<IsSame<B, D>, BoolExpr<IsBaseOfImpl<B, D> > >::Type {};

#endif // CEREAL_RAPIDJSON_HAS_CXX11_TYPETRAITS
//
template <bool Condition, typename T = void> struct EnableIfCond  { typedef T Type; };
template <typename T> struct EnableIfCond<false, T> { /* empty */ };

template <bool Condition, typename T = void> struct DisableIfCond { typedef T Type; };
template <typename T> struct DisableIfCond<true, T> { /* empty */ };

template <typename Condition, typename T = void>
struct EnableIf : EnableIfCond<Condition::Value, T> {};

template <typename Condition, typename T = void>
struct DisableIf : DisableIfCond<Condition::Value, T> {};

// SFINAE helpers
struct SfinaeTag {};
template <typename T> struct RemoveSfinaeTag;
template <typename T> struct RemoveSfinaeTag<SfinaeTag&(*)(T)> { typedef T Type; };

#define CEREAL_RAPIDJSON_REMOVEFPTR_(type) \
    typename ::CEREAL_RAPIDJSON_NAMESPACE::internal::RemoveSfinaeTag \


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/pow10.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

//! Computes integer powers of 10 in double (10.0^n).
/*! This function uses lookup table for fast and accurate results.
inline double Pow10(int n) {
    static const double e[] = { // 1e-0...1e308: 309 * 8 bytes = 2472 bytes
        1e+0,  
        1e+1,  1e+2,  1e+3,  1e+4,  1e+5,  1e+6,  1e+7,  1e+8,  1e+9,  1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 
        1e+21, 1e+22, 1e+23, 1e+24, 1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31, 1e+32, 1e+33, 1e+34, 1e+35, 1e+36, 1e+37, 1e+38, 1e+39, 1e+40,


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/regex.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

///////////////////////////////////////////////////////////////////////////////
// DecodedStream

template <typename SourceStream, typename Encoding>
class DecodedStream {
public:
    DecodedStream(SourceStream& ss) : ss_(ss), codepoint_() { Decode(); }
    unsigned Peek() { return codepoint_; }
    unsigned Take() {

private:
    void Decode() {
        if (!Encoding::Decode(ss_, &codepoint_))
            codepoint_ = 0;

static const SizeType kRegexInvalidState = ~SizeType(0);  //!< Represents an invalid index in GenericRegex::State::out, out1
static const SizeType kRegexInvalidRange = ~SizeType(0);

template <typename Encoding, typename Allocator>
class GenericRegexSearch;

//! Regular expression engine with subset of ECMAscript grammar.
/*!
*/
template <typename Encoding, typename Allocator = CrtAllocator>
class GenericRegex {
public:
    typedef Encoding EncodingType;
    typedef typename Encoding::Ch Ch;
    template <typename, typename> friend class GenericRegexSearch;

    GenericRegex(const Ch* source, Allocator* allocator = 0) : 
        ownAllocator_(allocator ? 0 : CEREAL_RAPIDJSON_NEW(Allocator)()), allocator_(allocator ? allocator : ownAllocator_), 

private:
    enum Operator {
        kZeroOrOne,
        kZeroOrMore,
        kOneOrMore,

    static const unsigned kAnyCharacterClass = 0xFFFFFFFF;   //!< For '.'
    static const unsigned kRangeCharacterClass = 0xFFFFFFFE;
    static const unsigned kRangeNegationFlag = 0x80000000;

    struct Range {
        unsigned start; // 
        unsigned end;
        SizeType next;

    struct State {
        SizeType out;     //!< Equals to kInvalid for matching state
        SizeType out1;    //!< Equals to non-kInvalid for split
        SizeType rangeStart;

    struct Frag {
        Frag(SizeType s, SizeType o, SizeType m) : start(s), out(o), minIndex(m) {}
        SizeType start;
        SizeType out; //!< link-list of all output states

    template <typename InputStream>
    void Parse(DecodedStream<InputStream, Encoding>& ds) {
        Stack<Allocator> operandStack(allocator_, 256);    // Frag
        Stack<Allocator> operatorStack(allocator_, 256);   // Operator

    static SizeType Min(SizeType a, SizeType b) { return a < b ? a : b; }

    void CloneTopOperand(Stack<Allocator>& operandStack) {
        const Frag src = *operandStack.template Top<Frag>(); // Copy constructor to prevent invalidation

    template <typename InputStream>
    bool ParseUnsigned(DecodedStream<InputStream, Encoding>& ds, unsigned* u) {
        unsigned r = 0;
        if (ds.Peek() < '0' || ds.Peek() > '9')

    template <typename InputStream>
    bool ParseRange(DecodedStream<InputStream, Encoding>& ds, SizeType* range) {
        bool isBegin = true;
        bool negate = false;

    template <typename InputStream>
    bool CharacterEscape(DecodedStream<InputStream, Encoding>& ds, unsigned* escapedCodepoint) {
        unsigned codepoint;
        switch (codepoint = ds.Take()) {

    static const unsigned kInfinityQuantifier = ~0u;

    // For SearchWithAnchoring()
    bool anchorBegin_;

template <typename RegexType, typename Allocator = CrtAllocator>
class GenericRegexSearch {
public:
    typedef typename RegexType::EncodingType Encoding;
    typedef typename Encoding::Ch Ch;

    GenericRegexSearch(const RegexType& regex, Allocator* allocator = 0) : 
        regex_(regex), allocator_(allocator), ownAllocator_(0),

    template <typename InputStream>
    bool Match(InputStream& is) {
        return SearchWithAnchoring(is, true, true);
    }

    template <typename InputStream>
    bool Search(InputStream& is) {
        return SearchWithAnchoring(is, regex_.anchorBegin_, regex_.anchorEnd_);
    }

private:
    typedef typename RegexType::State State;
    typedef typename RegexType::Range Range;

    template <typename InputStream>
    bool SearchWithAnchoring(InputStream& is, bool anchorBegin, bool anchorEnd) {
        DecodedStream<InputStream, Encoding> ds(is);


typedef GenericRegex<UTF8<> > Regex;
typedef GenericRegexSearch<Regex> RegexSearch;

} // namespace internal
CEREAL_RAPIDJSON_NAMESPACE_END


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/stack.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

///////////////////////////////////////////////////////////////////////////////
// Stack
*/
template <typename Allocator>
class Stack {
public:
    // Optimization note: Do not allocate memory for stack_ in constructor.
    // Do it lazily when first Push() -> Expand() -> Resize().
    Stack(Allocator* allocator, size_t stackCapacity) : allocator_(allocator), ownAllocator_(0), stack_(0), stackTop_(0), stackEnd_(0), initialCapacity_(stackCapacity) {
    // Expansion is run very infrequently, so it is moved to another (probably non-inline) function.
    template<typename T>
    CEREAL_RAPIDJSON_FORCEINLINE void Reserve(size_t count = 1) {
         // Expand the stack if needed
        if (CEREAL_RAPIDJSON_UNLIKELY(static_cast<std::ptrdiff_t>(sizeof(T) * count) > (stackEnd_ - stackTop_)))

    template<typename T>
    CEREAL_RAPIDJSON_FORCEINLINE T* Push(size_t count = 1) {
        Reserve<T>(count);
        return PushUnsafe<T>(count);

    template<typename T>
    CEREAL_RAPIDJSON_FORCEINLINE T* PushUnsafe(size_t count = 1) {
        CEREAL_RAPIDJSON_ASSERT(stackTop_);
        CEREAL_RAPIDJSON_ASSERT(static_cast<std::ptrdiff_t>(sizeof(T) * count) <= (stackEnd_ - stackTop_));

    template<typename T>
    T* Pop(size_t count) {
        CEREAL_RAPIDJSON_ASSERT(GetSize() >= count * sizeof(T));
        stackTop_ -= count * sizeof(T);

    template<typename T>
    T* Top() { 
        CEREAL_RAPIDJSON_ASSERT(GetSize() >= sizeof(T));
        return reinterpret_cast<T*>(stackTop_ - sizeof(T));

    template<typename T>
    const T* Top() const {
        CEREAL_RAPIDJSON_ASSERT(GetSize() >= sizeof(T));
        return reinterpret_cast<T*>(stackTop_ - sizeof(T));

    template<typename T>
    T* End() { return reinterpret_cast<T*>(stackTop_); }

    template<typename T>
    const T* End() const { return reinterpret_cast<T*>(stackTop_); }

    template<typename T>
    T* Bottom() { return reinterpret_cast<T*>(stack_); }

    template<typename T>
    const T* Bottom() const { return reinterpret_cast<T*>(stack_); }

    bool HasAllocator() const {

private:
    template<typename T>
    void Expand(size_t count) {
        // Only expand the capacity if the current stack exists. Otherwise just create a stack with initial capacity.
        size_t newCapacity;


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/strfunc.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

//! Custom strlen() which works on different character types.
/*! \tparam Ch Character type (e.g. char, wchar_t, short)
*/
template <typename Ch>
inline SizeType StrLen(const Ch* s) {
    CEREAL_RAPIDJSON_ASSERT(s != 0);
    const Ch* p = s;

template <>
inline SizeType StrLen(const char* s) {
    return SizeType(std::strlen(s));
}

template <>
inline SizeType StrLen(const wchar_t* s) {
    return SizeType(std::wcslen(s));
}
//! Returns number of code points in a encoded string.
template<typename Encoding>
bool CountStringCodePoint(const typename Encoding::Ch* s, SizeType length, SizeType* outCount) {
    CEREAL_RAPIDJSON_ASSERT(s != 0);
    CEREAL_RAPIDJSON_ASSERT(outCount != 0);


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/strtod.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

inline double FastPath(double significand, int exp) {
    if (exp < -308)

template <typename T>
inline T Min3(T a, T b, T c) {
    T m = a;
    if (m > b) m = b;
    if (actualExp != dExp) {
        static const DiyFp kPow10[] = {
            DiyFp(CEREAL_RAPIDJSON_UINT64_C2(0xa0000000, 0x00000000), -60),  // 10^1
            DiyFp(CEREAL_RAPIDJSON_UINT64_C2(0xc8000000, 0x00000000), -57),  // 10^2
            DiyFp(CEREAL_RAPIDJSON_UINT64_C2(0xfa000000, 0x00000000), -54),  // 10^3


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/internal/swap.h =====
//========================================
CEREAL_RAPIDJSON_NAMESPACE_BEGIN
namespace internal {

//! Custom swap() to avoid dependency on C++ <algorithm> header
/*! \tparam T Type of the arguments to swap, should be instantiated with primitive C++ types only.
*/
template <typename T>
inline void Swap(T& a, T& b) CEREAL_RAPIDJSON_NOEXCEPT {
    T tmp = a;
        a = b;


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/istreamwrapper.h =====
//========================================
   
template <typename StreamType>
class BasicIStreamWrapper {
public:
    typedef typename StreamType::char_type Ch;

    //! Constructor.
    /*!

private:
    BasicIStreamWrapper();
    BasicIStreamWrapper(const BasicIStreamWrapper&);
    BasicIStreamWrapper& operator=(const BasicIStreamWrapper&);

typedef BasicIStreamWrapper<std::istream> IStreamWrapper;
typedef BasicIStreamWrapper<std::wistream> WIStreamWrapper;

#if defined(__clang__) || defined(_MSC_VER)
CEREAL_RAPIDJSON_DIAG_POP


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/memorybuffer.h =====
//========================================
*/
template <typename Allocator = CrtAllocator>
struct GenericMemoryBuffer {
    typedef char Ch; // byte

    GenericMemoryBuffer(Allocator* allocator = 0, size_t capacity = kDefaultCapacity) : stack_(allocator, capacity) {}


    static const size_t kDefaultCapacity = 256;
    mutable internal::Stack<Allocator> stack_;
};

typedef GenericMemoryBuffer<> MemoryBuffer;

//! Implement specialized version of PutN() with memset() for better performance.
template<>
inline void PutN(MemoryBuffer& memoryBuffer, char c, size_t n) {
    std::memset(memoryBuffer.stack_.Push<char>(n), c, n * sizeof(c));
}


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/memorystream.h =====
//========================================
*/
struct MemoryStream {
    typedef char Ch; // byte

    MemoryStream(const Ch *src, size_t size) : src_(src), begin_(src), end_(src + size), size_(size) {}



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/msinttypes/inttypes.h =====
//========================================

typedef struct {
   intmax_t quot;
   intmax_t rem;
} imaxdiv_t;
#ifdef STATIC_IMAXDIV // [
static
#else // STATIC_IMAXDIV ][
_inline
#endif // STATIC_IMAXDIV ]


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/msinttypes/stdint.h =====
//========================================
#if (_MSC_VER < 1300)
   typedef signed char       int8_t;
   typedef signed short      int16_t;
   typedef signed int        int32_t;
   typedef unsigned char     uint8_t;
   typedef unsigned short    uint16_t;
   typedef unsigned int      uint32_t;
#else
   typedef signed __int8     int8_t;
   typedef signed __int16    int16_t;
   typedef signed __int32    int32_t;
   typedef unsigned __int8   uint8_t;
   typedef unsigned __int16  uint16_t;
   typedef unsigned __int32  uint32_t;
#endif
typedef signed __int64       int64_t;
typedef unsigned __int64     uint64_t;


// 7.18.1.2 Minimum-width integer types
typedef int8_t    int_least8_t;
typedef int16_t   int_least16_t;
typedef int32_t   int_least32_t;
typedef int64_t   int_least64_t;
typedef uint8_t   uint_least8_t;
typedef uint16_t  uint_least16_t;
typedef uint32_t  uint_least32_t;
typedef uint64_t  uint_least64_t;

// 7.18.1.3 Fastest minimum-width integer types
typedef int8_t    int_fast8_t;
typedef int16_t   int_fast16_t;
typedef int32_t   int_fast32_t;
typedef int64_t   int_fast64_t;
typedef uint8_t   uint_fast8_t;
typedef uint16_t  uint_fast16_t;
typedef uint32_t  uint_fast32_t;
typedef uint64_t  uint_fast64_t;

// 7.18.1.4 Integer types capable of holding object pointers
#ifdef _WIN64 // [
   typedef signed __int64    intptr_t;
   typedef unsigned __int64  uintptr_t;
#else // _WIN64 ][
   typedef _W64 signed int   intptr_t;
   typedef _W64 unsigned int uintptr_t;
#endif // _WIN64 ]

// 7.18.1.5 Greatest-width integer types
typedef int64_t   intmax_t;
typedef uint64_t  uintmax_t;


// 7.18.2 Limits of specified-width integer types


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/ostreamwrapper.h =====
//========================================
   
template <typename StreamType>
class BasicOStreamWrapper {
public:
    typedef typename StreamType::char_type Ch;
    BasicOStreamWrapper(StreamType& stream) : stream_(stream) {}

    void Put(Ch c) {

private:
    BasicOStreamWrapper(const BasicOStreamWrapper&);
    BasicOStreamWrapper& operator=(const BasicOStreamWrapper&);


typedef BasicOStreamWrapper<std::ostream> OStreamWrapper;
typedef BasicOStreamWrapper<std::wostream> WOStreamWrapper;

#ifdef __clang__
CEREAL_RAPIDJSON_DIAG_POP


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/pointer.h =====
//========================================

static const SizeType kPointerInvalidIndex = ~SizeType(0);  //!< Represents an invalid index in GenericPointer::Token

//! Error code of parsing.
/*! \ingroup CEREAL_RAPIDJSON_ERRORS
*/
enum PointerParseErrorCode {
    kPointerParseErrorNone = 0,                     //!< The parse is successful

    kPointerParseErrorTokenMustBeginWithSolidus,    //!< A token must begin with a '/'
*/
template <typename ValueType, typename Allocator = CrtAllocator>
class GenericPointer {
public:
    typedef typename ValueType::EncodingType EncodingType;  //!< Encoding type from Value
    typedef typename ValueType::Ch Ch;                      //!< Character type from Value

    //! A token is the basic units of internal representation.
    /*!
    */
    struct Token {
        const Ch* name;             //!< Name of the token. It has null character at the end but it can contain null character.
        SizeType length;            //!< Length of the name.
        SizeType index;             //!< A valid array index, if it is not equal to kPointerInvalidIndex.
    */
    explicit GenericPointer(const Ch* source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
        Parse(source, internal::StrLen(source));
    }

    */
    explicit GenericPointer(const std::basic_string<Ch>& source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
        Parse(source.c_str(), source.size());
    }
#endif

        static const Pointer::Token kTokens[] = { NAME("foo"), INDEX(123) };
        static const Pointer p(kTokens, sizeof(kTokens) / sizeof(kTokens[0]));
        // Equivalent to static const Pointer p("/foo/123");

        #undef NAME
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >), (GenericPointer))
    Append(T* name, Allocator* allocator = 0) const {
        return Append(name, internal::StrLen(name), allocator);
    */
    template<typename OutputStream>
    bool Stringify(OutputStream& os) const {
        return Stringify<false, OutputStream>(os);
    }
    */
    template<typename OutputStream>
    bool StringifyUriFragment(OutputStream& os) const {
        return Stringify<true, OutputStream>(os);
    }
    */
    template <typename stackAllocator>
    ValueType& Create(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, bool* alreadyExist = 0) const {
        return Create(document, document.GetAllocator(), alreadyExist);
    }
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
    GetWithDefault(ValueType& root, T defaultValue, typename ValueType::AllocatorType& allocator) const {
        return GetWithDefault(root, ValueType(defaultValue).Move(), allocator);
    //! Query a value in a document with default value.
    template <typename stackAllocator>
    ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const ValueType& defaultValue) const {
        return GetWithDefault(document, defaultValue, document.GetAllocator());
    }
    //! Query a value in a document with default null-terminated string.
    template <typename stackAllocator>
    ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const Ch* defaultValue) const {
        return GetWithDefault(document, defaultValue, document.GetAllocator());
    }
    //! Query a value in a document with default std::basic_string.
    template <typename stackAllocator>
    ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const std::basic_string<Ch>& defaultValue) const {
        return GetWithDefault(document, defaultValue, document.GetAllocator());
    }
    */
    template <typename T, typename stackAllocator>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
    GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, T defaultValue) const {
        return GetWithDefault(document, defaultValue, document.GetAllocator());
    */
    template <typename T>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
    Set(ValueType& root, T value, typename ValueType::AllocatorType& allocator) const {
        return Create(root, allocator) = ValueType(value).Move();
    //! Set a value in a document, with move semantics.
    template <typename stackAllocator>
    ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, ValueType& value) const {
        return Create(document) = value;
    }
    //! Set a value in a document, with copy semantics.
    template <typename stackAllocator>
    ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const ValueType& value) const {
        return Create(document).CopyFrom(value, document.GetAllocator());
    }
    //! Set a null-terminated string in a document.
    template <typename stackAllocator>
    ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const Ch* value) const {
        return Create(document) = ValueType(value, document.GetAllocator()).Move();
    }
    //! Sets a std::basic_string in a document.
    template <typename stackAllocator>
    ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const std::basic_string<Ch>& value) const {
        return Create(document) = ValueType(value, document.GetAllocator()).Move();
    }
    */
    template <typename T, typename stackAllocator>
    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
        Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, T value) const {
            return Create(document) = value;
    //! Swap a value with a value in a document.
    template <typename stackAllocator>
    ValueType& Swap(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, ValueType& value) const {
        return Create(document).Swap(value);
    }

private:
    //! Clone the content from rhs to this.
    /*!
        \param rhs Source pointer.
    */
    template<bool uriFragment, typename OutputStream>
    bool Stringify(OutputStream& os) const {
        CEREAL_RAPIDJSON_ASSERT(IsValid());

    */
    class PercentDecodeStream {
    public:
        typedef typename ValueType::Ch Ch;

        //! Constructor
        /*!

    private:
        const Ch* src_;     //!< Current read position.
        const Ch* head_;    //!< Original head of the string.
        const Ch* end_;     //!< Past-the-end position.
    //! A helper stream to encode character (UTF-8 code unit) into percent-encoded sequence.
    template <typename OutputStream>
    class PercentEncodeStream {
    public:
        PercentEncodeStream(OutputStream& os) : os_(os) {}
        void Put(char c) { // UTF-8 must be byte
            unsigned char u = static_cast<unsigned char>(c);
            static const char hexDigits[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
            os_.Put('%');
            os_.Put(static_cast<typename OutputStream::Ch>(hexDigits[u >> 4]));
            os_.Put(static_cast<typename OutputStream::Ch>(hexDigits[u & 15]));
        }
    private:
        OutputStream& os_;
    };

//! GenericPointer for Value (UTF-8, default allocator).
typedef GenericPointer<Value> Pointer;

//!@name Helper functions for GenericPointer
//@{

template <typename T>
typename T::ValueType& CreateValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::AllocatorType& a) {
    return pointer.Create(root, a);
}

template <typename T, typename CharType, size_t N>
typename T::ValueType& CreateValueByPointer(T& root, const CharType(&source)[N], typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Create(root, a);
}

template <typename DocumentType>
typename DocumentType::ValueType& CreateValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer) {
    return pointer.Create(document);
}

template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& CreateValueByPointer(DocumentType& document, const CharType(&source)[N]) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Create(document);
}

template <typename T>
typename T::ValueType* GetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, size_t* unresolvedTokenIndex = 0) {
    return pointer.Get(root, unresolvedTokenIndex);
}

template <typename T>
const typename T::ValueType* GetValueByPointer(const T& root, const GenericPointer<typename T::ValueType>& pointer, size_t* unresolvedTokenIndex = 0) {
    return pointer.Get(root, unresolvedTokenIndex);
}

template <typename T, typename CharType, size_t N>
typename T::ValueType* GetValueByPointer(T& root, const CharType (&source)[N], size_t* unresolvedTokenIndex = 0) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Get(root, unresolvedTokenIndex);
}

template <typename T, typename CharType, size_t N>
const typename T::ValueType* GetValueByPointer(const T& root, const CharType(&source)[N], size_t* unresolvedTokenIndex = 0) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Get(root, unresolvedTokenIndex);
}

template <typename T>
typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::ValueType& defaultValue, typename T::AllocatorType& a) {
    return pointer.GetWithDefault(root, defaultValue, a);
}

template <typename T>
typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::Ch* defaultValue, typename T::AllocatorType& a) {
    return pointer.GetWithDefault(root, defaultValue, a);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename T>
typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const std::basic_string<typename T::Ch>& defaultValue, typename T::AllocatorType& a) {
    return pointer.GetWithDefault(root, defaultValue, a);
}

template <typename T, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, T2 defaultValue, typename T::AllocatorType& a) {
    return pointer.GetWithDefault(root, defaultValue, a);

template <typename T, typename CharType, size_t N>
typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const typename T::ValueType& defaultValue, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
}

template <typename T, typename CharType, size_t N>
typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const typename T::Ch* defaultValue, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename T, typename CharType, size_t N>
typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const std::basic_string<typename T::Ch>& defaultValue, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
}

template <typename T, typename CharType, size_t N, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
GetValueByPointerWithDefault(T& root, const CharType(&source)[N], T2 defaultValue, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);

template <typename DocumentType>
typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::ValueType& defaultValue) {
    return pointer.GetWithDefault(document, defaultValue);
}

template <typename DocumentType>
typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::Ch* defaultValue) {
    return pointer.GetWithDefault(document, defaultValue);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename DocumentType>
typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const std::basic_string<typename DocumentType::Ch>& defaultValue) {
    return pointer.GetWithDefault(document, defaultValue);
}

template <typename DocumentType, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, T2 defaultValue) {
    return pointer.GetWithDefault(document, defaultValue);

template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const typename DocumentType::ValueType& defaultValue) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
}

template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const typename DocumentType::Ch* defaultValue) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const std::basic_string<typename DocumentType::Ch>& defaultValue) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
}

template <typename DocumentType, typename CharType, size_t N, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], T2 defaultValue) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);

template <typename T>
typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::ValueType& value, typename T::AllocatorType& a) {
    return pointer.Set(root, value, a);
}

template <typename T>
typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::ValueType& value, typename T::AllocatorType& a) {
    return pointer.Set(root, value, a);
}

template <typename T>
typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::Ch* value, typename T::AllocatorType& a) {
    return pointer.Set(root, value, a);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename T>
typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const std::basic_string<typename T::Ch>& value, typename T::AllocatorType& a) {
    return pointer.Set(root, value, a);
}

template <typename T, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, T2 value, typename T::AllocatorType& a) {
    return pointer.Set(root, value, a);

template <typename T, typename CharType, size_t N>
typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], typename T::ValueType& value, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
}

template <typename T, typename CharType, size_t N>
typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const typename T::ValueType& value, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
}

template <typename T, typename CharType, size_t N>
typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const typename T::Ch* value, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename T, typename CharType, size_t N>
typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const std::basic_string<typename T::Ch>& value, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
}

template <typename T, typename CharType, size_t N, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
SetValueByPointer(T& root, const CharType(&source)[N], T2 value, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);

template <typename DocumentType>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, typename DocumentType::ValueType& value) {
    return pointer.Set(document, value);
}

template <typename DocumentType>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::ValueType& value) {
    return pointer.Set(document, value);
}

template <typename DocumentType>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::Ch* value) {
    return pointer.Set(document, value);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename DocumentType>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const std::basic_string<typename DocumentType::Ch>& value) {
    return pointer.Set(document, value);
}

template <typename DocumentType, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, T2 value) {
    return pointer.Set(document, value);

template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], typename DocumentType::ValueType& value) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
}

template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const typename DocumentType::ValueType& value) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
}

template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const typename DocumentType::Ch* value) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
}
#if CEREAL_RAPIDJSON_HAS_STDSTRING
template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const std::basic_string<typename DocumentType::Ch>& value) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
}

template <typename DocumentType, typename CharType, size_t N, typename T2>
CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
SetValueByPointer(DocumentType& document, const CharType(&source)[N], T2 value) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);

template <typename T>
typename T::ValueType& SwapValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::ValueType& value, typename T::AllocatorType& a) {
    return pointer.Swap(root, value, a);
}

template <typename T, typename CharType, size_t N>
typename T::ValueType& SwapValueByPointer(T& root, const CharType(&source)[N], typename T::ValueType& value, typename T::AllocatorType& a) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Swap(root, value, a);
}

template <typename DocumentType>
typename DocumentType::ValueType& SwapValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, typename DocumentType::ValueType& value) {
    return pointer.Swap(document, value);
}

template <typename DocumentType, typename CharType, size_t N>
typename DocumentType::ValueType& SwapValueByPointer(DocumentType& document, const CharType(&source)[N], typename DocumentType::ValueType& value) {
    return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Swap(document, value);
}

template <typename T>
bool EraseValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer) {
    return pointer.Erase(root);
}

template <typename T, typename CharType, size_t N>
bool EraseValueByPointer(T& root, const CharType(&source)[N]) {
    return GenericPointer<typename T::ValueType>(source, N - 1).Erase(root);
}


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/prettywriter.h =====
//========================================
 */
enum PrettyFormatOptions {
    kFormatDefault = 0,         //!< Default pretty formatting.
    kFormatSingleLineArray = 1  //!< Format arrays on a single line.
};
*/
template<typename OutputStream, typename SourceEncoding = UTF8<>, typename TargetEncoding = UTF8<>, typename StackAllocator = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags>
class PrettyWriter : public Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags> {
public:
    typedef Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags> Base;
    typedef typename Base::Ch Ch;

    //! Constructor
    /*! \param os Output stream.
    */
    explicit PrettyWriter(OutputStream& os, StackAllocator* allocator = 0, size_t levelDepth = Base::kDefaultLevelDepth) : 
        Base(os, allocator, levelDepth), indentChar_(' '), indentCharCount_(4), formatOptions_(kFormatDefault) {}


    explicit PrettyWriter(StackAllocator* allocator = 0, size_t levelDepth = Base::kDefaultLevelDepth) : 
        Base(allocator, levelDepth), indentChar_(' '), indentCharCount_(4) {}

#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS

protected:
    void PrettyPrefix(Type type) {
        (void)type;
        if (Base::level_stack_.GetSize() != 0) { // this value is not at root

private:
    // Prohibit copy constructor & assignment operator.
    PrettyWriter(const PrettyWriter&);
    PrettyWriter& operator=(const PrettyWriter&);


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/rapidjson.h =====
//========================================
    a single binary, users can customize the name of the main RapidJSON
    namespace.

    In case of a single nesting level, defining \c CEREAL_RAPIDJSON_NAMESPACE
    to a custom name (e.g. \c MyRapidJSON) is sufficient.  If multiple
    #define CEREAL_RAPIDJSON_NO_SIZETYPEDEFINE
    namespace rapidjson { typedef ::std::size_t SizeType; }
    #include "rapidjson/..."
    \endcode

*/
typedef unsigned SizeType;
CEREAL_RAPIDJSON_NAMESPACE_END
#endif

#define CEREAL_RAPIDJSON_STATIC_ASSERT(x) \
   static_assert(x, CEREAL_RAPIDJSON_STRINGIFY(x))
#endif // C++11
#endif // CEREAL_RAPIDJSON_STATIC_ASSERT

CEREAL_RAPIDJSON_NAMESPACE_BEGIN
template <bool x> struct STATIC_ASSERTION_FAILURE;
template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };
template <size_t x> struct StaticAssertTest {};
CEREAL_RAPIDJSON_NAMESPACE_END

#if defined(__GNUC__) || defined(__clang__)
#define CEREAL_RAPIDJSON_STATIC_ASSERT(x) \
    typedef ::CEREAL_RAPIDJSON_NAMESPACE::StaticAssertTest< \
      sizeof(::CEREAL_RAPIDJSON_NAMESPACE::STATIC_ASSERTION_FAILURE<bool(x) >)> \
    CEREAL_RAPIDJSON_JOIN(StaticAssertTypedef, __LINE__) CEREAL_RAPIDJSON_STATIC_ASSERT_UNUSED_ATTRIBUTE
#endif // CEREAL_RAPIDJSON_STATIC_ASSERT
//! Type of JSON value
enum Type {
    kNullType = 0,      //!< null
    kFalseType = 1,     //!< false
    kTrueType = 2,      //!< true


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/reader.h =====
//========================================

    struct ParseException : std::runtime_error, rapidjson::ParseResult {
      ParseException(rapidjson::ParseErrorCode code, const char* msg, size_t offset)
        : std::runtime_error(msg), ParseResult(code, offset) {}
    };
 */
enum ParseFlag {
    kParseNoFlags = 0,              //!< No flags are set.
    kParseInsituFlag = 1,           //!< In-situ(destructive) parsing.
    kParseValidateEncodingFlag = 2, //!< Validate encoding of JSON strings.
*/
template<typename Encoding = UTF8<>, typename Derived = void>
struct BaseReaderHandler {
    typedef typename Encoding::Ch Ch;

    typedef typename internal::SelectIf<internal::IsSame<Derived, void>, BaseReaderHandler, Derived>::Type Override;

    bool Default() { return true; }
    bool Null() { return static_cast<Override&>(*this).Default(); }

namespace internal {

template<typename Stream, int = StreamTraits<Stream>::copyOptimization>
class StreamLocalCopy;

//! Do copy optimization.
template<typename Stream>
class StreamLocalCopy<Stream, 1> {
public:
    StreamLocalCopy(Stream& original) : s(original), original_(original) {}
    ~StreamLocalCopy() { original_ = s; }


private:
    StreamLocalCopy& operator=(const StreamLocalCopy&) /* = delete */;

    Stream& original_;
//! Keep reference.
template<typename Stream>
class StreamLocalCopy<Stream, 0> {
public:
    StreamLocalCopy(Stream& original) : s(original) {}

    Stream& s;

private:
    StreamLocalCopy& operator=(const StreamLocalCopy&) /* = delete */;
};

*/
template<typename InputStream>
void SkipWhitespace(InputStream& is) {
    internal::StreamLocalCopy<InputStream> copy(is);
    InputStream& s(copy.s);
    // The rest of string using SIMD
    static const char whitespace[16] = " \n\r\t";
    const __m128i w = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespace[0]));

    for (;; p += 16) {
    // The middle of string using SIMD
    static const char whitespace[16] = " \n\r\t";
    const __m128i w = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespace[0]));

    for (; p <= end - 16; p += 16) {
    #define C16(c) { c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c }
    static const char whitespaces[4][16] = { C16(' '), C16('\n'), C16('\r'), C16('\t') };
    #undef C16

    const __m128i w0 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[0][0]));
    #define C16(c) { c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c }
    static const char whitespaces[4][16] = { C16(' '), C16('\n'), C16('\r'), C16('\t') };
    #undef C16

    const __m128i w0 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[0][0]));
//! Template function specialization for InsituStringStream
template<> inline void SkipWhitespace(InsituStringStream& is) {
    is.src_ = const_cast<char*>(SkipWhitespace_SIMD(is.src_));
}

//! Template function specialization for StringStream
template<> inline void SkipWhitespace(StringStream& is) {
    is.src_ = SkipWhitespace_SIMD(is.src_);
}

template<> inline void SkipWhitespace(EncodedInputStream<UTF8<>, MemoryStream>& is) {
    is.is_.src_ = SkipWhitespace_SIMD(is.is_.src_, is.is_.end_);
}
#endif // CEREAL_RAPIDJSON_SIMD
*/
template <typename SourceEncoding, typename TargetEncoding, typename StackAllocator = CrtAllocator>
class GenericReader {
public:
    typedef typename SourceEncoding::Ch Ch; //!< SourceEncoding character type

    //! Constructor.
    /*! \param stackAllocator Optional allocator for allocating stack memory. (Only use for non-destructive parsing)
    */
    template <unsigned parseFlags, typename InputStream, typename Handler>
    ParseResult Parse(InputStream& is, Handler& handler) {
        if (parseFlags & kParseIterativeFlag)
            return IterativeParse<parseFlags>(is, handler);
    */
    template <typename InputStream, typename Handler>
    ParseResult Parse(InputStream& is, Handler& handler) {
        return Parse<kParseDefaultFlags>(is, handler);
    }
     */
    template <unsigned parseFlags, typename InputStream, typename Handler>
    bool IterativeParseNext(InputStream& is, Handler& handler) {
        while (CEREAL_RAPIDJSON_LIKELY(is.Peek() != '\0')) {
            SkipWhitespaceAndComments<parseFlags>(is);

protected:
    void SetParseError(ParseErrorCode code, size_t offset) { parseResult_.Set(code, offset); }

private:
    // Prohibit copy constructor & assignment operator.
    GenericReader(const GenericReader&);
    GenericReader& operator=(const GenericReader&);
    // clear stack on any exit from ParseStream, e.g. due to exception
    struct ClearStackOnExit {
        explicit ClearStackOnExit(GenericReader& r) : r_(r) {}
        ~ClearStackOnExit() { r_.ClearStack(); }
    private:
        GenericReader& r_;
        ClearStackOnExit(const ClearStackOnExit&);
        ClearStackOnExit& operator=(const ClearStackOnExit&);

    template<unsigned parseFlags, typename InputStream>
    void SkipWhitespaceAndComments(InputStream& is) {
        SkipWhitespace(is);

    // Parse object: { string : value, ... }
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseObject(InputStream& is, Handler& handler) {
        CEREAL_RAPIDJSON_ASSERT(is.Peek() == '{');
        is.Take();  // Skip '{'
    // Parse array: [ value, ... ]
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseArray(InputStream& is, Handler& handler) {
        CEREAL_RAPIDJSON_ASSERT(is.Peek() == '[');
        is.Take();  // Skip '['

    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseNull(InputStream& is, Handler& handler) {
        CEREAL_RAPIDJSON_ASSERT(is.Peek() == 'n');
        is.Take();

    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseTrue(InputStream& is, Handler& handler) {
        CEREAL_RAPIDJSON_ASSERT(is.Peek() == 't');
        is.Take();

    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseFalse(InputStream& is, Handler& handler) {
        CEREAL_RAPIDJSON_ASSERT(is.Peek() == 'f');
        is.Take();

    template<typename InputStream>
    CEREAL_RAPIDJSON_FORCEINLINE static bool Consume(InputStream& is, typename InputStream::Ch expect) {
        if (CEREAL_RAPIDJSON_LIKELY(is.Peek() == expect)) {
            is.Take();
    // Helper function to parse four hexadecimal digits in \uXXXX in ParseString().
    template<typename InputStream>
    unsigned ParseHex4(InputStream& is, size_t escapeOffset) {
        unsigned codepoint = 0;
        for (int i = 0; i < 4; i++) {

    template <typename CharType>
    class StackStream {
    public:
        typedef CharType Ch;

        StackStream(internal::Stack<StackAllocator>& stack) : stack_(stack), length_(0) {}
        CEREAL_RAPIDJSON_FORCEINLINE void Put(Ch c) {

    private:
        StackStream(const StackStream&);
        StackStream& operator=(const StackStream&);

    // Parse string and generate String event. Different code paths for kParseInsituFlag.
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseString(InputStream& is, Handler& handler, bool isKey = false) {
        internal::StreamLocalCopy<InputStream> copy(is);
        InputStream& s(copy.s);
    // This function handles the prefix/suffix double quotes, escaping, and optional encoding validation.
    template<unsigned parseFlags, typename SEncoding, typename TEncoding, typename InputStream, typename OutputStream>
    CEREAL_RAPIDJSON_FORCEINLINE void ParseStringToStream(InputStream& is, OutputStream& os) {
//!@cond CEREAL_RAPIDJSON_HIDDEN_FROM_DOXYGEN
#define Z16 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        static const char escape[256] = {
            Z16, Z16, 0, 0,'\"', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'/',
            Z16, Z16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
            0, 0,'\b', 0, 0, 0,'\f', 0, 0, 0, 0, 0, 0, 0,'\n', 0,

    template<typename InputStream, typename OutputStream>
    static CEREAL_RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InputStream&, OutputStream&) {
            // Do nothing for generic version
    }

    // StringStream -> StackStream<char>
    static CEREAL_RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(StringStream& is, StackStream<char>& os) {
        const char* p = is.src_;

        // Scan one by one until alignment (unaligned load may cross page boundary and cause crash)
        // The rest of string using SIMD
        static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
        static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
        static const char space[16]  = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
        const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
        const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
        const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
    // InsituStringStream -> InsituStringStream
    static CEREAL_RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InsituStringStream& is, InsituStringStream& os) {
        CEREAL_RAPIDJSON_ASSERT(&is == &os);
        (void)os;

        // The rest of string using SIMD
        static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
        static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
        static const char space[16] = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
        const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
        const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
        const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
    // When read/write pointers are the same for insitu stream, just skip unescaped characters
    static CEREAL_RAPIDJSON_FORCEINLINE void SkipUnescapedString(InsituStringStream& is) {
        CEREAL_RAPIDJSON_ASSERT(is.src_ == is.dst_);
        char* p = is.src_;

        // The rest of string using SIMD
        static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
        static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
        static const char space[16] = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
        const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
        const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
        const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
    // StringStream -> StackStream<char>
    static CEREAL_RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(StringStream& is, StackStream<char>& os) {
        const char* p = is.src_;

        // Scan one by one until alignment (unaligned load may cross page boundary and cause crash)
    // InsituStringStream -> InsituStringStream
    static CEREAL_RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InsituStringStream& is, InsituStringStream& os) {
        CEREAL_RAPIDJSON_ASSERT(&is == &os);
        (void)os;

    // When read/write pointers are the same for insitu stream, just skip unescaped characters
    static CEREAL_RAPIDJSON_FORCEINLINE void SkipUnescapedString(InsituStringStream& is) {
        CEREAL_RAPIDJSON_ASSERT(is.src_ == is.dst_);
        char* p = is.src_;


    template<typename InputStream, bool backup, bool pushOnTake>
    class NumberStream;

    template<typename InputStream>
    class NumberStream<InputStream, false, false> {
    public:
        typedef typename InputStream::Ch Ch;

        NumberStream(GenericReader& reader, InputStream& s) : is(s) { (void)reader;  }


    protected:
        NumberStream& operator=(const NumberStream&);

        InputStream& is;

    template<typename InputStream>
    class NumberStream<InputStream, true, false> : public NumberStream<InputStream, false, false> {
        typedef NumberStream<InputStream, false, false> Base;
    public:
        NumberStream(GenericReader& reader, InputStream& s) : Base(reader, s), stackStream(reader.stack_) {}

        CEREAL_RAPIDJSON_FORCEINLINE Ch TakePush() {

    private:
        StackStream<char> stackStream;
    };

    template<typename InputStream>
    class NumberStream<InputStream, true, true> : public NumberStream<InputStream, true, false> {
        typedef NumberStream<InputStream, true, false> Base;
    public:
        NumberStream(GenericReader& reader, InputStream& is) : Base(reader, is) {}

        CEREAL_RAPIDJSON_FORCEINLINE Ch Take() { return Base::TakePush(); }

    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseNumber(InputStream& is, Handler& handler) {
        internal::StreamLocalCopy<InputStream> copy(is);
        NumberStream<InputStream,
    // Parse any JSON value
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseValue(InputStream& is, Handler& handler) {
        switch (is.Peek()) {
            case 'n': ParseNull  <parseFlags>(is, handler); break;
    // States
    enum IterativeParsingState {
        IterativeParsingFinishState = 0, // sink states at top
        IterativeParsingErrorState,      // sink states at top
        IterativeParsingStartState,
    // Tokens
    enum Token {
        LeftBracketToken = 0,
        RightBracketToken,

        // Maps from ASCII to Token
        static const unsigned char tokenMap[256] = {
            N16, // 00~0F
            N16, // 10~1F
            N, N, StringToken, N, N, N, N, N, N, N, N, N, CommaToken, N, N, N, // 20~2F
        // current state x one lookahead token -> new state
        static const char G[cIterativeParsingStateCount][kTokenCount] = {
            // Finish(sink state)
            {
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
    // May return a new state on state pop.
    template <unsigned parseFlags, typename InputStream, typename Handler>
    CEREAL_RAPIDJSON_FORCEINLINE IterativeParsingState Transit(IterativeParsingState src, Token token, IterativeParsingState dst, InputStream& is, Handler& handler) {
        (void)token;


    template <typename InputStream>
    void HandleError(IterativeParsingState src, InputStream& is) {
        if (HasParseError()) {
            // Error flag has been set.

    template <unsigned parseFlags, typename InputStream, typename Handler>
    ParseResult IterativeParse(InputStream& is, Handler& handler) {
        parseResult_.Clear();
        ClearStackOnExit scope(*this);

    static const size_t kDefaultStackCapacity = 256;    //!< Default stack capacity in bytes for storing a single decoded string.
    internal::Stack<StackAllocator> stack_;  //!< A stack for storing decoded string temporarily during non-destructive parsing.
    ParseResult parseResult_;
    IterativeParsingState state_;
//! Reader with UTF8 encoding and default allocator.
typedef GenericReader<UTF8<>, UTF8<> > Reader;

CEREAL_RAPIDJSON_NAMESPACE_END



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/schema.h =====
//========================================

namespace internal {

inline void PrintInvalidKeyword(const char* keyword) {
    printf("Fail keyword: %s\n", keyword);

template <typename ValueType, typename Allocator>
class GenericSchemaDocument;

namespace internal {

template <typename SchemaDocumentType>
class Schema;

///////////////////////////////////////////////////////////////////////////////
// ISchemaValidator

class ISchemaValidator {
public:
    virtual ~ISchemaValidator() {}
    virtual bool IsValid() const = 0;
};

///////////////////////////////////////////////////////////////////////////////

template <typename SchemaType>
class ISchemaStateFactory {
public:
    virtual ~ISchemaStateFactory() {}
    virtual ISchemaValidator* CreateSchemaValidator(const SchemaType&) = 0;
    virtual void DestroySchemaValidator(ISchemaValidator* validator) = 0;
    virtual void* CreateHasher() = 0;
    virtual uint64_t GetHashCode(void* hasher) = 0;
    virtual void DestroryHasher(void* hasher) = 0;
    virtual void* MallocState(size_t size) = 0;
    virtual void FreeState(void* p) = 0;
};

///////////////////////////////////////////////////////////////////////////////

template <typename SchemaType>
class IValidationErrorHandler {
public:
    typedef typename SchemaType::Ch Ch;
    typedef typename SchemaType::SValue SValue;

    virtual ~IValidationErrorHandler() {}

    virtual void NotMultipleOf(int64_t actual, const SValue& expected) = 0;
    virtual void NotMultipleOf(uint64_t actual, const SValue& expected) = 0;
    virtual void NotMultipleOf(double actual, const SValue& expected) = 0;
    virtual void AboveMaximum(int64_t actual, const SValue& expected, bool exclusive) = 0;
    virtual void AboveMaximum(uint64_t actual, const SValue& expected, bool exclusive) = 0;
    virtual void AboveMaximum(double actual, const SValue& expected, bool exclusive) = 0;
    virtual void BelowMinimum(int64_t actual, const SValue& expected, bool exclusive) = 0;
    virtual void BelowMinimum(uint64_t actual, const SValue& expected, bool exclusive) = 0;
    virtual void BelowMinimum(double actual, const SValue& expected, bool exclusive) = 0;

    virtual void TooLong(const Ch* str, SizeType length, SizeType expected) = 0;
    virtual void TooShort(const Ch* str, SizeType length, SizeType expected) = 0;
    virtual void DoesNotMatch(const Ch* str, SizeType length) = 0;

    virtual void DisallowedItem(SizeType index) = 0;
    virtual void TooFewItems(SizeType actualCount, SizeType expectedCount) = 0;
    virtual void TooManyItems(SizeType actualCount, SizeType expectedCount) = 0;
    virtual void DuplicateItems(SizeType index1, SizeType index2) = 0;

    virtual void TooManyProperties(SizeType actualCount, SizeType expectedCount) = 0;
    virtual void TooFewProperties(SizeType actualCount, SizeType expectedCount) = 0;
    virtual void StartMissingProperties() = 0;
    virtual void AddMissingProperty(const SValue& name) = 0;
    virtual bool EndMissingProperties() = 0;
    virtual void PropertyViolations(ISchemaValidator** subvalidators, SizeType count) = 0;
    virtual void DisallowedProperty(const Ch* name, SizeType length) = 0;

    virtual void StartDependencyErrors() = 0;
    virtual void StartMissingDependentProperties() = 0;
    virtual void AddMissingDependentProperty(const SValue& targetName) = 0;
    virtual void EndMissingDependentProperties(const SValue& sourceName) = 0;
    virtual void AddDependencySchemaError(const SValue& souceName, ISchemaValidator* subvalidator) = 0;
    virtual bool EndDependencyErrors() = 0;

    virtual void DisallowedValue() = 0;
    virtual void StartDisallowedType() = 0;
    virtual void AddExpectedType(const typename SchemaType::ValueType& expectedType) = 0;
    virtual void EndDisallowedType(const typename SchemaType::ValueType& actualType) = 0;
    virtual void NotAllOf(ISchemaValidator** subvalidators, SizeType count) = 0;
    virtual void NoneOf(ISchemaValidator** subvalidators, SizeType count) = 0;
    virtual void NotOneOf(ISchemaValidator** subvalidators, SizeType count) = 0;
    virtual void Disallowed() = 0;
};


// For comparison of compound value
template<typename Encoding, typename Allocator>
class Hasher {
public:
    typedef typename Encoding::Ch Ch;

    Hasher(Allocator* allocator = 0, size_t stackCapacity = kDefaultSize) : stack_(allocator, stackCapacity) {}


private:
    static const size_t kDefaultSize = 256;
    struct Number {
        union U {
            uint64_t u;
            int64_t i;

    static uint64_t Hash(uint64_t h, uint64_t d) {
        static const uint64_t kPrime = CEREAL_RAPIDJSON_UINT64_C2(0x00000100, 0x000001b3);
        h ^= d;
        h *= kPrime;
        return h;

template <typename SchemaDocumentType>
struct SchemaValidationContext {
    typedef Schema<SchemaDocumentType> SchemaType;
    typedef ISchemaStateFactory<SchemaType> SchemaValidatorFactoryType;
    typedef IValidationErrorHandler<SchemaType> ErrorHandlerType;
    typedef typename SchemaType::ValueType ValueType;
    typedef typename ValueType::Ch Ch;

    enum PatternValidatorType {
        kPatternValidatorOnly,
        kPatternValidatorWithProperty,
        kPatternValidatorWithAdditionalProperty

template <typename SchemaDocumentType>
class Schema {
public:
    typedef typename SchemaDocumentType::ValueType ValueType;
    typedef typename SchemaDocumentType::AllocatorType AllocatorType;
    typedef typename SchemaDocumentType::PointerType PointerType;
    typedef typename ValueType::EncodingType EncodingType;
    typedef typename EncodingType::Ch Ch;
    typedef SchemaValidationContext<SchemaDocumentType> Context;
    typedef Schema<SchemaDocumentType> SchemaType;
    typedef GenericValue<EncodingType, AllocatorType> SValue;
    typedef IValidationErrorHandler<Schema> ErrorHandler;
    friend class GenericSchemaDocument<ValueType, AllocatorType>;

    Schema(SchemaDocumentType* schemaDocument, const PointerType& p, const ValueType& value, const ValueType& document, AllocatorType* allocator) :
        typeless_(schemaDocument->GetTypeless()),
        enum_(),
        enumCount_(),
        not_(),
        type_((1 << kTotalSchemaType) - 1), // typeless
        validatorCount_(),
    {
        typedef typename SchemaDocumentType::ValueType ValueType;
        typedef typename ValueType::ConstValueIterator ConstValueIterator;
        typedef typename ValueType::ConstMemberIterator ConstMemberIterator;

        if (!value.IsObject())
            return;
            if (v->IsArray() && v->Size() > 0) {
                enum_ = static_cast<uint64_t*>(allocator_->Malloc(sizeof(uint64_t) * v->Size()));
                for (ConstValueIterator itr = v->Begin(); itr != v->End(); ++itr) {
                    typedef Hasher<EncodingType, MemoryPoolAllocator<> > EnumHasherType;
                    char buffer[256u + 24];
                    MemoryPoolAllocator<> hasherAllocator(buffer, sizeof(buffer));
                    EnumHasherType h(&hasherAllocator, 256);
                    itr->Accept(h);
                    enum_[enumCount_++] = h.GetHashCode();
                }
            }

#define CEREAL_RAPIDJSON_STRING_(name, ...) \
    static const ValueType& Get##name##String() {\
        static const Ch s[] = { __VA_ARGS__, '\0' };\
        static const ValueType v(s, static_cast<SizeType>(sizeof(s) / sizeof(Ch) - 1));\
        return v;\
    }


private:
    enum SchemaValueType {
        kNullSchemaType,
        kBooleanSchemaType,
        kObjectSchemaType,
#if CEREAL_RAPIDJSON_SCHEMA_USE_INTERNALREGEX
        typedef internal::GenericRegex<EncodingType, AllocatorType> RegexType;
#elif CEREAL_RAPIDJSON_SCHEMA_USE_STDREGEX
        typedef std::basic_regex<Ch> RegexType;
#else
        typedef char RegexType;
#endif

    struct SchemaArray {
        SchemaArray() : schemas(), count() {}
        ~SchemaArray() { AllocatorType::Free(schemas); }
        const SchemaType** schemas;

    template <typename V1, typename V2>
    void AddUniqueElement(V1& a, const V2& v) {
        for (typename V1::ConstValueIterator itr = a.Begin(); itr != a.End(); ++itr)
            if (*itr == v)

    static const ValueType* GetMember(const ValueType& value, const ValueType& name) {
        typename ValueType::ConstMemberIterator itr = value.FindMember(name);
        return itr != value.MemberEnd() ? &(itr->value) : 0;
    }

    static void AssignIfExist(bool& out, const ValueType& value, const ValueType& name) {
        if (const ValueType* v = GetMember(value, name))
            if (v->IsBool())
                out = v->GetBool();

    static void AssignIfExist(SizeType& out, const ValueType& value, const ValueType& name) {
        if (const ValueType* v = GetMember(value, name))
            if (v->IsUint64() && v->GetUint64() <= SizeType(~0))
                out = static_cast<SizeType>(v->GetUint64());
#if CEREAL_RAPIDJSON_SCHEMA_USE_INTERNALREGEX
    template <typename ValueType>
    RegexType* CreatePattern(const ValueType& value) {
        if (value.IsString()) {
            RegexType* r = new (allocator_->Malloc(sizeof(RegexType))) RegexType(value.GetString(), allocator_);

    static bool IsPatternMatch(const RegexType* pattern, const Ch *str, SizeType) {
        GenericRegexSearch<RegexType> rs(*pattern);
        return rs.Search(str);
    }
#elif CEREAL_RAPIDJSON_SCHEMA_USE_STDREGEX
    template <typename ValueType>
    RegexType* CreatePattern(const ValueType& value) {
        if (value.IsString()) {
            RegexType *r = static_cast<RegexType*>(allocator_->Malloc(sizeof(RegexType)));

    static bool IsPatternMatch(const RegexType* pattern, const Ch *str, SizeType length) {
        std::match_results<const Ch*> r;
        return std::regex_search(str, str + length, r, *pattern);
    }
#else
    template <typename ValueType>
    RegexType* CreatePattern(const ValueType&) { return 0; }

    static bool IsPatternMatch(const RegexType*, const Ch *, SizeType) { return true; }
#endif // CEREAL_RAPIDJSON_SCHEMA_USE_STDREGEX

    void AddType(const ValueType& type) {

    struct Property {
        Property() : schema(), dependenciesSchema(), dependenciesValidatorIndex(), dependencies(), required(false) {}
        ~Property() { AllocatorType::Free(dependencies); }
        SValue name;

    struct PatternProperty {
        PatternProperty() : schema(), pattern() {}
        ~PatternProperty() { 
            if (pattern) {

template<typename Stack, typename Ch>
struct TokenHelper {
    CEREAL_RAPIDJSON_FORCEINLINE static void AppendIndexToken(Stack& documentStack, SizeType index) {
        *documentStack.template Push<Ch>() = '/';
        char buffer[21];
// Partial specialized version for char to prevent buffer copying.
template <typename Stack>
struct TokenHelper<Stack, char> {
    CEREAL_RAPIDJSON_FORCEINLINE static void AppendIndexToken(Stack& documentStack, SizeType index) {
        if (sizeof(SizeType) == 4) {
            char *buffer = documentStack.template Push<char>(1 + 10); // '/' + uint

template <typename SchemaDocumentType>
class IGenericRemoteSchemaDocumentProvider {
public:
    typedef typename SchemaDocumentType::Ch Ch;

    virtual ~IGenericRemoteSchemaDocumentProvider() {}
    virtual const SchemaDocumentType* GetRemoteDocument(const Ch* uri, SizeType length) = 0;
};

///////////////////////////////////////////////////////////////////////////////
*/
template <typename ValueT, typename Allocator = CrtAllocator>
class GenericSchemaDocument {
public:
    typedef ValueT ValueType;
    typedef IGenericRemoteSchemaDocumentProvider<GenericSchemaDocument> IRemoteSchemaDocumentProviderType;
    typedef Allocator AllocatorType;
    typedef typename ValueType::EncodingType EncodingType;
    typedef typename EncodingType::Ch Ch;
    typedef internal::Schema<GenericSchemaDocument> SchemaType;
    typedef GenericPointer<ValueType, Allocator> PointerType;
    typedef GenericValue<EncodingType, Allocator> URIType;
    friend class internal::Schema<GenericSchemaDocument>;
    template <typename, typename, typename>
    friend class GenericSchemaValidator;

    //! Constructor.
    */
    explicit GenericSchemaDocument(const ValueType& document, const Ch* uri = 0, SizeType uriLength = 0,
        IRemoteSchemaDocumentProviderType* remoteProvider = 0, Allocator* allocator = 0) :
        remoteProvider_(remoteProvider),
        allocator_(allocator),

private:
    //! Prohibit copying
    GenericSchemaDocument(const GenericSchemaDocument&);
    //! Prohibit assignment

    struct SchemaRefEntry {
        SchemaRefEntry(const PointerType& s, const PointerType& t, const SchemaType** outSchema, Allocator *allocator) : source(s, allocator), target(t, allocator), schema(outSchema) {}
        PointerType source;
        PointerType target;

    struct SchemaEntry {
        SchemaEntry(const PointerType& p, SchemaType* s, bool o, Allocator* allocator) : pointer(p, allocator), schema(s), owned(o) {}
        ~SchemaEntry() {
            if (owned) {
    bool HandleRefSchema(const PointerType& source, const SchemaType** schema, const ValueType& v, const ValueType& document) {
        static const Ch kRefString[] = { '$', 'r', 'e', 'f', '\0' };
        static const ValueType kRefValue(kRefString, 4);

        typename ValueType::ConstMemberIterator itr = v.FindMember(kRefValue);
        if (itr == v.MemberEnd())

    static const size_t kInitialSchemaMapSize = 64;
    static const size_t kInitialSchemaRefSize = 64;

    IRemoteSchemaDocumentProviderType* remoteProvider_;
    Allocator *allocator_;
//! GenericSchemaDocument using Value type.
typedef GenericSchemaDocument<Value> SchemaDocument;
//! IGenericRemoteSchemaDocumentProvider using SchemaDocument.
typedef IGenericRemoteSchemaDocumentProvider<SchemaDocument> IRemoteSchemaDocumentProvider;

///////////////////////////////////////////////////////////////////////////////
// GenericSchemaValidator
*/
template <
    typename SchemaDocumentType,
    typename OutputHandler = BaseReaderHandler<typename SchemaDocumentType::SchemaType::EncodingType>,
    typename StateAllocator = CrtAllocator>
class GenericSchemaValidator :
    public internal::ISchemaStateFactory<typename SchemaDocumentType::SchemaType>, 
    public internal::ISchemaValidator,
    public internal::IValidationErrorHandler<typename SchemaDocumentType::SchemaType>
{
public:
    typedef typename SchemaDocumentType::SchemaType SchemaType;
    typedef typename SchemaDocumentType::PointerType PointerType;
    typedef typename SchemaType::EncodingType EncodingType;
    typedef typename SchemaType::SValue SValue;
    typedef typename EncodingType::Ch Ch;
    typedef GenericStringRef<Ch> StringRefType;
    typedef GenericValue<EncodingType, StateAllocator> ValueType;

    //! Constructor without output handler.
    /*!
    // Implementation of ISchemaValidator
    virtual bool IsValid() const { return valid_; }

    //! Gets the error object.
    ValueType& GetError() { return error_; }
        currentError_.AddMember(ValueType(sourceName, GetStateAllocator()).Move(),
            static_cast<GenericSchemaValidator*>(subvalidator)->GetError(), GetStateAllocator());
    }
    bool EndDependencyErrors() {
        if (currentError_.ObjectEmpty())
#define CEREAL_RAPIDJSON_STRING_(name, ...) \
    static const StringRefType& Get##name##String() {\
        static const Ch s[] = { __VA_ARGS__, '\0' };\
        static const StringRefType v(s, static_cast<SizeType>(sizeof(s) / sizeof(Ch) - 1)); \
        return v;\
    }

        if (context->hasher)\
            static_cast<HasherType*>(context->hasher)->method arg2;\
        if (context->validators)\
            for (SizeType i_ = 0; i_ < context->validatorCount; i_++)\
                static_cast<GenericSchemaValidator*>(context->validators[i_])->method arg2;\
        if (context->patternPropertiesValidators)\
            for (SizeType i_ = 0; i_ < context->patternPropertiesValidatorCount; i_++)\
                static_cast<GenericSchemaValidator*>(context->patternPropertiesValidators[i_])->method arg2;\
    }

#define CEREAL_RAPIDJSON_SCHEMA_HANDLE_END_(method, arg2)\
    // Implementation of ISchemaStateFactory<SchemaType>
    virtual ISchemaValidator* CreateSchemaValidator(const SchemaType& root) {
        return new (GetStateAllocator().Malloc(sizeof(GenericSchemaValidator))) GenericSchemaValidator(*schemaDocument_, root, documentStack_.template Bottom<char>(), documentStack_.GetSize(),
#if CEREAL_RAPIDJSON_SCHEMA_VERBOSE
        depth_ + 1,

    virtual void DestroySchemaValidator(ISchemaValidator* validator) {
        GenericSchemaValidator* v = static_cast<GenericSchemaValidator*>(validator);
        v->~GenericSchemaValidator();
        StateAllocator::Free(v);

    virtual void* CreateHasher() {
        return new (GetStateAllocator().Malloc(sizeof(HasherType))) HasherType(&GetStateAllocator());
    }

    virtual uint64_t GetHashCode(void* hasher) {
        return static_cast<HasherType*>(hasher)->GetHashCode();
    }

    virtual void DestroryHasher(void* hasher) {
        HasherType* h = static_cast<HasherType*>(hasher);
        h->~HasherType();
        StateAllocator::Free(h);

    virtual void* MallocState(size_t size) {
        return GetStateAllocator().Malloc(size);
    }

    virtual void FreeState(void* p) {
        StateAllocator::Free(p);
    }

private:
    typedef typename SchemaType::Context Context;
    typedef GenericValue<UTF8<>, StateAllocator> HashCodeArray;
    typedef internal::Hasher<EncodingType, StateAllocator> HasherType;

    GenericSchemaValidator( 
        const SchemaDocumentType& schemaDocument,

    static const size_t kDefaultSchemaStackCapacity = 1024;
    static const size_t kDefaultDocumentStackCapacity = 256;
    const SchemaDocumentType* schemaDocument_;
    const SchemaType& root_;
    StateAllocator* stateAllocator_;

typedef GenericSchemaValidator<SchemaDocument> SchemaValidator;

///////////////////////////////////////////////////////////////////////////////
// SchemaValidatingReader
*/
template <
    unsigned parseFlags,
    typename InputStream,
    typename SourceEncoding,
    typename StackAllocator = CrtAllocator>
class SchemaValidatingReader {
public:
    typedef typename SchemaDocumentType::PointerType PointerType;
    typedef typename InputStream::Ch Ch;
    typedef GenericValue<SourceEncoding, StackAllocator> ValueType;

    //! Constructor
    /*!

    template <typename Handler>
    bool operator()(Handler& handler) {
        GenericReader<SourceEncoding, typename SchemaDocumentType::EncodingType, StackAllocator> reader;
        GenericSchemaValidator<SchemaDocumentType, Handler> validator(sd_, handler);

private:
    InputStream& is_;
    const SchemaDocumentType& sd_;



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/stream.h =====
//========================================
*/
template<typename Stream>
struct StreamTraits {
    //! Whether to make local copy of stream for optimization during parsing.
    /*!
        By default, for safety, streams do not use local copy optimization.
    */
    enum { copyOptimization = 0 };
};

//! Reserve n characters for writing to a stream.
template<typename Stream>
inline void PutReserve(Stream& stream, size_t count) {
    (void)stream;
    (void)count;
//! Write character to a stream, presuming buffer is reserved.
template<typename Stream>
inline void PutUnsafe(Stream& stream, typename Stream::Ch c) {
    stream.Put(c);
}
//! Put N copies of a character to a stream.
template<typename Stream, typename Ch>
inline void PutN(Stream& stream, Ch c, size_t n) {
    PutReserve(stream, n);
    for (size_t i = 0; i < n; i++)

template <typename InputStream, typename Encoding = UTF8<> >
class GenericStreamWrapper {
public:
    typedef typename Encoding::Ch Ch;
    GenericStreamWrapper(InputStream& is): is_(is) {}

    Ch Peek() const { return is_.Peek(); }

protected:
    InputStream& is_;
};

*/
template <typename Encoding>
struct GenericStringStream {
    typedef typename Encoding::Ch Ch;

    GenericStringStream(const Ch *src) : src_(src), head_(src) {}


template <typename Encoding>
struct StreamTraits<GenericStringStream<Encoding> > {
    enum { copyOptimization = 1 };
};

//! String stream with UTF8 encoding.
typedef GenericStringStream<UTF8<> > StringStream;

///////////////////////////////////////////////////////////////////////////////
// InsituStringStream
*/
template <typename Encoding>
struct GenericInsituStringStream {
    typedef typename Encoding::Ch Ch;

    GenericInsituStringStream(Ch *src) : src_(src), dst_(0), head_(src) {}


template <typename Encoding>
struct StreamTraits<GenericInsituStringStream<Encoding> > {
    enum { copyOptimization = 1 };
};

//! Insitu string stream with UTF8 encoding.
typedef GenericInsituStringStream<UTF8<> > InsituStringStream;

CEREAL_RAPIDJSON_NAMESPACE_END



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/stringbuffer.h =====
//========================================
*/
template <typename Encoding, typename Allocator = CrtAllocator>
class GenericStringBuffer {
public:
    typedef typename Encoding::Ch Ch;

    GenericStringBuffer(Allocator* allocator = 0, size_t capacity = kDefaultCapacity) : stack_(allocator, capacity) {}


    static const size_t kDefaultCapacity = 256;
    mutable internal::Stack<Allocator> stack_;

private:
    // Prohibit copy constructor & assignment operator.
    GenericStringBuffer(const GenericStringBuffer&);
    GenericStringBuffer& operator=(const GenericStringBuffer&);
//! String buffer with UTF8 encoding
typedef GenericStringBuffer<UTF8<> > StringBuffer;

template<typename Encoding, typename Allocator>
inline void PutReserve(GenericStringBuffer<Encoding, Allocator>& stream, size_t count) {
    stream.Reserve(count);
}

template<typename Encoding, typename Allocator>
inline void PutUnsafe(GenericStringBuffer<Encoding, Allocator>& stream, typename Encoding::Ch c) {
    stream.PutUnsafe(c);
}
//! Implement specialized version of PutN() with memset() for better performance.
template<>
inline void PutN(GenericStringBuffer<UTF8<> >& stream, char c, size_t n) {
    std::memset(stream.stack_.Push<char>(n), c, n * sizeof(c));
}


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidjson/writer.h =====
//========================================
//! Combination of writeFlags
enum WriteFlag {
    kWriteNoFlags = 0,              //!< No flags are set.
    kWriteValidateEncodingFlag = 1, //!< Validate encoding of JSON strings.
    kWriteNanAndInfFlag = 2,        //!< Allow writing of Infinity, -Infinity and NaN.
*/
template<typename OutputStream, typename SourceEncoding = UTF8<>, typename TargetEncoding = UTF8<>, typename StackAllocator = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags>
class Writer {
public:
    typedef typename SourceEncoding::Ch Ch;

    static const int kDefaultMaxDecimalPlaces = 324;

    //! Constructor
    /*! \param os Output stream.
    */
    explicit
    Writer(OutputStream& os, StackAllocator* stackAllocator = 0, size_t levelDepth = kDefaultLevelDepth) : 
        os_(&os), level_stack_(stackAllocator, levelDepth * sizeof(Level)), maxDecimalPlaces_(kDefaultMaxDecimalPlaces), hasRoot_(false) {}

    explicit
    Writer(StackAllocator* allocator = 0, size_t levelDepth = kDefaultLevelDepth) :
        os_(0), level_stack_(allocator, levelDepth * sizeof(Level)), maxDecimalPlaces_(kDefaultMaxDecimalPlaces), hasRoot_(false) {}


protected:
    //! Information for each nested level
    struct Level {
        Level(bool inArray_) : valueCount(0), inArray(inArray_) {}
        size_t valueCount;  //!< number of values in this level
        bool inArray;       //!< true if in array, otherwise in object

    static const size_t kDefaultLevelDepth = 32;

    bool WriteNull()  {
        PutReserve(*os_, 4);
    bool WriteString(const Ch* str, SizeType length)  {
        static const typename OutputStream::Ch hexDigits[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        static const char escape[256] = {
#define Z16 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            //0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
            'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'b', 't', 'n', 'u', 'f', 'r', 'u', 'u', // 00

private:
    // Prohibit copy constructor & assignment operator.
    Writer(const Writer&);
    Writer& operator=(const Writer&);

template<>
inline bool Writer<StringBuffer>::WriteInt(int i) {
    char *buffer = os_->Push(11);
    const char* end = internal::i32toa(i, buffer);

template<>
inline bool Writer<StringBuffer>::WriteUint(unsigned u) {
    char *buffer = os_->Push(10);
    const char* end = internal::u32toa(u, buffer);

template<>
inline bool Writer<StringBuffer>::WriteInt64(int64_t i64) {
    char *buffer = os_->Push(21);
    const char* end = internal::i64toa(i64, buffer);

template<>
inline bool Writer<StringBuffer>::WriteUint64(uint64_t u) {
    char *buffer = os_->Push(20);
    const char* end = internal::u64toa(u, buffer);

template<>
inline bool Writer<StringBuffer>::WriteDouble(double d) {
    if (internal::Double(d).IsNanOrInf()) {
        // Note: This code path can only be reached if (CEREAL_RAPIDJSON_WRITE_DEFAULT_FLAGS & kWriteNanAndInfFlag).
#if defined(CEREAL_RAPIDJSON_SSE2) || defined(CEREAL_RAPIDJSON_SSE42)
template<>
inline bool Writer<StringBuffer>::ScanWriteUnescapedString(StringStream& is, size_t length) {
    if (length < 16)
        return CEREAL_RAPIDJSON_LIKELY(is.Tell() < length);
    // The rest of string using SIMD
    static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
    static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
    static const char space[16]  = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
    const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
    const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
    const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
#elif defined(CEREAL_RAPIDJSON_NEON)
template<>
inline bool Writer<StringBuffer>::ScanWriteUnescapedString(StringStream& is, size_t length) {
    if (length < 16)
        return CEREAL_RAPIDJSON_LIKELY(is.Tell() < length);


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidxml/rapidxml.hpp =====
//========================================

namespace cereal {
namespace rapidxml
{
    //! When exceptions are disabled by defining CEREAL_RAPIDXML_NO_EXCEPTIONS,
    //! this function is called to notify user about the error.

namespace cereal {
namespace rapidxml
{

    //! Parse error exception.
    //! This class derives from <code>std::exception</code> class.
    class parse_error: public std::exception
    {

    public:

        //! Constructs parse error
        parse_error(const char *what_, void *where_)
        //! \return Pointer to null terminated description of the error.
        virtual const char *what() const CEREAL_NOEXCEPT override
        {
            return m_what;
        }
        //! \return Pointer to location within the parsed string where error occured.
        template<class Ch>
        Ch *where() const
        {
            return reinterpret_cast<Ch *>(m_where);

    private:

        const char *m_what;
        void *m_where;

namespace cereal {
namespace rapidxml
{
    // Forward declarations
    template<class Ch> class xml_node;
    template<class Ch> class xml_attribute;
    template<class Ch> class xml_document;

    //! Enumeration listing all node types produced by the parser.
    //! Use xml_node::type() function to query node type.
    enum node_type
    {
        node_document,      //!< A document node. Name and value are empty.
        node_element,       //!< An element node. Name contains element name. Value contains text of first data node.
    //! \cond internal
    namespace internal
    {

        // Struct that contains lookup tables for the parser
        // It must be a template to allow correct linking (because it has static data members, which are defined in a header file).
        template<int Dummy>
        struct lookup_tables
        {
            static const unsigned char lookup_whitespace[256];              // Whitespace table
            static const unsigned char lookup_node_name[256];               // Node name table
            static const unsigned char lookup_text[256];                    // Text table
            static const unsigned char lookup_text_pure_no_ws[256];         // Text table
            static const unsigned char lookup_text_pure_with_ws[256];       // Text table
            static const unsigned char lookup_attribute_name[256];          // Attribute name table
            static const unsigned char lookup_attribute_data_1[256];        // Attribute data table with single quote
            static const unsigned char lookup_attribute_data_1_pure[256];   // Attribute data table with single quote
            static const unsigned char lookup_attribute_data_2[256];        // Attribute data table with double quotes
            static const unsigned char lookup_attribute_data_2_pure[256];   // Attribute data table with double quotes
            static const unsigned char lookup_digits[256];                  // Digits
            static const unsigned char lookup_upcase[256];                  // To uppercase conversion table for ASCII characters
        };

        // Find length of the string
        template<class Ch>
        inline std::size_t measure(const Ch *p)
        {
            const Ch *tmp = p;
        // Compare strings for equality
        template<class Ch>
        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)
        {
            if (size1 != size2)

        template<class Ch>
        inline bool preserve_space(xml_node<Ch>* node)
        {
            const Ch preserve_value[] = { Ch('p'), Ch('r'), Ch('e'), Ch('s'), Ch('e'), Ch('r'), Ch('v'), Ch('e') };
    //! \tparam Ch Character type of created nodes.
    template<class Ch = char>
    class memory_pool
    {

    public:

        //! \cond internal
        typedef void *(alloc_func)(std::size_t);       // Type of user-defined function used to allocate memory
        typedef void (free_func)(void *);              // Type of user-defined function used to free memory
        //! \endcond

        //! Constructs empty pool with default allocator functions.

    private:

        struct header
        {
            char *previous_begin;
        };
    //! \tparam Ch Character type to use
    template<class Ch = char>
    class xml_base
    {

    public:

        ///////////////////////////////////////////////////////////////////////////
        // Construction & destruction

    protected:

        // Return empty string
        static Ch *nullstr()
        {
            static Ch zero = Ch('\0');
            return &zero;
        }

    //! \tparam Ch Character type to use.
    template<class Ch = char>
    class xml_attribute: public xml_base<Ch>
    {

        friend class xml_node<Ch>;

    public:

        ///////////////////////////////////////////////////////////////////////////
        // Construction & destruction

    private:

        xml_attribute<Ch> *m_prev_attribute;        // Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero
        xml_attribute<Ch> *m_next_attribute;        // Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero
    //! \tparam Ch Character type to use.
    template<class Ch = char>
    class xml_node: public xml_base<Ch>
    {

    public:

        ///////////////////////////////////////////////////////////////////////////
        // Construction & destruction

    private:

        ///////////////////////////////////////////////////////////////////////////
        // Restrictions
    //! \tparam Ch Character type to use.
    template<class Ch = char>
    class xml_document: public xml_node<Ch>, public memory_pool<Ch>
    {

    public:

        //! Constructs empty XML document
        xml_document()
        //! \param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.
        template<int Flags>
        void parse(Ch *text)
        {
            assert(text);

    private:

        ///////////////////////////////////////////////////////////////////////
        // Internal character utility functions
        // Detect whitespace character
        struct whitespace_pred
        {
            static unsigned char test(Ch ch)
            {
                return internal::lookup_tables<0>::lookup_whitespace[static_cast<unsigned char>(ch)];
            }
        // Detect node name character
        struct node_name_pred
        {
            static unsigned char test(Ch ch)
            {
                return internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];
            }
        // Detect attribute name character
        struct attribute_name_pred
        {
            static unsigned char test(Ch ch)
            {
                return internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];
            }
        // Detect text character (PCDATA)
        struct text_pred
        {
            static unsigned char test(Ch ch)
            {
                return internal::lookup_tables<0>::lookup_text[static_cast<unsigned char>(ch)];
            }
        // Detect text character (PCDATA) that does not require processing
        struct text_pure_no_ws_pred
        {
            static unsigned char test(Ch ch)
            {
                return internal::lookup_tables<0>::lookup_text_pure_no_ws[static_cast<unsigned char>(ch)];
            }
        // Detect text character (PCDATA) that does not require processing
        struct text_pure_with_ws_pred
        {
            static unsigned char test(Ch ch)
            {
                return internal::lookup_tables<0>::lookup_text_pure_with_ws[static_cast<unsigned char>(ch)];
            }
        // Detect attribute value character
        template<Ch Quote>
        struct attribute_value_pred
        {
            static unsigned char test(Ch ch)
            {
                if (Quote == Ch('\''))
                    return internal::lookup_tables<0>::lookup_attribute_data_1[static_cast<unsigned char>(ch)];
        // Detect attribute value character
        template<Ch Quote>
        struct attribute_value_pure_pred
        {
            static unsigned char test(Ch ch)
            {
                if (Quote == Ch('\''))
                    return internal::lookup_tables<0>::lookup_attribute_data_1_pure[static_cast<unsigned char>(ch)];
        // Insert coded character, using UTF8 or 8-bit ASCII
        template<int Flags>
        static void insert_coded_character(Ch *&text, unsigned long code)
        {
            if (Flags & parse_no_utf8)
            {
        // Skip characters until predicate evaluates to true
        template<class StopPred, int Flags>
        static void skip(Ch *&text)
        {
            Ch *tmp = text;
            while (StopPred::test(*tmp))
        // - condensing whitespace sequences to single space character
        template<class StopPred, class StopPredPure, int Flags>
        static Ch *skip_and_expand_character_refs(Ch *&text, bool preserve_space)
        {
            // If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip
            if (Flags & parse_no_entity_translation &&
        // Parse BOM, if any
        template<int Flags>
        void parse_bom(Ch *&text)
        {
            // UTF-8?
            if (static_cast<unsigned char>(text[0]) == 0xEF &&
                static_cast<unsigned char>(text[1]) == 0xBB &&
                static_cast<unsigned char>(text[2]) == 0xBF)
            {
                text += 3;      // Skup utf-8 bom
            }
        // Parse XML declaration (<?xml...)
        template<int Flags>
        xml_node<Ch> *parse_xml_declaration(Ch *&text)
        {
            // If parsing of declaration is disabled
        // Parse XML comment (<!--...)
        template<int Flags>
        xml_node<Ch> *parse_comment(Ch *&text)
        {
            // If parsing of comments is disabled
        // Parse DOCTYPE
        template<int Flags>
        xml_node<Ch> *parse_doctype(Ch *&text)
        {
            // Remember value start
        // Parse PI
        template<int Flags>
        xml_node<Ch> *parse_pi(Ch *&text)
        {
            // If creation of PI nodes is enabled
        // This is necessary because this character might have been overwritten by a terminating 0
        template<int Flags>
        Ch parse_and_append_data(xml_node<Ch> *node, Ch *&text, Ch *contents_start)
        {
            // Backup to contents start if whitespace trimming is disabled
        // Parse CDATA
        template<int Flags>
        xml_node<Ch> *parse_cdata(Ch *&text)
        {
            // If CDATA is disabled
        // Parse element node
        template<int Flags>
        xml_node<Ch> *parse_element(Ch *&text)
        {
            // Create element node
        // Determine node type, and parse it
        template<int Flags>
        xml_node<Ch> *parse_node(Ch *&text)
        {
            // Parse proper node type
        // Parse contents of the node - children, data etc.
        template<int Flags>
        void parse_node_contents(Ch *&text, xml_node<Ch> *node)
        {
            // For all children and text
        // Parse XML attributes of the node
        template<int Flags>
        void parse_node_attributes(Ch *&text, xml_node<Ch> *node)
        {
            // For all attributes
    //! \cond internal
    namespace internal
    {

        // Whitespace (space \n \r \t)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_whitespace[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Node name (anything but space \n \r \t / > ? \0)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_node_name[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Text (i.e. PCDATA) (anything but < \0)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_text[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // (anything but < \0 &)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_text_pure_no_ws[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // (anything but < \0 & space \n \r \t)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_text_pure_with_ws[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Attribute name (anything but space \n \r \t / < > = ? ! \0)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_attribute_name[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Attribute data with single quote (anything but ' \0)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Attribute data with single quote that does not require processing (anything but ' \0 &)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1_pure[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Attribute data with double quote (anything but " \0)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Attribute data with double quote that does not require processing (anything but " \0 &)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2_pure[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Digits (dec and hex, 255 denotes end of numeric character reference)
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_digits[256] =
        {
          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        // Upper case conversion
        template<int Dummy>
        const unsigned char lookup_tables<Dummy>::lookup_upcase[256] =
        {
          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidxml/rapidxml_iterators.hpp =====
//========================================

namespace cereal {
namespace rapidxml
{

    //! Iterator of child nodes of xml_node
    template<class Ch>
    class node_iterator
    {

    public:

        typedef typename xml_node<Ch> value_type;
        typedef typename xml_node<Ch> &reference;
        typedef typename xml_node<Ch> *pointer;
        typedef std::ptrdiff_t difference_type;
        typedef std::bidirectional_iterator_tag iterator_category;

        node_iterator()
            : m_node(0)

    private:

        xml_node<Ch> *m_node;

    //! Iterator of child attributes of xml_node
    template<class Ch>
    class attribute_iterator
    {

    public:

        typedef typename xml_attribute<Ch> value_type;
        typedef typename xml_attribute<Ch> &reference;
        typedef typename xml_attribute<Ch> *pointer;
        typedef std::ptrdiff_t difference_type;
        typedef std::bidirectional_iterator_tag iterator_category;

        attribute_iterator()
            : m_attribute(0)

    private:

        xml_attribute<Ch> *m_attribute;



//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidxml/rapidxml_print.hpp =====
//========================================

namespace cereal {
namespace rapidxml
{

    ///////////////////////////////////////////////////////////////////////
    //! \cond internal
    namespace internal
    {

        ///////////////////////////////////////////////////////////////////////////
        // Copy characters from given range to given output iterator
        template<class OutIt, class Ch>
        inline OutIt copy_chars(const Ch *begin, const Ch *end, OutIt out)
        {
            while (begin != end)
        // characters into references (&lt; &gt; &apos; &quot; &amp;)
        template<class OutIt, class Ch>
        inline OutIt copy_and_expand_chars(const Ch *begin, const Ch *end, Ch noexpand, OutIt out)
        {
            while (begin != end)
        // Fill given output iterator with repetitions of the same character
        template<class OutIt, class Ch>
        inline OutIt fill_chars(OutIt out, int n, Ch ch)
        {
            for (int i = 0; i < n; ++i)
        // Find character
        template<class Ch, Ch ch>
        inline bool find_char(const Ch *begin, const Ch *end)
        {
            while (begin != end)
        // Print node
        template<class OutIt, class Ch>
        inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);

        // Print children of the node
        template<class OutIt, class Ch>
        inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            for (xml_node<Ch> *child = node->first_node(); child; child = child->next_sibling())
        // Print attributes of the node
        template<class OutIt, class Ch>
        inline OutIt print_attributes(OutIt out, const xml_node<Ch> *node, int /*flags*/)
        {
            for (xml_attribute<Ch> *attribute = node->first_attribute(); attribute; attribute = attribute->next_attribute())
        // Print data node
        template<class OutIt, class Ch>
        inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            assert(node->type() == node_data);
        // Print data node
        template<class OutIt, class Ch>
        inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            assert(node->type() == node_cdata);
        // Print element node
        template<class OutIt, class Ch>
        inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            assert(node->type() == node_element);
        // Print declaration node
        template<class OutIt, class Ch>
        inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            // Print declaration start
        // Print comment node
        template<class OutIt, class Ch>
        inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            assert(node->type() == node_comment);
        // Print doctype node
        template<class OutIt, class Ch>
        inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            assert(node->type() == node_doctype);
        // Print pi node
        template<class OutIt, class Ch>
        inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            assert(node->type() == node_pi);
        // Print node
        template<class OutIt, class Ch>
        inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
        {
            // Print proper node type
    //! \return Output iterator pointing to position immediately after last character of printed text.
    template<class OutIt, class Ch>
    inline OutIt print(OutIt out, const xml_node<Ch> &node, int flags = 0)
    {
        return internal::print_node(out, &node, flags, 0);
    //! \return Output stream.
    template<class Ch>
    inline std::basic_ostream<Ch> &print(std::basic_ostream<Ch> &out, const xml_node<Ch> &node, int flags = 0)
    {
        print(std::ostream_iterator<Ch>(out), node, flags);
    //! \return Output stream.
    template<class Ch>
    inline std::basic_ostream<Ch> &operator <<(std::basic_ostream<Ch> &out, const xml_node<Ch> &node)
    {
        return print(out, node);


//========================================
//===== File: ./third-party/cereal/include/cereal/external/rapidxml/rapidxml_utils.hpp =====
//========================================

namespace cereal {
namespace rapidxml
{

    //! Represents data loaded from a file
    template<class Ch = char>
    class file
    {

    public:

        //! Loads file into the memory. Data will be automatically destroyed by the destructor.
        //! \param filename Filename to load.

    private:

        std::vector<Ch> m_data;   // File data

    //! \return Number of children of node
    template<class Ch>
    inline std::size_t count_children(xml_node<Ch> *node)
    {
        xml_node<Ch> *child = node->first_node();
    //! \return Number of attributes of node
    template<class Ch>
    inline std::size_t count_attributes(xml_node<Ch> *node)
    {
        xml_attribute<Ch> *attr = node->first_attribute();


//========================================
//===== File: ./third-party/cereal/include/cereal/macros.hpp =====
//========================================


//========================================
//===== File: ./third-party/cereal/include/cereal/specialize.hpp =====
//========================================

namespace cereal
{
  // Forward declaration of access class that users can become friends with
  class access;

  // ######################################################################
  //! A specifier used in conjunction with cereal::specialize to disambiguate
      @ingroup Access */
  enum class specialization
  {
    member_serialize,            //!< Force the use of a member serialize function
    member_load_save,            //!< Force the use of a member load/save pair
      This can happen because you have both a serialize and load/save pair, or even because a base
      class has a serialize (public or private with friend access) and a derived class does not
      overwrite this due to choosing some other serialization type.

      Specializing this class will tell cereal to explicitly use the serialization type you specify
      @code{.cpp}
      class MyParent
      {
        friend class cereal::access;
        template <class Archive>
        void serialize( Archive & ar ) {}
      };

      // even through MyDerived
      class MyDerived : public MyParent
      {
        public:
          template <class Archive>
          void load( Archive & ar ) {}

          template <class Archive>
          void save( Archive & ar ) {}
      };


      namespace cereal
      {
        // This struct specialization will tell cereal which is the right way to serialize the ambiguity
        template <class Archive> struct specialize<Archive, MyDerived, cereal::specialization::member_load_save> {};

        // If we only had a disambiguation for a specific archive type, it would look something like this
        template <> struct specialize<cereal::BinaryOutputArchive, MyDerived, cereal::specialization::member_load_save> {};
      }
      @endcode

      @ingroup Access */
  template <class Archive, class T, specialization S>
  struct specialize : public std::false_type {};

  //! Convenient macro for performing specialization for all archive types
  /*! This performs specialization for the specific type for all types of archives.
      @code{cpp}
      struct MyType {};
      CEREAL_SPECIALIZE_FOR_ALL_ARCHIVES( MyType, cereal::specialization::member_load_save );
      @endcode

  #define CEREAL_SPECIALIZE_FOR_ALL_ARCHIVES( Type, Specialization )                                \
  namespace cereal { template <class Archive> struct specialize<Archive, Type, Specialization> {}; }

  //! Convenient macro for performing specialization for a single archive type
  /*! This performs specialization for the specific type for a single type of archive.
      @code{cpp}
      struct MyType {};
      CEREAL_SPECIALIZE_FOR_ARCHIVE( cereal::XMLInputArchive, MyType, cereal::specialization::member_load_save );
      @endcode

  #define CEREAL_SPECIALIZE_FOR_ARCHIVE( Archive, Type, Specialization )               \
  namespace cereal { template <> struct specialize<Archive, Type, Specialization> {}; }
}

#endif


//========================================
//===== File: ./third-party/cereal/include/cereal/types/array.hpp =====
//========================================

namespace cereal
{
  //! Saving for std::array primitive types
  //! using binary serialization, if supported
  template <class Archive, class T, size_t N> inline
  typename std::enable_if<traits::is_output_serializable<BinaryData<T>, Archive>::value
                          && std::is_arithmetic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::array<T, N> const & array )
  //! using binary serialization, if supported
  template <class Archive, class T, size_t N> inline
  typename std::enable_if<traits::is_input_serializable<BinaryData<T>, Archive>::value
                          && std::is_arithmetic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::array<T, N> & array )
  //! Saving for std::array all other types
  template <class Archive, class T, size_t N> inline
  typename std::enable_if<!traits::is_output_serializable<BinaryData<T>, Archive>::value
                          || !std::is_arithmetic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::array<T, N> const & array )
  //! Loading for std::array all other types
  template <class Archive, class T, size_t N> inline
  typename std::enable_if<!traits::is_input_serializable<BinaryData<T>, Archive>::value
                          || !std::is_arithmetic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::array<T, N> & array )


//========================================
//===== File: ./third-party/cereal/include/cereal/types/atomic.hpp =====
//========================================

namespace cereal
{
  //! Serializing (save) for std::atomic
  template <class Archive, class T> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::atomic<T> const & a )
  {
    ar( CEREAL_NVP_("atomic_data", a.load()) );
  //! Serializing (load) for std::atomic
  template <class Archive, class T> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::atomic<T> & a )
  {
    T tmp;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/base_class.hpp =====
//========================================

namespace cereal
{
  namespace base_class_detail
  {
    //! Used to register polymorphic relations and avoid the need to include
    //! polymorphic.hpp when no polymorphism is used
    /*! @internal */
    template <class Base, class Derived, bool IsPolymorphic = std::is_polymorphic<Base>::value>
    struct RegisterPolymorphicBaseClass
    {
      static void bind()
      { }
    };

    /*! @internal */
    template <class Base, class Derived>
    struct RegisterPolymorphicBaseClass<Base, Derived, true>
    {
      static void bind()
      { detail::RegisterPolymorphicCaster<Base, Derived>::bind(); }
    };
  }
      @code{.cpp}
      struct MyBase
      {
        int x;

        virtual void foo() = 0;

        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( x );

      struct MyDerived : public MyBase //<-- Note non-virtual inheritance
      {
        int y;

        virtual void foo() {};

        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( cereal::base_class<MyBase>(this) );
      @endcode */
  template<class Base>
    struct base_class : private traits::detail::BaseCastBase
    {
      template<class Derived>
        base_class(Derived const * derived) :
          base_ptr(const_cast<Base*>(static_cast<Base const *>(derived)))
      {
        static_assert( std::is_base_of<Base, Derived>::value, "Can only use base_class on a valid base class" );
        base_class_detail::RegisterPolymorphicBaseClass<Base, Derived>::bind();
      }

      @code{.cpp}
      struct MyBase
      {
        int x;

        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( x );

      struct MyLeft : virtual MyBase //<-- Note the virtual inheritance
      {
        int y;

        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( cereal::virtual_base_class<MyBase>( this ) );

      struct MyRight : virtual MyBase
      {
        int z;

        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( cereal::virtual_base_clas<MyBase>( this ) );
      // diamond virtual inheritance; contains one copy of each base class
      struct MyDerived : virtual MyLeft, virtual MyRight
      {
        int a;

        template <class Archive>
        void serialize( Archive & ar )
        {
          ar( cereal::virtual_base_class<MyLeft>( this ) );  // safely serialize data members in MyLeft
     @endcode */
  template<class Base>
    struct virtual_base_class : private traits::detail::BaseCastBase
    {
      template<class Derived>
        virtual_base_class(Derived const * derived) :
          base_ptr(const_cast<Base*>(static_cast<Base const *>(derived)))
      {
        static_assert( std::is_base_of<Base, Derived>::value, "Can only use virtual_base_class on a valid base class" );
        base_class_detail::RegisterPolymorphicBaseClass<Base, Derived>::bind();
      }



//========================================
//===== File: ./third-party/cereal/include/cereal/types/bitset.hpp =====
//========================================

namespace cereal
{
  namespace bitset_detail
  {
    //! The type the bitset is encoded with
    /*! @internal */
    enum class type : uint8_t
    {
      ulong,
      ullong,
  //! Serializing (save) for std::bitset when BinaryData optimization supported
  template <class Archive, size_t N,
            traits::EnableIf<traits::is_output_serializable<BinaryData<std::uint32_t>, Archive>::value>
            = traits::sfinae> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::bitset<N> const & bits )
  //! Serializing (save) for std::bitset when BinaryData is not supported
  template <class Archive, size_t N,
            traits::DisableIf<traits::is_output_serializable<BinaryData<std::uint32_t>, Archive>::value>
            = traits::sfinae> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::bitset<N> const & bits )
  //! Serializing (load) for std::bitset
  template <class Archive, size_t N> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::bitset<N> & bits )
  {
    bitset_detail::type t;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/boost_variant.hpp =====
//========================================

namespace cereal
{
  namespace boost_variant_detail
  {
    //! @internal
    template <class Archive>
    struct variant_save_visitor : boost::static_visitor<>
    {
      variant_save_visitor(Archive & ar_) : ar(ar_) {}

      template<class T>
      void operator()(T const & value) const
      {
        ar( CEREAL_NVP_("data", value) );
    //! @internal
    template <class Archive, class T>
    struct LoadAndConstructLoadWrapper
    {
      using ST = typename std::aligned_storage<sizeof(T), CEREAL_ALIGNOF(T)>::type;

    //! @internal
    template <class T> struct load_variant_wrapper;

    //! Avoid serializing variant void_ type
    /*! @internal */
    template <>
    struct load_variant_wrapper<boost::detail::variant::void_>
    {
      template <class Variant, class Archive>
      static void load_variant( Archive &, Variant & )
      { }
    };

    //! @internal
    template <class T>
    struct load_variant_wrapper
    {
      // default constructible
      template <class Archive, class Variant>
      static void load_variant_impl( Archive & ar, Variant & variant, std::true_type )
      {
        T value;
        ar( CEREAL_NVP_("data", value) );
      // not default constructible
      template<class Variant, class Archive>
      static void load_variant_impl(Archive & ar, Variant & variant, std::false_type )
      {
        LoadAndConstructLoadWrapper<Archive, T> loadWrapper;

      //! @internal
      template<class Variant, class Archive>
      static void load_variant(Archive & ar, Variant & variant)
      {
        load_variant_impl( ar, variant, typename std::is_default_constructible<T>::type() );
      }
  //! Saving for boost::variant
  template <class Archive, typename ... VariantTypes> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, boost::variant<VariantTypes...> const & variant )
  {
    int32_t which = variant.which();
  //! Loading for boost::variant
  template <class Archive, typename ... VariantTypes> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, boost::variant<VariantTypes...> & variant )
  {
    int32_t which;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/chrono.hpp =====
//========================================

namespace cereal
{
  //! Saving std::chrono::duration
  template <class Archive, class R, class P> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::chrono::duration<R, P> const & dur )
  {
    ar( CEREAL_NVP_("count", dur.count()) );
  //! Loading std::chrono::duration
  template <class Archive, class R, class P> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::chrono::duration<R, P> & dur )
  {
    R count;
  //! Saving std::chrono::time_point
  template <class Archive, class C, class D> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::chrono::time_point<C, D> const & dur )
  {
    ar( CEREAL_NVP_("time_since_epoch", dur.time_since_epoch()) );
  //! Loading std::chrono::time_point
  template <class Archive, class C, class D> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::chrono::time_point<C, D> & dur )
  {
    D elapsed;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/common.hpp =====
//========================================

namespace cereal
{
  namespace common_detail
  {
    //! Serialization for arrays if BinaryData is supported and we are arithmetic
    /*! @internal */
    template <class Archive, class T> inline
    void serializeArray( Archive & ar, T & array, std::true_type /* binary_supported */ )
    {
      ar( binary_data( array, sizeof(array) ) );
    /*! @internal */
    template <class Archive, class T> inline
    void serializeArray( Archive & ar, T & array, std::false_type /* binary_supported */ )
    {
      for( auto & i : array )

    namespace
    {
      //! Gets the underlying type of an enum
      /*! @internal */
      template <class T, bool IsEnum>
      struct enum_underlying_type : std::false_type {};

      //! Gets the underlying type of an enum
      /*! Specialization for when we actually have an enum
          @internal */
      template <class T>
      struct enum_underlying_type<T, true> { using type = typename std::underlying_type<T>::type; };
    } // anon namespace

    //! Checks if a type is an enum
        @internal */
    template <class T>
    class is_enum
    {
      private:
        using DecayedT  = typename std::decay<T>::type;
        using StrippedT = typename ::cereal::traits::strip_minimal<DecayedT>::type;

      public:
        static const bool value = std::is_enum<StrippedT>::value;
        using type = StrippedT;
        using base_type = typename enum_underlying_type<StrippedT, value>::type;
    };
  //! Saving for enum types
  template <class Archive, class T> inline
  typename std::enable_if<common_detail::is_enum<T>::value,
                          typename common_detail::is_enum<T>::base_type>::type
  CEREAL_SAVE_MINIMAL_FUNCTION_NAME( Archive const &, T const & t )
  //! Loading for enum types
  template <class Archive, class T> inline
  typename std::enable_if<common_detail::is_enum<T>::value, void>::type
  CEREAL_LOAD_MINIMAL_FUNCTION_NAME( Archive const &, T && t,
                                     typename common_detail::is_enum<T>::base_type const & value )
  /*! This exists only to throw a static_assert to let users know we don't support raw pointers. */
  template <class Archive, class T> inline
  void CEREAL_SERIALIZE_FUNCTION_NAME( Archive &, T * & )
  {
    static_assert(cereal::traits::detail::delay_static_assert<T>::value,
      "Cereal does not support serializing raw pointers - please use a smart pointer");
  }

  //! Serialization for C style arrays
  template <class Archive, class T> inline
  typename std::enable_if<std::is_array<T>::value, void>::type
  CEREAL_SERIALIZE_FUNCTION_NAME(Archive & ar, T & array)
  {


//========================================
//===== File: ./third-party/cereal/include/cereal/types/complex.hpp =====
//========================================

namespace cereal
{
  //! Serializing (save) for std::complex
  template <class Archive, class T> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::complex<T> const & comp )
  {
    ar( CEREAL_NVP_("real", comp.real()),
  //! Serializing (load) for std::complex
  template <class Archive, class T> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::complex<T> & bits )
  {
    T real, imag;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/concepts/pair_associative_container.hpp =====
//========================================

namespace cereal
{
  //! Saving for std-like pair associative containers
  template <class Archive, template <typename...> class Map, typename... Args, typename = typename Map<Args...>::mapped_type> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, Map<Args...> const & map )
  {
    ar( make_size_tag( static_cast<size_type>(map.size()) ) );
  //! Loading for std-like pair associative containers
  template <class Archive, template <typename...> class Map, typename... Args, typename = typename Map<Args...>::mapped_type> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, Map<Args...> & map )
  {
    size_type size;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/deque.hpp =====
//========================================

namespace cereal
{
  //! Saving for std::deque
  template <class Archive, class T, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::deque<T, A> const & deque )
  {
    ar( make_size_tag( static_cast<size_type>(deque.size()) ) );
  //! Loading for std::deque
  template <class Archive, class T, class A> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::deque<T, A> & deque )
  {
    size_type size;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/forward_list.hpp =====
//========================================

namespace cereal
{
  //! Saving for std::forward_list all other types
  template <class Archive, class T, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::forward_list<T, A> const & forward_list )
  {
    // write the size - note that this is slow because we need to traverse
  //! Loading for std::forward_list all other types from
  template <class Archive, class T, class A>
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::forward_list<T, A> & forward_list )
  {
    size_type size;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/functional.hpp =====
//========================================

namespace cereal
{
  //! Saving for std::less
  template <class Archive, class T> inline
  void serialize( Archive &, std::less<T> & )
  { }
} // namespace cereal


//========================================
//===== File: ./third-party/cereal/include/cereal/types/list.hpp =====
//========================================

namespace cereal
{
  //! Saving for std::list
  template <class Archive, class T, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::list<T, A> const & list )
  {
    ar( make_size_tag( static_cast<size_type>(list.size()) ) );
  //! Loading for std::list
  template <class Archive, class T, class A> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::list<T, A> & list )
  {
    size_type size;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/map.hpp =====
//========================================


//========================================
//===== File: ./third-party/cereal/include/cereal/types/memory.hpp =====
//========================================

namespace cereal
{
  namespace memory_detail
  {
    //! A wrapper class to notify cereal that it is ok to serialize the contained pointer
    /*! This mechanism allows us to intercept and properly handle polymorphic pointers
        @internal */
    template<class T>
    struct PtrWrapper
    {
      PtrWrapper(T && p) : ptr(std::forward<T>(p)) {}
      T & ptr;
    /*! @internal */
    template<class T> inline
    PtrWrapper<T> make_ptr_wrapper(T && t)
    {
      return {std::forward<T>(t)};
        @internal */
    template <class Archive, class T>
    struct LoadAndConstructLoadWrapper
    {
      LoadAndConstructLoadWrapper( T * ptr ) :
        construct( ptr )
      //! Constructor for embedding an early call for restoring shared_from_this
      template <class F>
      LoadAndConstructLoadWrapper( T * ptr, F && sharedFromThisFunc ) :
        construct( ptr, sharedFromThisFunc )
      { }
        @internal */
    template <class T>
    class EnableSharedStateHelper
    {
      // typedefs for parent type and storage type
      using BaseType = typename ::cereal::traits::get_shared_from_this_base<T>::type;

      public:
        //! Saves the state of some type inheriting from enable_shared_from_this
        /*! @param ptr The raw pointer held by the shared_ptr */
        inline EnableSharedStateHelper( T * ptr ) :

      private:
        ParentType * itsPtr;
        StorageType itsState;
        bool itsRestored;
        @internal */
    template <class Archive, class T> inline
    void loadAndConstructSharedPtr( Archive & ar, T * ptr, std::true_type /* has_shared_from_this */ )
    {
      memory_detail::EnableSharedStateHelper<T> state( ptr );
        @internal */
    template <class Archive, class T> inline
    void loadAndConstructSharedPtr( Archive & ar, T * ptr, std::false_type /* has_shared_from_this */ )
    {
      memory_detail::LoadAndConstructLoadWrapper<Archive, T> loadWrapper( ptr );
  //! Saving std::shared_ptr for non polymorphic types
  template <class Archive, class T> inline
  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> const & ptr )
  {
  //! Loading std::shared_ptr, case when no user load and construct for non polymorphic types
  template <class Archive, class T> inline
  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> & ptr )
  {
  //! Saving std::weak_ptr for non polymorphic types
  template <class Archive, class T> inline
  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> const & ptr )
  {
  //! Loading std::weak_ptr for non polymorphic types
  template <class Archive, class T> inline
  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> & ptr )
  {
  //! Saving std::unique_ptr for non polymorphic types
  template <class Archive, class T, class D> inline
  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> const & ptr )
  {
  //! Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types
  template <class Archive, class T, class D> inline
  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> & ptr )
  {
  /*! @internal */
  template <class Archive, class T> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> const &> const & wrapper )
  {
    auto & ptr = wrapper.ptr;
  /*! @internal */
  template <class Archive, class T> inline
  typename std::enable_if<traits::has_load_and_construct<T, Archive>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> &> & wrapper )
  {
  /*! @internal */
  template <class Archive, class T> inline
  typename std::enable_if<!traits::has_load_and_construct<T, Archive>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> &> & wrapper )
  {
  /*! @internal */
  template <class Archive, class T, class D> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::unique_ptr<T, D> const &> const & wrapper )
  {
    auto & ptr = wrapper.ptr;
  /*! @internal */
  template <class Archive, class T, class D> inline
  typename std::enable_if<traits::has_load_and_construct<T, Archive>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::unique_ptr<T, D> &> & wrapper )
  {
  /*! @internal */
  template <class Archive, class T, class D> inline
  typename std::enable_if<!traits::has_load_and_construct<T, Archive>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::unique_ptr<T, D> &> & wrapper )
  {


//========================================
//===== File: ./third-party/cereal/include/cereal/types/optional.hpp =====
//========================================

namespace cereal {
  //! Saving for std::optional
  template <class Archive, typename T> inline
  void CEREAL_SAVE_FUNCTION_NAME(Archive& ar, const std::optional<T>& optional)
  {
    if(!optional) {
  //! Loading for std::optional
  template <class Archive, typename T> inline
  void CEREAL_LOAD_FUNCTION_NAME(Archive& ar, std::optional<T>& optional)
  {
    bool nullopt;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/polymorphic.hpp =====
//========================================
    pointers to them can be serialized.  Note that base
    classes do not need to be registered.

    Registering a type lets cereal know how to properly
    serialize it when a smart pointer to a base object is
#define CEREAL_REGISTER_TYPE(...)                                        \
  namespace cereal {                                                     \
  namespace detail {                                                     \
  template <>                                                            \
  struct binding_name<__VA_ARGS__>                                       \
  {                                                                      \
    CEREAL_STATIC_CONSTEXPR char const * name() { return #__VA_ARGS__; } \
  };                                                                     \
#define CEREAL_REGISTER_TYPE_WITH_NAME(T, Name)                     \
  namespace cereal {                                                \
  namespace detail {                                                \
  template <>                                                       \
  struct binding_name<T>                                            \
  { CEREAL_STATIC_CONSTEXPR char const * name() { return Name; } }; \
  } } /* end namespaces */                                          \
  CEREAL_BIND_TO_ARCHIVES(T)
    and the Base type any possible base that has not been covered under a base
    class serialization that will be used to store a Derived pointer.

    Placement of this is the same as for CEREAL_REGISTER_TYPE. */
#define CEREAL_REGISTER_POLYMORPHIC_RELATION(Base, Derived)                     \
  namespace cereal {                                                            \
  namespace detail {                                                            \
  template <>                                                                   \
  struct PolymorphicRelation<Base, Derived>                                     \
  { static void bind() { RegisterPolymorphicCaster<Base, Derived>::bind(); } }; \
  } } /* end namespaces */

#define CEREAL_REGISTER_DYNAMIC_INIT(LibName)                \
  namespace cereal {                                         \
  namespace detail {                                         \
    void CEREAL_DLL_EXPORT dynamic_init_dummy_##LibName() {} \
  } } /* end namespaces */

#define CEREAL_FORCE_DYNAMIC_INIT(LibName)                 \
  namespace cereal {                                       \
  namespace detail {                                       \
    void CEREAL_DLL_EXPORT dynamic_init_dummy_##LibName(); \
  } /* end detail */                                       \
  } /* end cereal */                                       \
  namespace {                                              \
    struct dynamic_init_##LibName {                        \
      dynamic_init_##LibName() {                           \
        ::cereal::detail::dynamic_init_dummy_##LibName();  \
      }                                                    \

namespace cereal
{
  namespace polymorphic_detail
  {
    //! Error message used for unregistered polymorphic types
    /*! @internal */
    /*! @internal */
    template<class Archive> inline
    typename ::cereal::detail::InputBindingMap<Archive>::Serializers getInputBinding(Archive & ar, std::uint32_t const nameid)
    {
      // If the nameid is zero, we serialized a null pointer
        @internal */
    template<class Archive, class T> inline
    typename std::enable_if<(traits::is_default_constructible<T>::value
                             || traits::has_load_and_construct<T, Archive>::value)
                             && !std::is_abstract<T>::value, bool>::type
        @internal */
    template<class Archive, class T, class D> inline
    typename std::enable_if<(traits::is_default_constructible<T>::value
                             || traits::has_load_and_construct<T, Archive>::value)
                             && !std::is_abstract<T>::value, bool>::type
        @internal */
    template<class Archive, class T> inline
    typename std::enable_if<(!traits::is_default_constructible<T>::value
                             && !traits::has_load_and_construct<T, Archive>::value)
                             || std::is_abstract<T>::value, bool>::type
        @internal */
    template<class Archive, class T, class D> inline
     typename std::enable_if<(!traits::is_default_constructible<T>::value
                               && !traits::has_load_and_construct<T, Archive>::value)
                               || std::is_abstract<T>::value, bool>::type
  //! Saving std::shared_ptr for polymorphic types, abstract
  template <class Archive, class T> inline
  typename std::enable_if<std::is_polymorphic<T>::value && std::is_abstract<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> const & ptr )
  {
    std::type_info const & ptrinfo = typeid(*ptr.get());
    static std::type_info const & tinfo = typeid(T);
    // ptrinfo can never be equal to T info since we can't have an instance
    // of an abstract object
    //  this implies we need to do the lookup
  //! Saving std::shared_ptr for polymorphic types, not abstract
  template <class Archive, class T> inline
  typename std::enable_if<std::is_polymorphic<T>::value && !std::is_abstract<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> const & ptr )
  {
    std::type_info const & ptrinfo = typeid(*ptr.get());
    static std::type_info const & tinfo = typeid(T);

    if(ptrinfo == tinfo)
    {
  //! Loading std::shared_ptr for polymorphic types
  template <class Archive, class T> inline
  typename std::enable_if<std::is_polymorphic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> & ptr )
  {
  //! Saving std::weak_ptr for polymorphic types
  template <class Archive, class T> inline
  typename std::enable_if<std::is_polymorphic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> const & ptr )
  {
  //! Loading std::weak_ptr for polymorphic types
  template <class Archive, class T> inline
  typename std::enable_if<std::is_polymorphic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> & ptr )
  {
  //! Saving std::unique_ptr for polymorphic types that are abstract
  template <class Archive, class T, class D> inline
  typename std::enable_if<std::is_polymorphic<T>::value && std::is_abstract<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> const & ptr )
  {
    std::type_info const & ptrinfo = typeid(*ptr.get());
    static std::type_info const & tinfo = typeid(T);
    // ptrinfo can never be equal to T info since we can't have an instance
    // of an abstract object
    //  this implies we need to do the lookup
  //! Saving std::unique_ptr for polymorphic types, not abstract
  template <class Archive, class T, class D> inline
  typename std::enable_if<std::is_polymorphic<T>::value && !std::is_abstract<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> const & ptr )
  {
    std::type_info const & ptrinfo = typeid(*ptr.get());
    static std::type_info const & tinfo = typeid(T);

    if(ptrinfo == tinfo)
    {
  //! Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types
  template <class Archive, class T, class D> inline
  typename std::enable_if<std::is_polymorphic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> & ptr )
  {


//========================================
//===== File: ./third-party/cereal/include/cereal/types/queue.hpp =====
//========================================

namespace cereal
{
  namespace queue_detail
  {
    //! Allows access to the protected container in queue
    /*! @internal */
    template <class T, class C> inline
    C const & container( std::queue<T, C> const & queue )
    {
      struct H : public std::queue<T, C>
      {
        static C const & get( std::queue<T, C> const & q )
        {
          return q.*(&H::c);
        }
    /*! @internal */
    template <class T, class C, class Comp> inline
    C const & container( std::priority_queue<T, C, Comp> const & priority_queue )
    {
      struct H : public std::priority_queue<T, C, Comp>
      {
        static C const & get( std::priority_queue<T, C, Comp> const & pq )
        {
          return pq.*(&H::c);
        }
    /*! @internal */
    template <class T, class C, class Comp> inline
    Comp const & comparator( std::priority_queue<T, C, Comp> const & priority_queue )
    {
      struct H : public std::priority_queue<T, C, Comp>
      {
        static Comp const & get( std::priority_queue<T, C, Comp> const & pq )
        {
          return pq.*(&H::comp);
        }
  //! Saving for std::queue
  template <class Archive, class T, class C> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::queue<T, C> const & queue )
  {
    ar( CEREAL_NVP_("container", queue_detail::container( queue )) );
  //! Loading for std::queue
  template <class Archive, class T, class C> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::queue<T, C> & queue )
  {
    C container;
  //! Saving for std::priority_queue
  template <class Archive, class T, class C, class Comp> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::priority_queue<T, C, Comp> const & priority_queue )
  {
    ar( CEREAL_NVP_("comparator", queue_detail::comparator( priority_queue )) );
  //! Loading for std::priority_queue
  template <class Archive, class T, class C, class Comp> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::priority_queue<T, C, Comp> & priority_queue )
  {
    Comp comparator;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/set.hpp =====
//========================================

namespace cereal
{
  namespace set_detail
  {
    //! @internal
    template <class Archive, class SetT> inline
    void save( Archive & ar, SetT const & set )
    {
      ar( make_size_tag( static_cast<size_type>(set.size()) ) );
    //! @internal
    template <class Archive, class SetT> inline
    void load( Archive & ar, SetT & set )
    {
      size_type size;
  //! Saving for std::set
  template <class Archive, class K, class C, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::set<K, C, A> const & set )
  {
    set_detail::save( ar, set );
  //! Loading for std::set
  template <class Archive, class K, class C, class A> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::set<K, C, A> & set )
  {
    set_detail::load( ar, set );
  //! Saving for std::multiset
  template <class Archive, class K, class C, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::multiset<K, C, A> const & multiset )
  {
    set_detail::save( ar, multiset );
  //! Loading for std::multiset
  template <class Archive, class K, class C, class A> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::multiset<K, C, A> & multiset )
  {
    set_detail::load( ar, multiset );


//========================================
//===== File: ./third-party/cereal/include/cereal/types/stack.hpp =====
//========================================

namespace cereal
{
  namespace stack_detail
  {
    //! Allows access to the protected container in stack
    template <class T, class C> inline
    C const & container( std::stack<T, C> const & stack )
    {
      struct H : public std::stack<T, C>
      {
        static C const & get( std::stack<T, C> const & s )
        {
          return s.*(&H::c);
        }
  //! Saving for std::stack
  template <class Archive, class T, class C> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::stack<T, C> const & stack )
  {
    ar( CEREAL_NVP_("container", stack_detail::container( stack )) );
  //! Loading for std::stack
  template <class Archive, class T, class C> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::stack<T, C> & stack )
  {
    C container;


//========================================
//===== File: ./third-party/cereal/include/cereal/types/string.hpp =====
//========================================

namespace cereal
{
  //! Serialization for basic_string types, if binary data is supported
  template<class Archive, class CharT, class Traits, class Alloc> inline
  typename std::enable_if<traits::is_output_serializable<BinaryData<CharT>, Archive>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME(Archive & ar, std::basic_string<CharT, Traits, Alloc> const & str)
  {
  //! Serialization for basic_string types, if binary data is supported
  template<class Archive, class CharT, class Traits, class Alloc> inline
  typename std::enable_if<traits::is_input_serializable<BinaryData<CharT>, Archive>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME(Archive & ar, std::basic_string<CharT, Traits, Alloc> & str)
  {


//========================================
//===== File: ./third-party/cereal/include/cereal/types/tuple.hpp =====
//========================================

namespace cereal
{
  namespace tuple_detail
  {
    //! Creates a c string from a sequence of characters
    /*! The c string created will always be prefixed by "tuple_element"
        @internal */
    template<char...Cs>
    struct char_seq_to_c_str
    {
      static const int size = 14;// Size of array for the word: tuple_element
      typedef const char (&arr_type)[sizeof...(Cs) + size];
      static const char str[sizeof...(Cs) + size];
    };

    // the word tuple_element plus a number
    //! @internal
    template<char...Cs>
    const char char_seq_to_c_str<Cs...>::str[sizeof...(Cs) + size] =
      {'t','u','p','l','e','_','e','l','e','m','e','n','t', Cs..., '\0'};

        @internal */
    template <size_t Q, size_t R, char ... C>
    struct to_string_impl
    {
      using type = typename to_string_impl<Q/10, Q%10, static_cast<char>(R+std::size_t{'0'}), C...>::type;
    };
    /*! @internal */
    template <size_t R, char ... C>
    struct to_string_impl<0, R, C...>
    {
      using type = char_seq_to_c_str<static_cast<char>(R+std::size_t{'0'}), C...>;
    };
        @internal */
    template<size_t T>
    struct tuple_element_name
    {
      using type = typename to_string_impl<T/10, T%10>::type;
      static const typename type::arr_type c_str(){ return type::str; }
    };

    // unwinds a tuple to save it
    //! @internal
    template <size_t Height>
    struct serialize
    {
      template <class Archive, class ... Types> inline
      static void apply( Archive & ar, std::tuple<Types...> & tuple )
      {
        serialize<Height - 1>::template apply( ar, tuple );
        ar( CEREAL_NVP_(tuple_element_name<Height - 1>::c_str(),
    //! @internal
    template <>
    struct serialize<0>
    {
      template <class Archive, class ... Types> inline
      static void apply( Archive &, std::tuple<Types...> & )
      { }
    };
  }
  //! Serializing for std::tuple
  template <class Archive, class ... Types> inline
  void CEREAL_SERIALIZE_FUNCTION_NAME( Archive & ar, std::tuple<Types...> & tuple )
  {
    tuple_detail::serialize<std::tuple_size<std::tuple<Types...>>::value>::template apply( ar, tuple );


//========================================
//===== File: ./third-party/cereal/include/cereal/types/unordered_map.hpp =====
//========================================


//========================================
//===== File: ./third-party/cereal/include/cereal/types/unordered_set.hpp =====
//========================================

namespace cereal
{
  namespace unordered_set_detail
  {
    //! @internal
    template <class Archive, class SetT> inline
    void save( Archive & ar, SetT const & set )
    {
      ar( make_size_tag( static_cast<size_type>(set.size()) ) );
    //! @internal
    template <class Archive, class SetT> inline
    void load( Archive & ar, SetT & set )
    {
      size_type size;
  //! Saving for std::unordered_set
  template <class Archive, class K, class H, class KE, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unordered_set<K, H, KE, A> const & unordered_set )
  {
    unordered_set_detail::save( ar, unordered_set );
  //! Loading for std::unordered_set
  template <class Archive, class K, class H, class KE, class A> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::unordered_set<K, H, KE, A> & unordered_set )
  {
    unordered_set_detail::load( ar, unordered_set );
  //! Saving for std::unordered_multiset
  template <class Archive, class K, class H, class KE, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unordered_multiset<K, H, KE, A> const & unordered_multiset )
  {
    unordered_set_detail::save( ar, unordered_multiset );
  //! Loading for std::unordered_multiset
  template <class Archive, class K, class H, class KE, class A> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::unordered_multiset<K, H, KE, A> & unordered_multiset )
  {
    unordered_set_detail::load( ar, unordered_multiset );


//========================================
//===== File: ./third-party/cereal/include/cereal/types/utility.hpp =====
//========================================

namespace cereal
{
  //! Serializing for std::pair
  template <class Archive, class T1, class T2> inline
  void CEREAL_SERIALIZE_FUNCTION_NAME( Archive & ar, std::pair<T1, T2> & pair )
  {
    ar( CEREAL_NVP_("first",  pair.first),


//========================================
//===== File: ./third-party/cereal/include/cereal/types/valarray.hpp =====
//========================================

namespace cereal
{
  //! Saving for std::valarray arithmetic types, using binary serialization, if supported
  template <class Archive, class T> inline
  typename std::enable_if<traits::is_output_serializable<BinaryData<T>, Archive>::value
                          && std::is_arithmetic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::valarray<T> const & valarray )
  //! Loading for std::valarray arithmetic types, using binary serialization, if supported
  template <class Archive, class T> inline
  typename std::enable_if<traits::is_input_serializable<BinaryData<T>, Archive>::value
                          && std::is_arithmetic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::valarray<T> & valarray )
  //! Saving for std::valarray all other types
  template <class Archive, class T> inline
  typename std::enable_if<!traits::is_output_serializable<BinaryData<T>, Archive>::value
                          || !std::is_arithmetic<T>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::valarray<T> const & valarray )
  //! Loading for std::valarray all other types
  template <class Archive, class T> inline
  typename std::enable_if<!traits::is_input_serializable<BinaryData<T>, Archive>::value
                          || !std::is_arithmetic<T>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::valarray<T> & valarray )


//========================================
//===== File: ./third-party/cereal/include/cereal/types/variant.hpp =====
//========================================

namespace cereal
{
  namespace variant_detail
  {
    //! @internal
    template <class Archive>
    struct variant_save_visitor
    {
      variant_save_visitor(Archive & ar_) : ar(ar_) {}

      template<class T>
        void operator()(T const & value) const
        {
          ar( CEREAL_NVP_("data", value) );
    //! @internal
    template<int N, class Variant, class Archive>
    typename std::enable_if<N == std::variant_size_v<Variant>, void>::type
    load_variant(Archive & /*ar*/, int /*target*/, Variant & /*variant*/)
    {
    //! @internal
    template<int N, class Variant, class Archive>
    typename std::enable_if<N < std::variant_size_v<Variant>, void>::type
    load_variant(Archive & ar, int target, Variant & variant)
    {
  //! Saving for std::variant
  template <class Archive, typename VariantType1, typename... VariantTypes> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::variant<VariantType1, VariantTypes...> const & variant )
  {
    std::int32_t index = static_cast<std::int32_t>(variant.index());
  //! Loading for std::variant
  template <class Archive, typename... VariantTypes> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::variant<VariantTypes...> & variant )
  {
    using variant_t = typename std::variant<VariantTypes...>;
  //! Serializing a std::monostate
  template <class Archive>
  void CEREAL_SERIALIZE_FUNCTION_NAME( Archive &, std::monostate const & ) {}
} // namespace cereal



//========================================
//===== File: ./third-party/cereal/include/cereal/types/vector.hpp =====
//========================================

namespace cereal
{
  //! Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported
  template <class Archive, class T, class A> inline
  typename std::enable_if<traits::is_output_serializable<BinaryData<T>, Archive>::value
                          && std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::vector<T, A> const & vector )
  //! Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported
  template <class Archive, class T, class A> inline
  typename std::enable_if<traits::is_input_serializable<BinaryData<T>, Archive>::value
                          && std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::vector<T, A> & vector )
  //! Serialization for non-arithmetic vector types
  template <class Archive, class T, class A> inline
  typename std::enable_if<(!traits::is_output_serializable<BinaryData<T>, Archive>::value
                          || !std::is_arithmetic<T>::value) && !std::is_same<T, bool>::value, void>::type
  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::vector<T, A> const & vector )
  //! Serialization for non-arithmetic vector types
  template <class Archive, class T, class A> inline
  typename std::enable_if<(!traits::is_input_serializable<BinaryData<T>, Archive>::value
                          || !std::is_arithmetic<T>::value) && !std::is_same<T, bool>::value, void>::type
  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::vector<T, A> & vector )
  //! Serialization for bool vector types
  template <class Archive, class A> inline
  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::vector<bool, A> const & vector )
  {
    ar( make_size_tag( static_cast<size_type>(vector.size()) ) ); // number of elements
  //! Serialization for bool vector types
  template <class Archive, class A> inline
  void CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::vector<bool, A> & vector )
  {
    size_type size;


//========================================
//===== File: ./third-party/cereal/include/cereal/version.hpp =====
//========================================


//========================================
//===== File: ./third-party/cereal/sandbox/sandbox_shared_lib/base.hpp =====
//========================================

class VersionTest
{
  public:
    int x;
    template <class Archive>
    void serialize( Archive & ar, const std::uint32_t /* version */ )
    { ar( x ); }
};

class Base
{
  public:
    friend class cereal::access;

    template < class Archive >
    void serialize(Archive &, std::uint32_t const) {}
    virtual ~Base() {}
};

extern template DECLSPECIFIER void Base::serialize<cereal::XMLInputArchive>


//========================================
//===== File: ./third-party/cereal/sandbox/sandbox_shared_lib/derived.hpp =====
//========================================
#include "base.hpp"
class Derived : public Base
{
  public:
    virtual ~Derived() {}

  private:
    friend class cereal::access;
    template <class Archive>
    void serialize(Archive & ar, std::uint32_t const)
    {
      ar(cereal::base_class<Base>(this));


//========================================
//===== File: ./third-party/google-benchmark/include/benchmark/benchmark.h =====
//========================================
// specified number of times:
static void BM_StringCreation(benchmark::State& state) {
  for (auto _ : state)
    std::string empty_string;
}
// Define another benchmark
static void BM_StringCopy(benchmark::State& state) {
  std::string x = "hello";
  for (auto _ : state)
    std::string copy(x);

static void BM_memcpy(benchmark::State& state) {
  char* src = new char[state.range(0)]; char* dst = new char[state.range(0)];
  memset(src, 'x', state.range(0));
  for (auto _ : state)
// measuring the speed of set insertion.
static void BM_SetInsert(benchmark::State& state) {
  set<int> data;
  for (auto _ : state) {
    state.PauseTiming();
// one parameter, and a sparse range on the second.
static void CustomArguments(benchmark::internal::Benchmark* b) {
  for (int i = 0; i <= 10; ++i)
    for (int j = 32; j <= 1024*1024; j *= 8)
      b->Args({i, j});
// Measures throughput in the absence of multiprogramming.
template <class Q> int BM_Sequential(benchmark::State& state) {
  Q q;
  typename Q::value_type v;
  for (auto _ : state) {

static void BM_MultiThreaded(benchmark::State& state) {
  if (state.thread_index == 0) {
    // Setup code here.
  }

namespace benchmark {
class BenchmarkReporter;
class MemoryManager;

void Initialize(int* argc, char** argv);
void Shutdown();

namespace internal {
class Benchmark;
class BenchmarkImp;
class BenchmarkFamilies;

void UseCharPointer(char const volatile*);

#ifndef BENCHMARK_HAS_NO_INLINE_ASSEMBLY
template <class Tp>
inline BENCHMARK_ALWAYS_INLINE void DoNotOptimize(Tp const& value) {
  asm volatile("" : : "r,m"(value) : "memory");
}

template <class Tp>
inline BENCHMARK_ALWAYS_INLINE void DoNotOptimize(Tp& value) {
#if defined(__clang__)
  asm volatile("" : "+r,m"(value) : : "memory");
#elif defined(_MSC_VER)
template <class Tp>
inline BENCHMARK_ALWAYS_INLINE void DoNotOptimize(Tp const& value) {
  internal::UseCharPointer(&reinterpret_cast<char const volatile&>(value));
  _ReadWriteBarrier();
#else
template <class Tp>
inline BENCHMARK_ALWAYS_INLINE void DoNotOptimize(Tp const& value) {
  internal::UseCharPointer(&reinterpret_cast<char const volatile&>(value));
}
// This class is used for user-defined counters.
class Counter {
 public:
  enum Flags {
    kDefaults = 0,
    // Mark the counter as a rate. It will be presented divided
    // by the duration of the benchmark.

  enum OneK {
    // 1'000 items per 1k
    kIs1000 = 1000,
    // 1'024 items per 1k
  return static_cast<Counter::Flags>(static_cast<int>(LHS) |
                                     static_cast<int>(RHS));
}

// This is the container for the user-defined counters.
typedef std::map<std::string, Counter> UserCounters;

// TimeUnit is passed to a benchmark in order to specify the order of magnitude
// for the measured time.
enum TimeUnit { kNanosecond, kMicrosecond, kMillisecond, kSecond };

// BigO is passed to a benchmark in order to specify the asymptotic
// computational
// calculated automatically to the best fit.
enum BigO { oNone, o1, oN, oNSquared, oNCubed, oLogN, oNLogN, oAuto, oLambda };

typedef uint64_t IterationCount;

// BigOFunc is passed to a benchmark in order to specify the asymptotic
// computational complexity for the benchmark.
typedef double(BigOFunc)(IterationCount);

// StatisticsFunc is passed to a benchmark in order to compute some descriptive
// statistics over all the measurements of some type
typedef double(StatisticsFunc)(const std::vector<double>&);

namespace internal {
struct Statistics {
  std::string name_;
  StatisticsFunc* compute_;


class BenchmarkInstance;
class ThreadTimer;
class ThreadManager;
class PerfCountersMeasurement;

enum AggregationReportMode
#if defined(BENCHMARK_HAS_CXX11)
    : unsigned
#else
// benchmark to use.
class State {
 public:
  struct StateIterator;
  friend struct StateIterator;

  // Returns iterators used to run each iteration of a benchmark using a

 public:
  const IterationCount max_iterations;

 private:
  bool started_;
  bool finished_;
  bool error_occurred_;

 private:  // items we don't need on the first cache line
  std::vector<int64_t> range_;

  int64_t complexity_n_;

 public:
  // Container for user-defined counters.
  UserCounters counters;
  // Index of the executing thread. Values from [0, threads).

 private:
  State(IterationCount max_iters, const std::vector<int64_t>& ranges,
        int thread_i, int n_threads, internal::ThreadTimer* timer,
        internal::ThreadManager* manager,

struct State::StateIterator {
  struct BENCHMARK_UNUSED Value {};
  typedef std::forward_iterator_tag iterator_category;
  typedef Value value_type;
  typedef Value reference;
  typedef Value pointer;
  typedef std::ptrdiff_t difference_type;

 private:
  friend class State;
  BENCHMARK_ALWAYS_INLINE
  StateIterator() : cached_(0), parent_() {}
  BENCHMARK_ALWAYS_INLINE
  explicit StateIterator(State* st)
      : cached_(st->error_occurred_ ? 0 : st->max_iterations), parent_(st) {}

 public:
  BENCHMARK_ALWAYS_INLINE
  Value operator*() const { return Value(); }


 private:
  IterationCount cached_;
  State* const parent_;
};

namespace internal {

typedef void(Function)(State&);

// ------------------------------------------------------
// Benchmark registration object.  The BENCHMARK() macro expands
// chained into one expression.
class Benchmark {
 public:
  virtual ~Benchmark();

  // Note: the following methods all return "this" so that multiple
  // method calls can be chained together in one expression.

  virtual void Run(State& state) = 0;

 protected:
  explicit Benchmark(const char* name);
  Benchmark(Benchmark const&);
  void SetName(const char* name);


 private:
  friend class BenchmarkFamilies;
  friend class BenchmarkInstance;

#if defined(BENCHMARK_HAS_CXX11)
template <class Lambda>
internal::Benchmark* RegisterBenchmark(const char* name, Lambda&& fn);
#endif


namespace internal {
// The class used to hold all Benchmarks created from static function.
// (ie those created using the BENCHMARK(...) macros.
class FunctionBenchmark : public Benchmark {
 public:
  FunctionBenchmark(const char* name, Function* func)
      : Benchmark(name), func_(func) {}

  virtual void Run(State& st) BENCHMARK_OVERRIDE;

 private:
  Function* func_;
};

#ifdef BENCHMARK_HAS_CXX11
template <class Lambda>
class LambdaBenchmark : public Benchmark {
 public:
  virtual void Run(State& st) BENCHMARK_OVERRIDE { lambda_(st); }

 private:
  template <class OLambda>
  LambdaBenchmark(const char* name, OLambda&& lam)
      : Benchmark(name), lambda_(std::forward<OLambda>(lam)) {}


 private:
  template <class Lam>
  friend Benchmark* ::benchmark::RegisterBenchmark(const char*, Lam&&);

  Lambda lambda_;
#ifdef BENCHMARK_HAS_CXX11
template <class Lambda>
internal::Benchmark* RegisterBenchmark(const char* name, Lambda&& fn) {
  using BenchType =
      internal::LambdaBenchmark<typename std::decay<Lambda>::type>;
    (!defined(BENCHMARK_GCC_VERSION) || BENCHMARK_GCC_VERSION >= 409)
template <class Lambda, class... Args>
internal::Benchmark* RegisterBenchmark(const char* name, Lambda&& fn,
                                       Args&&... args) {
  return benchmark::RegisterBenchmark(
// The base class for all fixture tests.
class Fixture : public internal::Benchmark {
 public:
  Fixture() : internal::Benchmark("") {}

  virtual void Run(State& st) BENCHMARK_OVERRIDE {
    this->SetUp(st);
    this->BenchmarkCase(st);
    this->TearDown(st);
  // These will be deprecated ...
  virtual void SetUp(const State&) {}
  virtual void TearDown(const State&) {}
  // ... In favor of these.
  virtual void SetUp(State& st) { SetUp(const_cast<const State&>(st)); }
  virtual void TearDown(State& st) { TearDown(const_cast<const State&>(st)); }

 protected:
  virtual void BenchmarkCase(State&) = 0;
};

}  // namespace benchmark
#define BENCHMARK_PRIVATE_DECLARE(n)                                 \
  static ::benchmark::internal::Benchmark* BENCHMARK_PRIVATE_NAME(n) \
      BENCHMARK_UNUSED

#define BENCHMARK(n)                                     \
#define BENCHMARK_PRIVATE_DECLARE_F(BaseClass, Method)                  \
  class BaseClass##_##Method##_Benchmark : public BaseClass {           \
   public:                                                              \
    BaseClass##_##Method##_Benchmark() : BaseClass() {                  \
      this->SetName(#BaseClass "/" #Method);                            \
    }                                                                   \
                                                                        \
   protected:                                                           \
    virtual void BenchmarkCase(::benchmark::State&) BENCHMARK_OVERRIDE; \
  };

#define BENCHMARK_TEMPLATE1_PRIVATE_DECLARE_F(BaseClass, Method, a)     \
  class BaseClass##_##Method##_Benchmark : public BaseClass<a> {        \
   public:                                                              \
    BaseClass##_##Method##_Benchmark() : BaseClass<a>() {               \
      this->SetName(#BaseClass "<" #a ">/" #Method);                    \
    }                                                                   \
                                                                        \
   protected:                                                           \
    virtual void BenchmarkCase(::benchmark::State&) BENCHMARK_OVERRIDE; \
  };

#define BENCHMARK_TEMPLATE2_PRIVATE_DECLARE_F(BaseClass, Method, a, b)  \
  class BaseClass##_##Method##_Benchmark : public BaseClass<a, b> {     \
   public:                                                              \
    BaseClass##_##Method##_Benchmark() : BaseClass<a, b>() {            \
      this->SetName(#BaseClass "<" #a "," #b ">/" #Method);             \
    }                                                                   \
                                                                        \
   protected:                                                           \
    virtual void BenchmarkCase(::benchmark::State&) BENCHMARK_OVERRIDE; \
  };

#ifdef BENCHMARK_HAS_CXX11
#define BENCHMARK_TEMPLATE_PRIVATE_DECLARE_F(BaseClass, Method, ...)       \
  class BaseClass##_##Method##_Benchmark : public BaseClass<__VA_ARGS__> { \
   public:                                                                 \
    BaseClass##_##Method##_Benchmark() : BaseClass<__VA_ARGS__>() {        \
      this->SetName(#BaseClass "<" #__VA_ARGS__ ">/" #Method);             \
    }                                                                      \
                                                                           \
   protected:                                                              \
    virtual void BenchmarkCase(::benchmark::State&) BENCHMARK_OVERRIDE;    \
  };
#else
#define BENCHMARK_TEMPLATE_PRIVATE_DECLARE_F(n, a) \

namespace benchmark {

struct CPUInfo {
  struct CacheInfo {
    std::string type;
    int level;
    int size;

  enum Scaling {
    UNKNOWN,
    ENABLED,
    DISABLED

  static const CPUInfo& Get();

 private:
  CPUInfo();
  BENCHMARK_DISALLOW_COPY_AND_ASSIGN(CPUInfo);
};
// Adding Struct for System Information
struct SystemInfo {
  std::string name;
  static const SystemInfo& Get();

 private:
  SystemInfo();
  BENCHMARK_DISALLOW_COPY_AND_ASSIGN(SystemInfo);
};
// building the final name using 'str()'.
struct BenchmarkName {
  std::string function_name;
  std::string args;
  std::string min_time;
// The reporter object must implement the following interface.
class BenchmarkReporter {
 public:
  struct Context {
    CPUInfo const& cpu_info;
    SystemInfo const& sys_info;
    // The number of chars in the longest benchmark name.
    size_t name_field_width;
    static const char* executable_name;
    Context();
  };

  struct Run {
    static const int64_t no_repetition_index = -1;
    enum RunType { RT_Iteration, RT_Aggregate };

    Run()
        : run_type(RT_Iteration),

  struct PerFamilyRunReports {
    PerFamilyRunReports() : num_runs_total(0), num_runs_done(0) {}

    // How many runs will all instances of this benchmark perform?
  // to skip runs based on the context information.
  virtual bool ReportContext(const Context& context) = 0;

  // Called once for each group of benchmark runs, gives information about
  // cpu-time and heap memory usage during the benchmark run. If the group
  // complexity and RMS of that benchmark family.
  virtual void ReportRuns(const std::vector<Run>& report) = 0;

  // Called once and only once after ever group of benchmarks is run and
  // reported.
  virtual void Finalize() {}

  // REQUIRES: The object referenced by 'out' is valid for the lifetime
  // of the reporter.

  virtual ~BenchmarkReporter();

  // Write a human readable string to 'out' representing the specified
  // 'context'.
  // REQUIRES: 'out' is non-null.
  static void PrintBasicContext(std::ostream* out, Context const& context);

 private:
  std::ostream* output_stream_;
  std::ostream* error_stream_;
};
// default reporter used by RunSpecifiedBenchmarks().
class ConsoleReporter : public BenchmarkReporter {
 public:
  enum OutputOptions {
    OO_None = 0,
    OO_Color = 1,
    OO_Tabular = 2,
  };
  explicit ConsoleReporter(OutputOptions opts_ = OO_Defaults)
      : output_options_(opts_),
        name_field_width_(0),
        prev_counters_(),

  virtual bool ReportContext(const Context& context) BENCHMARK_OVERRIDE;
  virtual void ReportRuns(const std::vector<Run>& reports) BENCHMARK_OVERRIDE;

 protected:
  virtual void PrintRunData(const Run& report);
  virtual void PrintHeader(const Run& report);

  OutputOptions output_options_;
  size_t name_field_width_;

class JSONReporter : public BenchmarkReporter {
 public:
  JSONReporter() : first_report_(true) {}
  virtual bool ReportContext(const Context& context) BENCHMARK_OVERRIDE;
  virtual void ReportRuns(const std::vector<Run>& reports) BENCHMARK_OVERRIDE;
  virtual void Finalize() BENCHMARK_OVERRIDE;

 private:
  void PrintRunData(const Run& report);

  bool first_report_;

class BENCHMARK_DEPRECATED_MSG(
    "The CSV Reporter will be removed in a future release") CSVReporter
    : public BenchmarkReporter {
 public:
  CSVReporter() : printed_header_(false) {}
  virtual bool ReportContext(const Context& context) BENCHMARK_OVERRIDE;
  virtual void ReportRuns(const std::vector<Run>& reports) BENCHMARK_OVERRIDE;

 private:
  void PrintRunData(const Run& report);

  bool printed_header_;
// allocation metrics for a run of the benchmark.
class MemoryManager {
 public:
  struct Result {
    Result() : num_allocs(0), max_bytes_used(0) {}

    // The number of allocations made in total between Start and Stop.

  virtual ~MemoryManager() {}

  // Implement this to start recording allocation information.
  virtual void Start() = 0;

  // Implement this to stop recording and fill out the given Result structure.
  virtual void Stop(Result* result) = 0;
};

inline const char* GetTimeUnitString(TimeUnit unit) {


//========================================
//===== File: ./third-party/google-benchmark/src/arraysize.h =====
//========================================

namespace benchmark {
namespace internal {
// The arraysize(arr) macro returns the # of elements in an array arr.
// The expression is a compile-time constant, and therefore can be
// used in defining new arrays, for example.  If you use arraysize on
// use its type.
template <typename T, size_t N>
char (&ArraySizeHelper(T (&array)[N]))[N];

// That gcc wants both of these prototypes seems mysterious. VC, for
#ifndef COMPILER_MSVC
template <typename T, size_t N>
char (&ArraySizeHelper(const T (&array)[N]))[N];
#endif



//========================================
//===== File: ./third-party/google-benchmark/src/benchmark_api_internal.h =====
//========================================

namespace benchmark {
namespace internal {

// Information kept per benchmark we may want to run
class BenchmarkInstance {
 public:
  BenchmarkInstance(Benchmark* benchmark, int family_index,
                    int per_family_instance_index,
                    const std::vector<int64_t>& args, int threads);

 private:
  BenchmarkName name_;
  Benchmark& benchmark_;
  const int family_index_;


//========================================
//===== File: ./third-party/google-benchmark/src/benchmark_register.h =====
//========================================

namespace benchmark {
namespace internal {

// Append the powers of 'mult' in the closed interval [lo, hi].
// Returns iterator to the start of the inserted range.
template <typename T>
typename std::vector<T>::iterator
AddPowers(std::vector<T>* dst, T lo, T hi, int mult) {
  BM_CHECK_GE(lo, 0);

  static const T kmax = std::numeric_limits<T>::max();

  // Space out the values in multiples of "mult"
  for (T i = static_cast<T>(1); i <= hi; i *= mult) {

template <typename T>
void AddNegatedPowers(std::vector<T>* dst, T lo, T hi, int mult) {
  // We negate lo and hi so we require that they cannot be equal to 'min'.
  BM_CHECK_GT(lo, std::numeric_limits<T>::min());

template <typename T>
void AddRange(std::vector<T>* dst, T lo, T hi, int mult) {
  static_assert(std::is_integral<T>::value && std::is_signed<T>::value,
                "Args type must be a signed integer");

  BM_CHECK_GE(hi, lo);


//========================================
//===== File: ./third-party/google-benchmark/src/benchmark_runner.h =====
//========================================

namespace benchmark {

BM_DECLARE_double(benchmark_min_time);
BM_DECLARE_int32(benchmark_repetitions);

namespace internal {

extern MemoryManager* memory_manager;

struct RunResults {
  std::vector<BenchmarkReporter::Run> non_aggregates;
  std::vector<BenchmarkReporter::Run> aggregates_only;


class BenchmarkRunner {
 public:
  BenchmarkRunner(const benchmark::internal::BenchmarkInstance& b_,
                  BenchmarkReporter::PerFamilyRunReports* reports_for_family);


 private:
  RunResults run_results;

  const benchmark::internal::BenchmarkInstance& b;

  struct IterationResults {
    internal::ThreadManager::Result results;
    IterationCount iters;
    double seconds;


//========================================
//===== File: ./third-party/google-benchmark/src/check.h =====
//========================================

namespace benchmark {
namespace internal {

typedef void(AbortHandlerT)();

inline AbortHandlerT*& GetAbortHandler() {
  static AbortHandlerT* handler = &std::abort;
  return handler;
}

// destructed.
class CheckHandler {
 public:
  CheckHandler(const char* check, const char* file, const char* func, int line)
      : log_(GetErrorLogInstance()) {
    log_ << file << ":" << line << ": " << func << ": Check `" << check

 private:
  LogType& log_;
};



//========================================
//===== File: ./third-party/google-benchmark/src/colorprint.h =====
//========================================

namespace benchmark {
enum LogColor {
  COLOR_DEFAULT,
  COLOR_RED,
  COLOR_GREEN,


//========================================
//===== File: ./third-party/google-benchmark/src/commandlineflags.h =====
//========================================

namespace benchmark {

// Parses a bool from the environment variable corresponding to the given flag.
//


//========================================
//===== File: ./third-party/google-benchmark/src/complexity.h =====
//========================================

namespace benchmark {

// Return a vector containing the bigO and RMS information for the specified
// list of reports. If 'reports.size() < 2' an empty vector is returned.

struct LeastSq {
  LeastSq() : coef(0.0), rms(0.0), complexity(oNone) {}

  double coef;


//========================================
//===== File: ./third-party/google-benchmark/src/counter.h =====
//========================================

namespace benchmark {

// these counter-related functions are hidden to reduce API surface.
namespace internal {
void Finish(UserCounters* l, IterationCount iterations, double time,
            double num_threads);
void Increment(UserCounters* l, UserCounters const& r);


//========================================
//===== File: ./third-party/google-benchmark/src/cycleclock.h =====
//========================================

namespace benchmark {
// NOTE: only i386 and x86_64 have been well tested.
// PPC, sparc, alpha, and ia64 are based on
//    http://peter.kuscsik.com/wordpress/?p=14
//    https://setisvn.ssl.berkeley.edu/svn/lib/fftw-3.0.1/kernel/cycle.h
namespace cycleclock {
// This should return the number of cycles since power-on.  Thread-safe.
inline BENCHMARK_ALWAYS_INLINE int64_t Now() {
#if defined(BENCHMARK_OS_MACOSX)
  int64_t virtual_timer_value;
  virtual_timer_value = _ReadStatusReg(ARM64_CNTVCT);
  return virtual_timer_value;
#elif defined(COMPILER_MSVC)
  return __rdtsc();
  // Initialize to always return 0 if clock_gettime fails.
  struct timespec ts = {0, 0};
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return static_cast<int64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;
#elif defined(__aarch64__)
#endif
  struct timeval tv;
  gettimeofday(&tv, nullptr);
  return static_cast<int64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
#elif defined(__mips__) || defined(__m68k__)
  // back to gettimeofday.  It's possible clock_gettime would be better.
  struct timeval tv;
  gettimeofday(&tv, nullptr);
  return static_cast<int64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
#elif defined(__loongarch__)
  struct timeval tv;
  gettimeofday(&tv, nullptr);
  return static_cast<int64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
#elif defined(__s390__)  // Covers both s390 and s390x.
#elif defined(__e2k__) || defined(__elbrus__)
  struct timeval tv;
  gettimeofday(&tv, nullptr);
  return static_cast<int64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
#else


//========================================
//===== File: ./third-party/google-benchmark/src/internal_macros.h =====
//========================================


//========================================
//===== File: ./third-party/google-benchmark/src/log.h =====
//========================================

namespace benchmark {
namespace internal {

typedef std::basic_ostream<char>&(EndLType)(std::basic_ostream<char>&);

class LogType {
  friend LogType& GetNullLogInstance();
  friend LogType& GetErrorLogInstance();

  // FIXME: Add locking to output.
  template <class Tp>
  friend LogType& operator<<(LogType&, Tp const&);
  friend LogType& operator<<(LogType&, EndLType*);

 private:
  LogType(std::ostream* out) : out_(out) {}
  std::ostream* out_;
  BENCHMARK_DISALLOW_COPY_AND_ASSIGN(LogType);

template <class Tp>
LogType& operator<<(LogType& log, Tp const& value) {
  if (log.out_) {
    *log.out_ << value;
inline int& LogLevel() {
  static int log_level = 0;
  return log_level;
}

inline LogType& GetNullLogInstance() {
  static LogType log(nullptr);
  return log;
}

inline LogType& GetErrorLogInstance() {
  static LogType log(&std::clog);
  return log;
}



//========================================
//===== File: ./third-party/google-benchmark/src/mutex.h =====
//========================================

namespace benchmark {

typedef std::condition_variable Condition;

// NOTE: Wrappers for std::mutex and std::unique_lock are provided so that
// we can annotate them with thread safety attributes and use the
// used directly because they do not provide the required annotations.
class CAPABILITY("mutex") Mutex {
 public:
  Mutex() {}

  void lock() ACQUIRE() { mut_.lock(); }

 private:
  std::mutex mut_;
};

class SCOPED_CAPABILITY MutexLock {
  typedef std::unique_lock<std::mutex> MutexLockImp;

 public:
  MutexLock(Mutex& m) ACQUIRE(m) : ml_(m.native_handle()) {}
  ~MutexLock() RELEASE() {}
  MutexLockImp& native_handle() { return ml_; }

 private:
  MutexLockImp ml_;
};

class Barrier {
 public:
  Barrier(int num_threads) : running_threads_(num_threads) {}

  // Called by each thread

 private:
  Mutex lock_;
  Condition phase_condition_;
  int running_threads_;


//========================================
//===== File: ./third-party/google-benchmark/src/perf_counters.h =====
//========================================

namespace benchmark {
namespace internal {

// Typically, we can only read a small number of counters. There is also a
// padding preceding counter values, when reading multiple counters with one
// operator[]) of this object.
class PerfCounterValues {
 public:
  explicit PerfCounterValues(size_t nr_counters) : nr_counters_(nr_counters) {
    BM_CHECK_LE(nr_counters_, kMaxCounters);
  }


  static constexpr size_t kMaxCounters = 3;

 private:
  friend class PerfCounters;
  // Get the byte buffer in which perf counters can be captured.
  // This is used by PerfCounters::Read

  static constexpr size_t kPadding = 1;
  std::array<uint64_t, kPadding + kMaxCounters> values_;
  const size_t nr_counters_;
};
// called, to obtain the object, until the object's destructor is called.
class PerfCounters final {
 public:
  // True iff this platform supports performance counters.
  static const bool kSupported;

  bool IsValid() const { return is_valid_; }
  static PerfCounters NoCounters() { return PerfCounters(); }

  ~PerfCounters();
  PerfCounters(PerfCounters&&) = default;
  // initialization here.
  static bool Initialize();

  // Return a PerfCounters object ready to read the counters with the names
  // specified. The values are user-mode only. The counter name format is
  // IsValid() boolean can be dropped.
  static PerfCounters Create(const std::vector<std::string>& counter_names);

  // Take a snapshot of the current value of the counters into the provided
  // valid PerfCounterValues storage. The values are populated such that:

 private:
  PerfCounters(const std::vector<std::string>& counter_names,
               std::vector<int>&& counter_ids)
      : counter_ids_(std::move(counter_ids)),
// Typical usage of the above primitives.
class PerfCountersMeasurement final {
 public:
  PerfCountersMeasurement(PerfCounters&& c)
      : counters_(std::move(c)),
        start_values_(counters_.IsValid() ? counters_.names().size() : 0),
      double measurement = static_cast<double>(end_values_[i]) -
                           static_cast<double>(start_values_[i]);
      ret.push_back({counters_.names()[i], measurement});
    }
    return ret;

 private:
  PerfCounters counters_;
  PerfCounterValues start_values_;
  PerfCounterValues end_values_;


//========================================
//===== File: ./third-party/google-benchmark/src/re.h =====
//========================================

namespace benchmark {

// A wrapper around the POSIX regular expression API that provides automatic
// cleanup
class Regex {
 public:
  Regex() : init_(false) {}

  ~Regex();

 private:
  bool init_;
// Underlying regular expression object
#if defined(HAVE_STD_REGEX)


//========================================
//===== File: ./third-party/google-benchmark/src/sleep.h =====
//========================================

namespace benchmark {
const int kNumMillisPerSecond = 1000;
const int kNumMicrosPerMilli = 1000;
const int kNumMicrosPerSecond = kNumMillisPerSecond * 1000;


//========================================
//===== File: ./third-party/google-benchmark/src/statistics.h =====
//========================================

namespace benchmark {

// Return a vector containing the mean, median and standard devation information
// (and any user-specified info) for the specified list of reports. If 'reports'


//========================================
//===== File: ./third-party/google-benchmark/src/string_util.h =====
//========================================

namespace benchmark {

void AppendHumanReadable(int n, std::string* str);


template <class First, class... Rest>
inline std::ostream& StrCatImp(std::ostream& out, First&& f, Rest&&... rest) {
  out << std::forward<First>(f);
  return StrCatImp(out, std::forward<Rest>(rest)...);

template <class... Args>
inline std::string StrCat(Args&&... args) {
  std::ostringstream ss;
  StrCatImp(ss, std::forward<Args>(args)...);


//========================================
//===== File: ./third-party/google-benchmark/src/thread_manager.h =====
//========================================

namespace benchmark {
namespace internal {

class ThreadManager {
 public:
  explicit ThreadManager(int num_threads)
      : alive_threads_(num_threads), start_stop_barrier_(num_threads) {}

  Mutex& GetBenchmarkMutex() const RETURN_CAPABILITY(benchmark_mutex_) {

 public:
  struct Result {
    IterationCount iterations = 0;
    double real_time_used = 0;
    double cpu_time_used = 0;

 private:
  mutable Mutex benchmark_mutex_;
  std::atomic<int> alive_threads_;
  Barrier start_stop_barrier_;


//========================================
//===== File: ./third-party/google-benchmark/src/thread_timer.h =====
//========================================

namespace benchmark {
namespace internal {

class ThreadTimer {
  explicit ThreadTimer(bool measure_process_cpu_time_)
      : measure_process_cpu_time(measure_process_cpu_time_) {}

 public:
  static ThreadTimer Create() {
    return ThreadTimer(/*measure_process_cpu_time_=*/false);
  }
  static ThreadTimer CreateProcessCpuTime() {
    return ThreadTimer(/*measure_process_cpu_time_=*/true);
  }


 private:
  double ReadCpuTimerOfChoice() const {
    if (measure_process_cpu_time) return ProcessCPUUsage();
    return ThreadCPUUsage();


//========================================
//===== File: ./third-party/google-benchmark/src/timers.h =====
//========================================

namespace benchmark {

// Return the CPU usage of the current process
double ProcessCPUUsage();
#if defined(HAVE_STEADY_CLOCK)
template <bool HighResIsSteady = std::chrono::high_resolution_clock::is_steady>
struct ChooseSteadyClock {
  typedef std::chrono::high_resolution_clock type;
};

template <>
struct ChooseSteadyClock<false> {
  typedef std::chrono::steady_clock type;
};
#endif

struct ChooseClockType {
#if defined(HAVE_STEADY_CLOCK)
  typedef ChooseSteadyClock<>::type type;
#else
  typedef std::chrono::high_resolution_clock type;
#endif
};

inline double ChronoClockNow() {
  typedef ChooseClockType::type ClockType;
  using FpSeconds = std::chrono::duration<double, std::chrono::seconds::period>;
  return FpSeconds(ClockType::now().time_since_epoch()).count();
}


//========================================
//===== File: ./third-party/gperftools/benchmark/run_benchmark.h =====
//========================================

typedef void (*bench_body)(long iterations, uintptr_t param);

void report_benchmark(const char *name, bench_body body, uintptr_t param);



//========================================
//===== File: ./third-party/gperftools/src/addressmap-inl.h =====
//========================================
// while another thread is calling non-const methods on the class.
template <class Value>
class AddressMap {
 public:
  typedef void* (*Allocator)(size_t size);
  typedef void  (*DeAllocator)(void* ptr);
  typedef const void* Key;

  // Create an AddressMap that uses the specified allocator/deallocator.
  // The allocator/deallocator should behave like malloc/free.
  // max_size specifies largest range size possibly in existence now.
  typedef size_t (*ValueSizeFunc)(const Value& v);
  const Value* FindInside(ValueSizeFunc size_func, size_t max_size,
                          Key key, Key* res_key);

  // unnecessary dependencies to this class with low-level uses.
  template<class Type>
  inline void Iterate(void (*callback)(Key, Value*, Type), Type arg) const;

 private:
  typedef uintptr_t Number;

  // The implementation assumes that addresses inserted into the map
  // will be clustered.  We take advantage of this fact by splitting
  // will be spent traversing linked lists.
  static const int kBlockBits = 7;
  static const int kBlockSize = 1 << kBlockBits;

  // Entry kept in per-block linked-list
  struct Entry {
    Entry* next;
    Key    key;
    Value  value;
  // linked-lists, one list per contained block.
  static const int kClusterBits = 13;
  static const Number kClusterSize = 1 << (kBlockBits + kClusterBits);
  static const int kClusterBlocks = 1 << kClusterBits;

  // We use a simple chaining hash-table to represent the clusters.
  struct Cluster {
    Cluster* next;                      // Next cluster in hash table chain
    Number   id;                        // Cluster ID
    Entry*   blocks[kClusterBlocks];    // Per-block linked-lists
  // in-use memory.
  static const int kHashBits = 12;
  static const int kHashSize = 1 << 12;

  // Number of entry objects allocated at a time
  static const int ALLOC_COUNT = 64;

  Cluster**     hashtable_;              // The hash-table
  Entry*        free_;                   // Free list of unused Entry objects
  // of the muliplied value.
  static const uint32_t kHashMultiplier = 2654435769u;
  static int HashInt(Number x) {
    // Multiply by a constant and take the top bits of the result.
    const uint32_t m = static_cast<uint32_t>(x) * kHashMultiplier;
    return static_cast<int>(m >> (32 - kHashBits));
  // Return the block ID for an address within its cluster
  static int BlockID(Number address) {
    return (address >> kBlockBits) & (kClusterBlocks - 1);
  }

  //--------------------------------------------------------------
  struct Object {
    Object* next;
    // The real data starts here
  };
  // when we are all done.
  template <class T> T* New(int num) {
    void* ptr = (*alloc_)(sizeof(Object) + num*sizeof(T));
    memset(ptr, 0, sizeof(Object) + num*sizeof(T));
    Object* obj = reinterpret_cast<Object*>(ptr);

template <class Value>
AddressMap<Value>::AddressMap(Allocator alloc, DeAllocator dealloc)
  : free_(NULL),
    alloc_(alloc),

template <class Value>
AddressMap<Value>::~AddressMap() {
  // De-allocate all of the objects we allocated
  for (Object* obj = allocated_; obj != NULL; /**/) {

template <class Value>
inline const Value* AddressMap<Value>::Find(Key key) const {
  return const_cast<AddressMap*>(this)->FindMutable(key);
}

template <class Value>
inline Value* AddressMap<Value>::FindMutable(Key key) {
  const Number num = reinterpret_cast<Number>(key);
  const Cluster* const c = FindCluster(num, false/*do not create*/);

template <class Value>
void AddressMap<Value>::Insert(Key key, Value value) {
  const Number num = reinterpret_cast<Number>(key);
  Cluster* const c = FindCluster(num, true/*create*/);

template <class Value>
bool AddressMap<Value>::FindAndRemove(Key key, Value* removed_value) {
  const Number num = reinterpret_cast<Number>(key);
  Cluster* const c = FindCluster(num, false/*do not create*/);

template <class Value>
const Value* AddressMap<Value>::FindInside(ValueSizeFunc size_func,
                                           size_t max_size,
                                           Key key,

template <class Value>
template <class Type>
inline void AddressMap<Value>::Iterate(void (*callback)(Key, Value*, Type),
                                       Type arg) const {
  // We could optimize this by traversing only non-empty clusters and/or blocks


//========================================
//===== File: ./third-party/gperftools/src/base/arm_instruction_set_select.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/base/atomicops.h =====
//========================================
// well as atomic loads and stores.  Instances must be naturally-aligned.
typedef intptr_t AtomicWord;

#ifdef AtomicWordCastType
// ------------------------------------------------------------------------

namespace base {
namespace subtle {

// Atomically execute:
//      result = *ptr;
// from AtomicWord in 64-bit binaries where AtomicWord is 64-bits.
typedef int32_t Atomic32;

// Corresponding operations on Atomic32
namespace base {
namespace subtle {

// Signed 64-bit type that supports the atomic ops below, as well as atomic
// loads and stores.  Instances must be naturally aligned.  This type differs
// from AtomicWord in 32-bit binaries where AtomicWord is 32-bits.
typedef int64_t Atomic64;

Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,
                                  Atomic32 old_value,


//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-arm-generic.h =====
//========================================

typedef int32_t Atomic32;

namespace base {
namespace subtle {

typedef int64_t Atomic64;

// 0xffff0fc0 is the hard coded address of a function provided by
// the kernel which implements an atomic compare-exchange. On older
// pLinuxKernelCmpxchg has both acquire and release barrier sematincs.
typedef Atomic32 (*LinuxKernelCmpxchgFunc)(Atomic32 old_value,
                                           Atomic32 new_value,
                                           volatile Atomic32* ptr);
LinuxKernelCmpxchgFunc pLinuxKernelCmpxchg ATTRIBUTE_WEAK =

typedef void (*LinuxKernelMemoryBarrierFunc)(void);
LinuxKernelMemoryBarrierFunc pLinuxKernelMemoryBarrier ATTRIBUTE_WEAK =
    (LinuxKernelMemoryBarrierFunc) 0xffff0fa0;



//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-arm-v6plus.h =====
//========================================

typedef int32_t Atomic32;

namespace base {
namespace subtle {

typedef int64_t Atomic64;

// 32-bit low-level ops



//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-gcc.h =====
//========================================

typedef int32_t Atomic32;

namespace base {
namespace subtle {

typedef int64_t Atomic64;

inline void MemoryBarrier() {
    __sync_synchronize();


//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-linuxppc.h =====
//========================================

typedef int32_t Atomic32;

#ifdef __PPC64__
#define BASE_HAS_ATOMIC64 1

namespace base {
namespace subtle {

static inline void _sync(void) {
  __asm__ __volatile__("sync": : : "memory");
}

static inline void _lwsync(void) {
  // gcc defines __NO_LWSYNC__ when appropriate; see
  //    http://gcc.gnu.org/ml/gcc-patches/2006-11/msg01238.html
#ifdef __NO_LWSYNC__

static inline void _isync(void) {
  __asm__ __volatile__("isync": : : "memory");
}

static inline Atomic32 OSAtomicAdd32(Atomic32 amount, Atomic32 *value) {
  Atomic32 t;
  __asm__ __volatile__(
"1:		lwarx   %0,0,%3\n\

static inline Atomic32 OSAtomicAdd32Barrier(Atomic32 amount, Atomic32 *value) {
  Atomic32 t;
  _lwsync();
  t = OSAtomicAdd32(amount, value);

static inline bool OSAtomicCompareAndSwap32(Atomic32 old_value,
                                            Atomic32 new_value,
                                            Atomic32 *value) {
  Atomic32 prev;

static inline Atomic32 OSAtomicCompareAndSwap32Acquire(Atomic32 old_value,
                                                       Atomic32 new_value,
                                                       Atomic32 *value) {
  Atomic32 t;

static inline Atomic32 OSAtomicCompareAndSwap32Release(Atomic32 old_value,
                                                       Atomic32 new_value,
                                                       Atomic32 *value) {
  _lwsync();

typedef int64_t Atomic64;

inline void MemoryBarrier() {
  // This can't be _lwsync(); we need to order the immediately

static inline Atomic64 OSAtomicAdd64(Atomic64 amount, Atomic64 *value) {
  Atomic64 t;
  __asm__ __volatile__(
"1:		ldarx   %0,0,%3\n\

static inline Atomic64 OSAtomicAdd64Barrier(Atomic64 amount, Atomic64 *value) {
  Atomic64 t;
  _lwsync();
  t = OSAtomicAdd64(amount, value);

static inline bool OSAtomicCompareAndSwap64(Atomic64 old_value,
                                            Atomic64 new_value,
                                            Atomic64 *value) {
  Atomic64 prev;

static inline Atomic64 OSAtomicCompareAndSwap64Acquire(Atomic64 old_value,
                                                       Atomic64 new_value,
                                                       Atomic64 *value) {
  Atomic64 t;

static inline Atomic64 OSAtomicCompareAndSwap64Release(Atomic64 old_value,
                                                       Atomic64 new_value,
                                                       Atomic64 *value) {
  _lwsync();


//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-macosx.h =====
//========================================

typedef int32_t Atomic32;

// MacOS uses long for intptr_t, AtomicWord and Atomic32 are always different
// on the Mac, even when they are the same size.  Similarly, on __ppc64__,

namespace base {
namespace subtle {

#if !defined(__LP64__) && defined(__ppc__)


typedef int64_t Atomic64;

inline void MemoryBarrier() {
  OSMemoryBarrier();


//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-mips.h =====
//========================================

typedef int32_t Atomic32;

namespace base {
namespace subtle {

// Atomically execute:
// result = *ptr;

typedef int64_t Atomic64;

inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,
                                         Atomic64 old_value,


//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-windows.h =====
//========================================

typedef int32 Atomic32;

#if defined(_WIN64)
#define BASE_HAS_ATOMIC64 1  // Use only in tests and base/atomic*

namespace base {
namespace subtle {

typedef int64 Atomic64;

// 32-bit low-level operations on any platform

      reinterpret_cast<volatile LONG*>(ptr),
      static_cast<LONG>(new_value),
      static_cast<LONG>(old_value));
  return static_cast<Atomic32>(result);
}

      reinterpret_cast<volatile LONG*>(ptr),
      static_cast<LONG>(new_value));
  return static_cast<Atomic32>(result);
}


namespace base {
namespace subtle {

inline void MemoryBarrier() {
  ::MemoryBarrier();


//========================================
//===== File: ./third-party/gperftools/src/base/atomicops-internals-x86.h =====
//========================================

typedef int32_t Atomic32;
#define BASE_HAS_ATOMIC64 1  // Use only in tests and base/atomic*


// but are set conservatively.
struct AtomicOps_x86CPUFeatureStruct {
  bool has_sse2;            // Processor has SSE2.
  bool has_cmpxchg16b;      // Processor supports cmpxchg16b instruction.
};

namespace base {
namespace subtle {

typedef int64_t Atomic64;

// 32-bit low-level operations on any platform.



//========================================
//===== File: ./third-party/gperftools/src/base/basictypes.h =====
//========================================
// TODO(csilvers): how do we make sure unsigned-char works on non-gcc systems?
typedef signed char         schar;
typedef int8_t              int8;
typedef int16_t             int16;
typedef int32_t             int32;
typedef int64_t             int64;

// NOTE: unsigned types are DANGEROUS in loops and other arithmetical
// places.  Use the signed types unless your variable represents a bit

typedef uint8_t            uint8;
typedef uint16_t           uint16;
typedef uint32_t           uint32;
typedef uint64_t           uint64;

const uint16 kuint16max = (   (uint16) 0xFFFF);
const uint32 kuint32max = (   (uint32) 0xFFFFFFFF);

template <bool>
struct CompileAssert {
};

#ifdef HAVE___ATTRIBUTE__
#define COMPILE_ASSERT(expr, msg)                               \
  typedef CompileAssert<(bool(expr))> msg[bool(expr) ? 1 : -1] ATTRIBUTE_UNUSED

#define arraysize(a)  (sizeof(a) / sizeof(*(a)))


template <class Dest, class Source>
inline Dest bit_cast(const Source& source) {
  COMPILE_ASSERT(sizeof(Dest) == sizeof(Source), bitcasting_unequal_sizes);
  Dest dest;
// This prevents undefined behavior when the dest pointer is unaligned.
template <class Dest, class Source>
inline void bit_store(Dest *dest, const Source *source) {
  COMPILE_ASSERT(sizeof(Dest) == sizeof(Source), bitcasting_unequal_sizes);
  memcpy(dest, source, sizeof(Dest));
#include <mach-o/dyld.h>
class AssignAttributeStartEnd {
 public:
  AssignAttributeStartEnd(const char* name, char** pstart, char** pend) {
    // Find out what dynamic library name is defined in
    if (_dyld_present()) {
  DECLARE_ATTRIBUTE_SECTION_VARS(name);                 \
  static const AssignAttributeStartEnd __assign_##name( \
    #name, &__start_##name, &__stop_##name)

#define DEFINE_ATTRIBUTE_SECTION_VARS(name)     \
//       static MyClass my_variable_name(base::LINKER_INITIALIZED);
namespace base {
enum LinkerInitialized { LINKER_INITIALIZED };
}

#endif  // _BASICTYPES_H_


//========================================
//===== File: ./third-party/gperftools/src/base/commandlineflags.h =====
//========================================
#define DECLARE_VARIABLE(type, name)                                          \
  namespace FLAG__namespace_do_not_use_directly_use_DECLARE_##type##_instead {  \
  extern PERFTOOLS_DLL_DECL type FLAGS_##name;                                \
  }                                                                           \
  using FLAG__namespace_do_not_use_directly_use_DECLARE_##type##_instead::FLAGS_##name
#define DEFINE_VARIABLE(type, name, value, meaning) \
  namespace FLAG__namespace_do_not_use_directly_use_DECLARE_##type##_instead {  \
  PERFTOOLS_DLL_DECL type FLAGS_##name(value);                                \
  char FLAGS_no##name;                                                        \
  }                                                                           \
#define DECLARE_string(name)                                          \
  namespace FLAG__namespace_do_not_use_directly_use_DECLARE_string_instead {  \
  extern std::string FLAGS_##name;                                                   \
  }                                                                           \
  using FLAG__namespace_do_not_use_directly_use_DECLARE_string_instead::FLAGS_##name
#define DEFINE_string(name, value, meaning) \
  namespace FLAG__namespace_do_not_use_directly_use_DECLARE_string_instead {  \
  std::string FLAGS_##name(value);                                                   \
  char FLAGS_no##name;                                                        \
  }                                                                           \
// implemented in sysinfo.cc
namespace tcmalloc {
  namespace commandlineflags {

    inline bool StringToBool(const char *value, bool def) {
      if (!value) {


//========================================
//===== File: ./third-party/gperftools/src/base/dynamic_annotations.h =====
//========================================
        ... = ANNOTATE_UNPROTECTED_READ(x); */
  template <class T>
  inline T ANNOTATE_UNPROTECTED_READ(const volatile T &x)
      ANNOTALYSIS_UNPROTECTED_READ {
    ANNOTATE_IGNORE_READS_BEGIN();
  #define ANNOTATE_BENIGN_RACE_STATIC(static_var, description)        \
    namespace {                                                       \
      class static_var ## _annotator {                                \
       public:                                                        \
        static_var ## _annotator() {                                  \
          ANNOTATE_BENIGN_RACE_SIZED(&static_var,                     \
                                      sizeof(static_var),             \
            # static_var ": " description);                           \
      };                                                              \
      static static_var ## _annotator the ## static_var ## _annotator;\
    }
#else /* DYNAMIC_ANNOTATIONS_ENABLED == 0 */

   original macro definitions above, these macros are expanded to calls to
   static inline functions so that the compiler will be able to remove the
   calls after the analysis. */

#ifdef ANNOTALYSIS_ONLY
    #undef ANNOTATE_UNPROTECTED_READ
    template <class T>
    inline T ANNOTATE_UNPROTECTED_READ(const volatile T &x)
         ANNOTALYSIS_UNPROTECTED_READ {
      ANNOTATE_IGNORE_READS_BEGIN();


//========================================
//===== File: ./third-party/gperftools/src/base/elf_mem_image.h =====
//========================================

namespace base {

// An in-memory ELF image (may not exist on disk).
class ElfMemImage {
 public:
  // Sentinel: there could never be an elf image at this address.
  static const void *const kInvalidBase;

  // Information about a single vdso symbol.
  // All pointers are into .dynsym, .dynstr, or .text of the VDSO.
  // Do not free() them or modify through them.
  struct SymbolInfo {
    const char      *name;      // E.g. "__vdso_getcpu"
    const char      *version;   // E.g. "LINUX_2.6", could be ""
                                // for unversioned symbol.
  // Supports iteration over all dynamic symbols.
  class SymbolIterator {
   public:
    friend class ElfMemImage;
    const SymbolInfo *operator->() const;
    const SymbolInfo &operator*() const;
    bool operator==(const SymbolIterator &rhs) const;
   private:
    SymbolIterator(const void *const image, int index);
    void Update(int incr);
    SymbolInfo info_;

  explicit ElfMemImage(const void *base);
  void                 Init(const void *base);
  bool                 IsPresent() const { return ehdr_ != NULL; }
  const ElfW(Phdr)*    GetPhdr(int index) const;

 private:
  const ElfW(Ehdr) *ehdr_;
  const ElfW(Sym) *dynsym_;
  const ElfW(Versym) *versym_;


//========================================
//===== File: ./third-party/gperftools/src/base/elfcore.h =====
//========================================
#if defined(__i386__) || defined(__x86_64__)
  typedef struct i386_regs {    /* Normal (non-FPU) CPU registers            */
  #ifdef __x86_64__
    #define BP rbp
    #define SP rsp
#elif defined(__arm__)
  typedef struct arm_regs {     /* General purpose registers                 */
    #define BP uregs[11]        /* Frame pointer                             */
    #define SP uregs[13]        /* Stack pointer                             */
    #define IP uregs[15]        /* Program counter                           */
#elif defined(__mips__)
  typedef struct mips_regs {
    unsigned long pad[6];       /* Unused padding to match kernel structures */
    unsigned long uregs[32];    /* General purpose registers.                */
    unsigned long hi;           /* Used for multiplication and division.     */
#elif defined (__PPC__)
  typedef struct ppc_regs {
    #define SP uregs[1]         /* Stack pointer                             */
    #define IP rip              /* Program counter                           */
    #define LR lr               /* Link register                             */
   */
  typedef struct Frame {
    struct i386_regs uregs;
    int              errno_;
    pid_t            tid;
  } Frame;
  /* The FRAME and SET_FRAME macros for x86_64.  */
  typedef struct Frame {
    struct i386_regs uregs;
    int              errno_;
    pid_t            tid;
  } Frame;
   */
  typedef struct Frame {
    struct arm_regs arm;
    int             errno_;
    pid_t           tid;
  } Frame;
#elif defined(__mips__) && defined(__GNUC__)
  typedef struct Frame {
    struct mips_regs mips_regs;
    int              errno_;
    pid_t            tid;
  } Frame;
   */
  typedef struct Frame {
    pid_t tid;
  } Frame;
  #define FRAME(f) Frame f; do { f.tid = sys_gettid(); } while (0)


//========================================
//===== File: ./third-party/gperftools/src/base/googleinit.h =====
//========================================

class GoogleInitializer {
 public:
  typedef void (*VoidFunction)(void);
  GoogleInitializer(const char* name, VoidFunction ctor, VoidFunction dtor)
      : name_(name), destructor_(dtor) {
    RAW_VLOG(10, "<GoogleModuleObject> constructing: %s\n", name_);

 private:
  const char* const name_;
  const VoidFunction destructor_;
};
#define REGISTER_MODULE_INITIALIZER(name, body)                 \
  namespace {                                                   \
    static void google_init_module_##name () { body; }          \
    GoogleInitializer google_initializer_module_##name(#name,   \
            google_init_module_##name, NULL);                   \
  }
#define REGISTER_MODULE_DESTRUCTOR(name, body)                  \
  namespace {                                                   \
    static void google_destruct_module_##name () { body; }      \
    GoogleInitializer google_destructor_module_##name(#name,    \
            NULL, google_destruct_module_##name);               \
  }


//========================================
//===== File: ./third-party/gperftools/src/base/linux_syscall_support.h =====
//========================================
/* include/linux/dirent.h                                                    */
struct kernel_dirent64 {
  unsigned long long d_ino;
  long long          d_off;
  unsigned short     d_reclen;
/* include/linux/dirent.h                                                    */
struct kernel_dirent {
  long               d_ino;
  long               d_off;
  unsigned short     d_reclen;
/* include/linux/time.h                                                      */
struct kernel_timespec {
  long               tv_sec;
  long               tv_nsec;
};
/* include/linux/time.h                                                      */
struct kernel_timeval {
  long               tv_sec;
  long               tv_usec;
};
/* include/linux/resource.h                                                  */
struct kernel_rusage {
  struct kernel_timeval ru_utime;
  struct kernel_timeval ru_stime;
  long               ru_maxrss;
  long               ru_ixrss;
  long               ru_idrss;
/* include/asm-{arm,i386,mips,ppc}/signal.h                                  */
struct kernel_old_sigaction {
  union {
    void             (*sa_handler_)(int);
    void             (*sa_sigaction_)(int, siginfo_t *, void *);
/* include/asm-{arm,i386,mips,x86_64}/signal.h                               */
struct kernel_sigset_t {
  unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)/
                    (8*sizeof(unsigned long))];
};
/* include/asm-{arm,generic,i386,mips,x86_64,ppc}/signal.h                   */
struct kernel_sigaction {
#ifdef __mips__
  unsigned long      sa_flags;
  union {
  };
  struct kernel_sigset_t sa_mask;
#else
  union {
    void             (*sa_handler_)(int);
  void               (*sa_restorer)(void);
  struct kernel_sigset_t sa_mask;
#endif
};

#if (_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32)
struct kernel_stat {
#else
struct kernel_stat64 {
#endif
  unsigned           st_dev;
  unsigned           __pad0[3];
#elif defined __PPC__
struct kernel_stat64 {
  unsigned long long st_dev;
  unsigned long long st_ino;
  unsigned           st_nlink;
#else
struct kernel_stat64 {
  unsigned long long st_dev;
  unsigned char      __pad0[4];
  unsigned           __st_ino;
#if defined(__i386__) || defined(__arm__)
struct kernel_stat {
  /* The kernel headers suggest that st_dev and st_rdev should be 32bit
   * quantities encoding 12bit major and 20bit minor numbers in an interleaved
   * format. In reality, we do not see useful data in the top bits. So,
#elif defined(__x86_64__)
struct kernel_stat {
  uint64_t           st_dev;
  uint64_t           st_ino;
  uint64_t           st_nlink;
#elif defined(__PPC__)
struct kernel_stat {
  unsigned long long st_dev;
  unsigned long      st_ino;
  unsigned long      st_nlink;
       && !(_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32)
struct kernel_stat {
  unsigned           st_dev;
  int                st_pad1[3];
  unsigned           st_ino;
#elif defined(__aarch64__)
struct kernel_stat {
  unsigned long      st_dev;
  unsigned long      st_ino;
  unsigned int       st_mode;
#elif defined(__s390x__)
struct kernel_stat {
  unsigned long      st_dev;
  unsigned long      st_ino;
  unsigned long      st_nlink;
#elif defined(__s390__)
struct kernel_stat {
  unsigned short     st_dev;
  unsigned short     __pad1;
  unsigned long      st_ino;
        long __res;                                                           \
        struct { long __a1; long __a6; } __s = { (long)arg1, (long) arg6 };   \
        __asm__ __volatile__("push %%ebp\n"                                   \
                             "push %%ebx\n"                                   \
                             "movl 4(%2),%%ebp\n"                             \
  LSS_INLINE _syscall2_long(int,     fstat,       fstat64,    int,         f,
                      struct kernel_stat*,   b)
#else
  LSS_INLINE _syscall2(int,     fstat,           int,         f,
                      struct kernel_stat*,   b)
#endif
  LSS_INLINE _syscall6(int,     futex,           int*,        a,
                       int,            o, int,    v,
                      struct kernel_timespec*, t,
                       int*, a2,
                       int, v3)
#ifdef __NR_getdents64
    LSS_INLINE _syscall3(int,     getdents64,      int,         f,
                         struct kernel_dirent64*, d, int,    c)
#define KERNEL_DIRENT kernel_dirent64
#define GETDENTS sys_getdents64
#else
    LSS_INLINE _syscall3(int,     getdents,        int,         f,
                         struct kernel_dirent*, d, int,    c)
#define KERNEL_DIRENT kernel_dirent
#define GETDENTS sys_getdents
#endif
                       const struct kernel_sigaction*, a,
                       struct kernel_sigaction*, o, size_t,   c)
  LSS_INLINE _syscall4(int, rt_sigprocmask,      int,         h,
                       const struct kernel_sigset_t*,  s,
                       struct kernel_sigset_t*,        o, size_t, c);
  LSS_INLINE _syscall0(int,     sched_yield)
  LSS_INLINE _syscall2(int,     sigaltstack,     const stack_t*, s,
                       const stack_t*, o)
    LSS_INLINE _syscall4(int, fstatat, int, d, const char *, p,
                         struct kernel_stat*,   b, int, flags)
    LSS_INLINE int LSS_NAME(stat)(const char* p, struct kernel_stat* b) {
      return LSS_NAME(fstatat)(AT_FDCWD,p,b,0);
  }
    LSS_INLINE _syscall2(int,     stat,            const char*, f,
                         struct kernel_stat*,   b)
  #endif
  LSS_INLINE _syscall3(ssize_t, write,            int,        f,
                       const void *,   b, size_t, c)
                                       const struct kernel_sigaction *act,
                                       struct kernel_sigaction *oldact) {
      #if defined(__x86_64__)
      /* On x86_64, the kernel requires us to always set our own
       * SA_RESTORER in order to be able to return from a signal handler.
      if (act != NULL && !(act->sa_flags & SA_RESTORER)) {
        struct kernel_sigaction a = *act;
        a.sa_flags   |= SA_RESTORER;
        a.sa_restorer = LSS_NAME(restore_rt)();
        return LSS_NAME(rt_sigaction)(signum, &a, oldact,
                                         const struct kernel_sigset_t *set,
                                         struct kernel_sigset_t *oldset) {
      return LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
    }
  #endif
                                       const struct kernel_sigaction *act,
                                       struct kernel_sigaction *oldact) {
        return LSS_NAME(rt_sigaction)(signum, act, oldact, (KERNEL_NSIG+7)/8);

    }
                                         const struct kernel_sigset_t *set,
                                         struct kernel_sigset_t *oldset) {
      return LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
    }
  #endif
                         int*,                    s, int,       o,
                         struct kernel_rusage*,   r)
    LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options){
      return LSS_NAME(wait4)(pid, status, options, 0);
    }
    LSS_INLINE _syscall2(int, fstat64,             int, f,
                         struct kernel_stat64 *, b)
    LSS_INLINE _syscall5(int, _llseek,     uint, fd, ulong, hi, ulong, lo,
                         loff_t *, res, uint, wh)
#if defined(__s390__) && !defined(__s390x__)
                         const struct kernel_old_sigaction*,  a,
                         struct kernel_old_sigaction*,        o)
    LSS_INLINE _syscall3(int,   _sigprocmask,      int,   h,
                         const unsigned long*,     s,
                         unsigned long*,           o)
    LSS_INLINE _syscall2(int, stat64,              const char *, p,
                         struct kernel_stat64 *, b)

    LSS_INLINE int LSS_NAME(sigaction)(int signum,
                                       const struct kernel_sigaction *act,
                                       struct kernel_sigaction *oldact) {
      int old_errno = LSS_ERRNO;
      int rc;
      struct kernel_sigaction a;
      if (act != NULL) {
        a             = *act;
        #ifdef __i386__
      if (rc < 0 && LSS_ERRNO == ENOSYS) {
        struct kernel_old_sigaction oa, ooa, *ptr_a = &oa, *ptr_oa = &ooa;
        if (!act) {
          ptr_a            = NULL;
        } else {
                                         const struct kernel_sigset_t *set,
                                         struct kernel_sigset_t *oldset) {
      int olderrno = LSS_ERRNO;
      int rc = LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
      if (rc < 0 && LSS_ERRNO == ENOSYS) {


//========================================
//===== File: ./third-party/gperftools/src/base/linuxthreads.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/base/logging.h =====
//========================================
#ifdef NDEBUG
enum { DEBUG_MODE = 0 };
#define RAW_DCHECK(condition, message)
#else
enum { DEBUG_MODE = 1 };
#define RAW_DCHECK(condition, message)  RAW_CHECK(condition, message)
#endif

#endif
enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};

// NOTE: we add a newline to the end of the output if it's not there already
inline void LogPrintf(int severity, const char* pat, va_list ap) {
#include <windows.h>
typedef HANDLE RawFD;
const RawFD kIllegalRawFD = INVALID_HANDLE_VALUE;
#else
typedef int RawFD;
const RawFD kIllegalRawFD = -1;   // what open returns if it fails
#endif  // defined(_WIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__)



//========================================
//===== File: ./third-party/gperftools/src/base/low_level_alloc.h =====
//========================================

class LowLevelAlloc {
 public:
  class PagesAllocator {
  public:
    virtual ~PagesAllocator();
    virtual void *MapPages(int32 flags, size_t size) = 0;
    virtual void UnMapPages(int32 flags, void *addr, size_t size) = 0;
  };

  static PagesAllocator *GetDefaultPagesAllocator(void);

  struct Arena;       // an arena from which memory may be allocated

  // Returns a pointer to a block of at least "request" bytes
  // that have been newly allocated from the specific arena.
  // is not available.
  static void *Alloc(size_t request)
    ATTRIBUTE_SECTION(malloc_hook);
  static void *AllocWithArena(size_t request, Arena *arena)
    ATTRIBUTE_SECTION(malloc_hook);

  // Deallocates a region of memory that was previously allocated with
  // from which it was allocated.
  static void Free(void *s) ATTRIBUTE_SECTION(malloc_hook);

    // ATTRIBUTE_SECTION(malloc_hook) for Alloc* and Free
    // are to put all callers of MallocHook::Invoke* in this module
  // These values may be ored into flags:
  enum {
    // Report calls to Alloc() and Free() via the MallocHook interface.
    // Set in the DefaultArena.
    kCallMallocHook = 0x0001,
  };
  static Arena *NewArena(int32 flags, Arena *meta_data_arena);

  // note: pages allocator will never be destroyed and allocated pages will never be freed
  // When allocator is NULL, it's same as NewArena
  static Arena *NewArenaWithCustomAlloc(int32 flags, Arena *meta_data_arena, PagesAllocator *allocator);

  // Destroys an arena allocated by NewArena and returns true,
  // provided no allocated blocks remain in the arena.
  // It is illegal to attempt to destroy the DefaultArena().
  static bool DeleteArena(Arena *arena);

  // The default arena that always exists.
  static Arena *DefaultArena();

 private:
  LowLevelAlloc();      // no instances
};



//========================================
//===== File: ./third-party/gperftools/src/base/simple_mutex.h =====
//========================================
#if defined(NO_THREADS)
  typedef int MutexType;      // to keep a lock-count
#elif defined(_WIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__)
# ifndef WIN32_LEAN_AND_MEAN
#   define WIN32_LEAN_AND_MEAN  // We only need minimal includes
# include <windows.h>
  typedef CRITICAL_SECTION MutexType;
#elif defined(HAVE_PTHREAD) && defined(HAVE_RWLOCK)
  // Needed for pthread_rwlock_*.  If it causes problems, you could take it
  // out, but then you'd have to unset HAVE_RWLOCK (at least on linux -- it
# include <pthread.h>
  typedef pthread_rwlock_t MutexType;
#elif defined(HAVE_PTHREAD)
# include <pthread.h>
  typedef pthread_mutex_t MutexType;
#else
# error Need to implement mutex.h for your architecture, or #define NO_THREADS
#endif

namespace MUTEX_NAMESPACE {

class Mutex {
 public:
  // This is used for the single-arg constructor
  enum LinkerInitialized { LINKER_INITIALIZED };

  // Create a Mutex that is not held by anybody.  This constructor is
  // typically used for Mutexes allocated on the heap or the stack.

 private:
  MutexType mutex_;
  // We want to make sure that the compiler sets is_safe_ to true only
  // when we tell it to, and never makes assumptions is_safe_ is
// MutexLock(mu) acquires mu when constructed and releases it when destroyed.
class MutexLock {
 public:
  explicit MutexLock(Mutex *mu) : mu_(mu) { mu_->Lock(); }
  ~MutexLock() { mu_->Unlock(); }
 private:
  Mutex * const mu_;
  // Disallow "evil" constructors
  MutexLock(const MutexLock&);
// ReaderMutexLock and WriterMutexLock do the same, for rwlocks
class ReaderMutexLock {
 public:
  explicit ReaderMutexLock(Mutex *mu) : mu_(mu) { mu_->ReaderLock(); }
  ~ReaderMutexLock() { mu_->ReaderUnlock(); }
 private:
  Mutex * const mu_;
  // Disallow "evil" constructors
  ReaderMutexLock(const ReaderMutexLock&);

class WriterMutexLock {
 public:
  explicit WriterMutexLock(Mutex *mu) : mu_(mu) { mu_->WriterLock(); }
  ~WriterMutexLock() { mu_->WriterUnlock(); }
 private:
  Mutex * const mu_;
  // Disallow "evil" constructors
  WriterMutexLock(const WriterMutexLock&);


//========================================
//===== File: ./third-party/gperftools/src/base/spinlock.h =====
//========================================

class LOCKABLE SpinLock {
 public:
  SpinLock() : lockword_(kSpinLockFree) { }

  // Special constructor for use with static SpinLock objects.  E.g.,
  // initializers run.
  explicit SpinLock(base::LinkerInitialized /*x*/) {
    // Does nothing; lockword_ is already initialized
  }


  static const base::LinkerInitialized LINKER_INITIALIZED;  // backwards compat
 private:
  enum { kSpinLockFree = 0 };
  enum { kSpinLockHeld = 1 };
  enum { kSpinLockSleeper = 2 };

  volatile Atomic32 lockword_;

// the duration of a C++ scope.
class SCOPED_LOCKABLE SpinLockHolder {
 private:
  SpinLock* lock_;
 public:
  inline explicit SpinLockHolder(SpinLock* l) EXCLUSIVE_LOCK_FUNCTION(l)
      : lock_(l) {
    l->Lock();


//========================================
//===== File: ./third-party/gperftools/src/base/spinlock_internal.h =====
//========================================

namespace base {
namespace internal {

void SpinLockWake(volatile Atomic32 *w, bool all);
void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop);


//========================================
//===== File: ./third-party/gperftools/src/base/spinlock_linux-inl.h =====
//========================================

static bool have_futex;
static int futex_private_flag = FUTEX_PRIVATE_FLAG;

namespace {
static struct InitModule {
  InitModule() {
    int x = 0;
    // futexes are ints, so we can use them only when

namespace base {
namespace internal {

void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {
  if (loop != 0) {
    int save_errno = errno;
    struct timespec tm;
    tm.tv_sec = 0;
    if (have_futex) {
      tm.tv_nsec = base::internal::SuggestedDelayNS(loop);


//========================================
//===== File: ./third-party/gperftools/src/base/spinlock_posix-inl.h =====
//========================================

namespace base {
namespace internal {

void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {
  int save_errno = errno;
  } else {
    struct timespec tm;
    tm.tv_sec = 0;
    tm.tv_nsec = base::internal::SuggestedDelayNS(loop);
    nanosleep(&tm, NULL);


//========================================
//===== File: ./third-party/gperftools/src/base/spinlock_win32-inl.h =====
//========================================

namespace base {
namespace internal {

void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {
  if (loop == 0) {


//========================================
//===== File: ./third-party/gperftools/src/base/stl_allocator.h =====
//========================================
//         The code is simply lifted from what std::allocator<> provides.
template <typename T, class Alloc>
class STL_Allocator {
 public:
  typedef size_t     size_type;
  typedef ptrdiff_t  difference_type;
  typedef T*         pointer;
  typedef const T*   const_pointer;
  typedef T&         reference;
  typedef const T&   const_reference;
  typedef T          value_type;

  template <class T1> struct rebind {
    typedef STL_Allocator<T1, Alloc> other;
  };

  STL_Allocator() { }
  STL_Allocator(const STL_Allocator&) { }
  template <class T1> STL_Allocator(const STL_Allocator<T1, Alloc>&) { }
  ~STL_Allocator() { }

  pointer address(reference x) const { return &x; }


//========================================
//===== File: ./third-party/gperftools/src/base/sysinfo.h =====
//========================================
//    proc            /proc   procfs  rw 0 0
class ProcMapsIterator {
 public:
  struct Buffer {
#ifdef __FreeBSD__
    // FreeBSD requires us to read all of the maps file at once, so
    // we have to make a buffer that's "always" big enough
    static const size_t kBufSize = 102400;
#else   // a one-line buffer is good enough
    static const size_t kBufSize = PATH_MAX + 1024;
#endif
    char buf_[kBufSize];
  };
  // Create a new iterator for the specified pid.  pid can be 0 for "self".
  explicit ProcMapsIterator(pid_t pid);

  // Create an iterator with specified storage (for use in signal
  // handler). "buffer" should point to a ProcMapsIterator::Buffer
  // called again.  (Since filename, at least, points into CurrentLine.)
  static int FormatLine(char* buffer, int bufsize,
                        uint64 start, uint64 end, const char *flags,
                        uint64 offset, int64 inode, const char *filename,
                        dev_t dev);

 private:
  void Init(pid_t pid, Buffer *buffer, bool use_maps_backing);

  char *ibuf_;        // input buffer

namespace tcmalloc {
int FillProcSelfMaps(char buf[], int size, bool* wrote_all);
void DumpProcSelfMaps(RawFD fd);
}


//========================================
//===== File: ./third-party/gperftools/src/base/thread_annotations.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/base/thread_lister.h =====
//========================================

typedef int (*ListAllProcessThreadsCallBack)(void *parameter,
                                             int num_threads,
                                             pid_t *thread_pids,
                                             va_list ap);


//========================================
//===== File: ./third-party/gperftools/src/base/vdso_support.h =====
//========================================

namespace base {

// NOTE: this class may be used from within tcmalloc, and can not
// use any memory allocation routines.
class VDSOSupport {
 public:
  VDSOSupport();

  typedef ElfMemImage::SymbolInfo SymbolInfo;
  typedef ElfMemImage::SymbolIterator SymbolIterator;

  // Answers whether we have a vdso at all.
  bool IsPresent() const { return image_.IsPresent(); }
  // possible; before any thread creation, chroot or setuid.
  static const void *Init();

 private:
  // image_ represents VDSO ELF image in memory.
  // image_.ehdr_ == NULL implies there is no VDSO.
  ElfMemImage image_;
  // page-aligned.
  static const void *vdso_base_;

  DISALLOW_COPY_AND_ASSIGN(VDSOSupport);
};


//========================================
//===== File: ./third-party/gperftools/src/central_freelist.h =====
//========================================

namespace tcmalloc {

// Data kept per size-class in central cache.
class CentralFreeList {
 public:
  // A CentralFreeList may be used before its constructor runs.
  // So we prevent lock_'s constructor from doing anything to the
  // lock_ state.

 private:
  // TransferCache is used to cache transfers of
  // sizemap.num_objects_to_move(size_class) back and forth between
  // thread caches and the central cache for a given size class.
  struct TCEntry {
    void *head;  // Head of chain of objects.
    void *tail;  // Tail of chain of objects.
  };
  // For the small memory model, the transfer cache is not used.
  static const int kMaxNumTransferEntries = 0;
#else
  // Starting point for the the maximum number of entries in the transfer cache.
  // This actual maximum for a given size class may be lower than this
  // maximum value.
  static const int kMaxNumTransferEntries = 64;
#endif

  // REQUIRES: lock_ is held
  // May temporarily lock a "random" size class.
  static bool EvictRandomSizeClass(int locked_size_class, bool force);

  // REQUIRES: lock_ is *not* held.
  // Tries to shrink the Cache.  If force is true it will relase objects to
// sizeof(CentralFreeList) is a multiple of 64.
template<int kFreeListSizeMod64>
class CentralFreeListPaddedTo : public CentralFreeList {
 private:
  char pad_[64 - kFreeListSizeMod64];
};

template<>
class CentralFreeListPaddedTo<0> : public CentralFreeList {
};

class CentralFreeListPadded : public CentralFreeListPaddedTo<
  sizeof(CentralFreeList) % 64> {
};



//========================================
//===== File: ./third-party/gperftools/src/common.h =====
//========================================
// Type that can hold a page number
typedef uintptr_t PageID;

// Type that can hold the length of a run of pages
typedef uintptr_t Length;

//-------------------------------------------------------------------
// Configuration
// waste due alignment of 25%. (eg malloc of 24 bytes will get 32 bytes)
static const size_t kMinAlign   = 8;
#else
static const size_t kMinAlign   = 16;
#endif

// Using large pages speeds up the execution at a cost of larger memory use.
#if defined(TCMALLOC_32K_PAGES)
static const size_t kPageShift  = 15;
#elif defined(TCMALLOC_64K_PAGES)
static const size_t kPageShift  = 16;
#else
static const size_t kPageShift  = 13;
#endif

static const size_t kClassSizesMax = 96;

static const size_t kMaxThreadCacheSize = 4 << 20;

static const size_t kPageSize   = 1 << kPageShift;
static const size_t kMaxSize    = 256 * 1024;
static const size_t kAlignment  = 8;
// For all span-lengths <= kMaxPages we keep an exact-size list in PageHeap.
static const size_t kMaxPages = 1 << (20 - kPageShift);

// Default bound on the total amount of thread caches.
#ifdef TCMALLOC_SMALL_BUT_SLOW
// for the small memory footprint case.
static const size_t kDefaultOverallThreadCacheSize = kMaxThreadCacheSize;
#else
static const size_t kDefaultOverallThreadCacheSize = 8u * kMaxThreadCacheSize;
#endif

// Lower bound on the per-thread cache sizes
static const size_t kMinThreadCacheSize = kMaxSize * 2;

// The number of bytes one ThreadCache will steal from another when
// the first ThreadCache is forced to Scavenge(), delaying the
// next call to Scavenge for this thread.
static const size_t kStealAmount = 1 << 16;

// The number of times that a deallocation can cause a freelist to
// go over its max_length() before shrinking max_length().
static const int kMaxOverages = 3;

// Maximum length we allow a per-thread free-list to have before we
// move objects from it into the corresponding central free-list.  We
// scavenging code will shrink it down when its contents are not in use.
static const int kMaxDynamicFreeListLength = 8192;

static const Length kMaxValidPages = (~static_cast<Length>(0)) >> kPageShift;

#if __aarch64__ || __x86_64__ || _M_AMD64 || _M_ARM64
// All current x86_64 processors only look at the lower 48 bits in
// OS perspective. So we can keep doing "48 bits" at least for now.
static const int kAddressBits = (sizeof(void*) < 8 ? (8 * sizeof(void*)) : 48);
#else
// mipsen and ppcs have more general hardware so we have to support
// full 64-bits of addresses.
static const int kAddressBits = 8 * sizeof(void*);
#endif

namespace tcmalloc {

// Convert byte size into pages.  This won't overflow, but may return
// an unreasonably large value if bytes is huge enough.
// Size-class information + mapping
class SizeMap {
 private:
  //-------------------------------------------------------------------
  // Mapping from size to size_class and vice versa
  //-------------------------------------------------------------------
  //   32768      (32768 + 127 + (120<<7)) / 128  376
  static const int kMaxSmallSize = 1024;
  static const size_t kClassArraySize =
      ((kMaxSize + 127 + (120 << 7)) >> 7) + 1;
  unsigned char class_array_[kClassArraySize];

  static inline size_t SmallSizeClass(size_t s) {
    return (static_cast<uint32_t>(s) + 7) >> 3;
  }

  static inline size_t LargeSizeClass(size_t s) {
    return (static_cast<uint32_t>(s) + 127 + (120 << 7)) >> 7;
  }

  // parameter idx and returning true. Otherwise return false.
  static inline bool ATTRIBUTE_ALWAYS_INLINE ClassIndexMaybe(size_t s,
                                                             uint32* idx) {
    if (PREDICT_TRUE(s <= kMaxSmallSize)) {
      *idx = (static_cast<uint32>(s) + 7) >> 3;
  // Compute index of the class_array[] entry for a given size
  static inline size_t ClassIndex(size_t s) {
    // Use unsigned arithmetic to avoid unnecessary sign extensions.
    ASSERT(0 <= s);
    ASSERT(s <= kMaxSize);

 public:
  size_t num_size_classes;

  // Constructor should do nothing since we rely on explicit Init()
// code below can conveniently cast them back and forth to void*.
static const int kMaxStackDepth = 31;
struct StackTrace {
  uintptr_t size;          // Size of object
  uintptr_t depth;         // Number of PC values stored in array below
  void*     stack[kMaxStackDepth];


//========================================
//===== File: ./third-party/gperftools/src/emergency_malloc.h =====
//========================================

namespace tcmalloc {
  static const uintptr_t kEmergencyArenaShift = 20+4; // 16 megs
  static const uintptr_t kEmergencyArenaSize = 1 << kEmergencyArenaShift;

  extern __attribute__ ((visibility("internal"))) char *emergency_arena_start;
  extern __attribute__ ((visibility("internal"))) uintptr_t emergency_arena_start_shifted;;

  static inline bool IsEmergencyPtr(const void *_ptr) {
    uintptr_t ptr = reinterpret_cast<uintptr_t>(_ptr);
    return PREDICT_FALSE((ptr >> kEmergencyArenaShift) == emergency_arena_start_shifted)
      && emergency_arena_start_shifted;


//========================================
//===== File: ./third-party/gperftools/src/getenv_safe.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/getpc.h =====
//========================================
#include <cygwin/signal.h>
typedef ucontext ucontext_t;
#endif


// any further processing.
struct CallUnrollInfo {
  // Offset from (e)ip register where this instruction sequence
  // should be matched. Interpreted as bytes. Offset 0 is the next
  // instruction to execute. Be extra careful with negative offsets in
#if defined(__linux) && defined(__i386) && defined(__GNUC__)
static const CallUnrollInfo callunrollinfo[] = {
  // Entry to a function:  push %ebp;  mov  %esp,%ebp
  // Top-of-stack contains the caller IP.
  { 0,
#ifndef HAVE_CYGWIN_SIGNAL_H
typedef int ucontext_t;
#endif

inline void* GetPC(const struct ucontext_t& signal_ucontext) {


//========================================
//===== File: ./third-party/gperftools/src/google/heap-checker.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/heap-profiler.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/malloc_extension.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/malloc_extension_c.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/malloc_hook.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/malloc_hook_c.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/profiler.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/stacktrace.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/google/tcmalloc.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/gperftools/heap-checker.h =====
//========================================
// as well as HeapLeakChecker objects: they can be accessed by multiple threads.
class PERFTOOLS_DLL_DECL HeapLeakChecker {
 public:

  // ----------------------------------------------------------------------- //
  // Static functions for working with (whole-program) leak checking.
  // if FLAGS_heap_check gets set to "" by some code before/during InitGoogle().
  static bool IsActive();

  // Return pointer to the whole-program checker if it has been created
  // and NULL otherwise.
  // or similar and gets false.
  static HeapLeakChecker* GlobalChecker();

  // Do whole-program leak check now (if it was activated for this binary);
  // return false only if it was activated and has failed.
  // to do the desired flavor of the check.
  static bool NoGlobalLeaks();

  // If whole-program checker if active,
  // cancel its automatic execution after main() exits.
  // has been called at least once on the whole-program checker.
  static void CancelGlobalCheck();

  // ----------------------------------------------------------------------- //
  // Non-static functions for starting and doing leak checking.
  // in particular not contain path expressions.
  explicit HeapLeakChecker(const char *name);

  // Destructor (verifies that some *NoLeaks or *SameHeap method
  // has been called at least once).
  // REQUIRES: Destructor runs in same thread as constructor
  class Disabler {
   public:
    Disabler();
    ~Disabler();
   private:
    Disabler(const Disabler&);        // disallow copy
    void operator=(const Disabler&);  // and assign
  };
  // whitelist objects referenced through it.
  template <typename T>
  static T* IgnoreObject(T* ptr) {
    DoIgnoreObject(static_cast<const void*>(const_cast<const T*>(ptr)));
    return ptr;
  }
  // allocated object which was previously registered with IgnoreObject().
  static void UnIgnoreObject(const void* ptr);

  // ----------------------------------------------------------------------- //
  // Internal types defined in .cc

  class Allocator;
  struct RangeValue;

 private:

  // ----------------------------------------------------------------------- //
  // Various helpers

  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };

  // Helper for *NoLeaks and *SameHeap
  bool DoNoLeaks(ShouldSymbolize should_symbolize);
  // Helper for NoGlobalLeaks, also called by the global destructor.
  static bool NoGlobalLeaksMaybeSymbolize(ShouldSymbolize should_symbolize);

  // These used to be public, but they are now deprecated.
  // Will remove entirely when all internal uses are fixed.
  // In the meantime, use friendship so the unittest can still test them.
  static void* GetDisableChecksStart();
  static void DisableChecksToHereFrom(const void* start_address);
  static void DisableChecksIn(const char* pattern);
  friend void RangeDisabledLeaks();
  friend void NamedTwoDisabledLeaks();
  friend void* RunNamedDisabledLeaks(void*);
  // Actually implements IgnoreObject().
  static void DoIgnoreObject(const void* ptr);

  // Disable checks based on stack trace entry at a depth <=
  // max_depth.  Used to hide allocations done inside some special
  // libraries.
  static void DisableChecksFromToLocked(const void* start_address,
                                        const void* end_address,
                                        int max_depth);

  // Helper for DoNoLeaks to ignore all objects reachable from all live data
  static void IgnoreAllLiveObjectsLocked(const void* self_stack_top);

  // Callback we pass to TCMalloc_ListAllProcessThreads (see thread_lister.h)
  // that is invoked when all threads of our process are found and stopped.
  // it found and attached to.
  static int IgnoreLiveThreadsLocked(void* parameter,
                                     int num_threads,
                                     pid_t* thread_pids,
                                     va_list ap);
  // not related to thread stacks and registers.
  static void IgnoreNonThreadLiveObjectsLocked();

  // Helper for IgnoreNonThreadLiveObjectsLocked and IgnoreLiveThreadsLocked
  // to discover and ignore all heap objects
  // are being used.
  static void IgnoreLiveObjectsLocked(const char* name, const char* name2);

  // Do the overall whole-program heap leak check if needed;
  // returns true when did the leak check.
  static bool DoMainHeapCheck();

  // Type of task for UseProcMapsLocked
  enum ProcMapsTask {
    RECORD_GLOBAL_DATA,
    DISABLE_LIBRARY_ALLOCS
  };
  // Success/Error Return codes for UseProcMapsLocked.
  enum ProcMapsResult {
    PROC_MAPS_USED,
    CANT_OPEN_PROC_MAPS,
    NO_SHARED_LIBS_IN_PROC_MAPS
  // Read /proc/self/maps, parse it, and do the 'proc_maps_task' for each line.
  static ProcMapsResult UseProcMapsLocked(ProcMapsTask proc_maps_task);

  // A ProcMapsTask to disable allocations from 'library'
  // that is mapped to [start_address..end_address)
  // (only if library is a certain system library).
  static void DisableLibraryAllocsLocked(const char* library,
                                         uintptr_t start_address,
                                         uintptr_t end_address);

  // and we move "*ptr" to point to the very start of the heap object.
  static inline bool HaveOnHeapLocked(const void** ptr, size_t* object_size);

  // Helper to shutdown heap leak checker when it's not needed
  // or can't function properly.
  static void TurnItselfOffLocked();

  // Internally-used c-tor to start whole-executable checking.
  HeapLeakChecker();
  // which must be a heap object.
  static const void* GetAllocCaller(void* ptr);
  friend void VerifyHeapProfileTableStackGet();

  // This gets to execute before constructors for all global objects
  static void BeforeConstructorsLocked();
  friend void HeapLeakChecker_BeforeConstructors();

  // This gets to execute after destructors for all global objects

  class SpinLock* lock_;  // to make HeapLeakChecker objects thread-safe
  const char* name_;  // our remembered name (we own it)
                      // NULL means this leak checker is a noop

// all objects reachable from o are ignored by the heap checker.
template <class T>
class HiddenPointer {
 public:
  explicit HiddenPointer(T* t)
      : masked_t_(reinterpret_cast<uintptr_t>(t) ^ kHideMask) {
  }
  // Returns unhidden pointer.  Be careful where you save the result.

 private:
  // Arbitrary value, but not such that xor'ing with it is likely
  // to map one valid pointer to another valid pointer:
  static const uintptr_t kHideMask =
      static_cast<uintptr_t>(0xF03A5F7BF03A5F7Bll);
  uintptr_t masked_t_;
};

// used directly, but instead by the REGISTER_HEAPCHECK_CLEANUP macro below.
class PERFTOOLS_DLL_DECL HeapCleaner {
 public:
  typedef void (*void_function)(void);
  HeapCleaner(void_function f);
  static void RunHeapCleanups();
 private:
  static std::vector<void_function>* heap_cleanups_;
};

// A macro to declare module heap check cleanup tasks
#define REGISTER_HEAPCHECK_CLEANUP(name, body)  \
  namespace { \
  void heapcheck_cleanup_##name() { body; } \
  static HeapCleaner heapcheck_cleaner_##name(&heapcheck_cleanup_##name); \
  }

#endif  // BASE_HEAP_CHECKER_H_


//========================================
//===== File: ./third-party/gperftools/src/gperftools/heap-profiler.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/gperftools/malloc_extension.h =====
//========================================

static const int kMallocHistogramSize = 64;

// One day, we could support other types of writers (perhaps for C?)
typedef std::string MallocExtensionWriter;

namespace base {
struct MallocRange;
}

// Interface to a pluggable system allocator.
class PERFTOOLS_DLL_DECL SysAllocator {
 public:
  SysAllocator() {
  }
  virtual ~SysAllocator();

  // Allocates "size"-byte of memory from system aligned with "alignment".
  // Returns NULL if failed. Otherwise, the returned pointer p up to and
  // including (p + actual_size -1) have been allocated.
  virtual void* Alloc(size_t size, size_t *actual_size, size_t alignment) = 0;
};

// The default implementations of the following routines do nothing.
// (TCMallocImplementation) is.
class PERFTOOLS_DLL_DECL MallocExtension {
 public:
  virtual ~MallocExtension();

  // Call this very early in the program execution -- say, in a global
  // constructor -- to set up parameters and state needed by all
  // multiple times, as long as each time is before threads start up.
  static void Initialize();

  // See "verify_memory.h" to see what these routines do
  virtual bool VerifyAllMemory();
  virtual bool VerifyNewMemory(const void* p);
  virtual bool VerifyArrayNewMemory(const void* p);
  virtual bool VerifyMallocMemory(const void* p);
  virtual bool MallocMemoryStats(int* blocks, size_t* total,
                                 int histogram[kMallocHistogramSize]);

  // Get a human readable description of the following malloc data structures.
  // REQUIRES: buffer_length > 0.
  virtual void GetStats(char* buffer, int buffer_length);

  // Outputs to "writer" a sample of live objects and the stack traces
  // that allocated these objects.  The format of the returned output
  //       variable TCMALLOC_SAMPLE_PARAMETER to a value such as 524288.
  virtual void GetHeapSample(MallocExtensionWriter* writer);

  // Outputs to "writer" the stack traces that caused growth in the
  // address space size.  The format of the returned output is
  // TCMALLOC_SAMPLE_PARAMETER.)
  virtual void GetHeapGrowthStacks(MallocExtensionWriter* writer);

  // Invokes func(arg, range) for every controlled memory
  // range.  *range is filled in with information about the range.
  // analysis.  The implementation may not call func at all.
  typedef void (RangeFunction)(void*, const base::MallocRange*);
  virtual void Ranges(void* arg, RangeFunction func);

  // -------------------------------------------------------------------
  // Control operations for getting and setting malloc implementation
  // REQUIRES: property != NULL; value != NULL
  virtual bool GetNumericProperty(const char* property, size_t* value);

  // Set the named "property"'s value.  Returns true if the property
  // is known and writable.  Returns false if the property is not a
  // REQUIRES: property != NULL
  virtual bool SetNumericProperty(const char* property, size_t value);

  // Mark the current thread as "idle".  This routine may optionally
  // be called by threads as a hint to the malloc implementation that
  // Most malloc implementations ignore this routine.
  virtual void MarkThreadIdle();

  // Mark the current thread as "busy".  This routine should be
  // called after MarkThreadIdle() if the thread will now do more
  // Most malloc implementations ignore this routine.
  virtual void MarkThreadBusy();

  // Gets the system allocator used by the malloc extension instance. Returns
  // NULL for malloc implementations that do not support pluggable system
  // allocators.
  virtual SysAllocator* GetSystemAllocator();

  // Sets the system allocator to the specified.
  //
  // system allocators.
  virtual void SetSystemAllocator(SysAllocator *a);

  // Try to release num_bytes of free memory back to the operating
  // system for reuse.  Use this extension with caution -- to get this
  // that may be slow.  (Currently only implemented in tcmalloc.)
  virtual void ReleaseToSystem(size_t num_bytes);

  // Same as ReleaseToSystem() but release as much memory as possible.
  virtual void ReleaseFreeMemory();

  // Sets the rate at which we release unused memory to the system.
  // Zero means we never release memory back to the system.  Increase
  // only implemented in tcmalloc).
  virtual void SetMemoryReleaseRate(double rate);

  // Gets the release rate.  Returns a value < 0 if unknown.
  virtual double GetMemoryReleaseRate();

  // Returns the estimated number of bytes that will be allocated for
  // a request of "size" bytes.  This is an estimate: an allocation of
  // This is equivalent to malloc_good_size() in OS X.
  virtual size_t GetEstimatedAllocatedSize(size_t size);

  // Returns the actual number N of bytes reserved by tcmalloc for the
  // pointer p.  The client is allowed to use the range of bytes
  // in glibc, and _msize() for windows.
  virtual size_t GetAllocatedSize(const void* p);

  // Returns kOwned if this malloc implementation allocated the memory
  // pointed to by p, or kNotOwned if some other malloc implementation
  // a pointer after having called free() on it).
  enum Ownership {
    // NOTE: Enum values MUST be kept in sync with the version in
    // malloc_extension_c.h
    kUnknownOwnership = 0,
  };
  virtual Ownership GetOwnership(const void* p);

  // The current malloc implementation.  Always non-NULL.
  static MallocExtension* instance();

  // Change the malloc implementation.  Typically called by the
  // malloc implementation during initialization.
  static void Register(MallocExtension* implementation);

  // Returns detailed information about malloc's freelists. For each list,
  // return a FreeListInfo:
  struct FreeListInfo {
    size_t min_object_size;
    size_t max_object_size;
    size_t total_bytes_free;
  // "tcmalloc.thread" - tcmalloc's per-thread caches. Never unmapped.
  virtual void GetFreeListSizes(std::vector<FreeListInfo>* v);

  // Get a list of stack traces of sampled allocation points.  Returns
  // a pointer to a "new[]-ed" result array, and stores the sample
  // convenient "GetHeapSample(string*)" method defined above.
  virtual void** ReadStackTraces(int* sample_period);

  // Like ReadStackTraces(), but returns stack traces that caused growth
  // in the address space size.
  virtual void** ReadHeapGrowthStackTraces();

  // Returns the size in bytes of the calling threads cache.
  virtual size_t GetThreadCacheSize();

  // Like MarkThreadIdle, but does not destroy the internal data
  // structures of the thread cache. When the thread resumes, it wil
  // cache data structures.
  virtual void MarkThreadTemporarilyIdle();
};

namespace base {

// Information passed per range.  More fields may be added later.
struct MallocRange {
  enum Type {
    INUSE,                // Application is using this range
    FREE,                 // Range is currently free
    UNMAPPED,             // Backing physical memory has been returned to the OS


//========================================
//===== File: ./third-party/gperftools/src/gperftools/malloc_extension_c.h =====
//========================================
 */
typedef enum {
  MallocExtension_kUnknownOwnership = 0,
  MallocExtension_kOwned,
  MallocExtension_kNotOwned


//========================================
//===== File: ./third-party/gperftools/src/gperftools/malloc_hook.h =====
//========================================

class PERFTOOLS_DLL_DECL MallocHook {
 public:
  // The NewHook is invoked whenever an object is allocated.
  // It may be passed NULL if the allocator returned NULL.
  typedef MallocHook_NewHook NewHook;
  inline static bool AddNewHook(NewHook hook) {
    return MallocHook_AddNewHook(hook);
  }
  // It may be passed NULL if the caller is trying to delete NULL.
  typedef MallocHook_DeleteHook DeleteHook;
  inline static bool AddDeleteHook(DeleteHook hook) {
    return MallocHook_AddDeleteHook(hook);
  }
  // a memory limit, and take outside actions to increase that limit.
  typedef MallocHook_PreMmapHook PreMmapHook;
  inline static bool AddPreMmapHook(PreMmapHook hook) {
    return MallocHook_AddPreMmapHook(hook);
  }
  // again.
  typedef MallocHook_MmapReplacement MmapReplacement;
  inline static bool SetMmapReplacement(MmapReplacement hook) {
    return MallocHook_SetMmapReplacement(hook);
  }
  // It may be passed MAP_FAILED if the mmap failed.
  typedef MallocHook_MmapHook MmapHook;
  inline static bool AddMmapHook(MmapHook hook) {
    return MallocHook_AddMmapHook(hook);
  }
  // calling SetMunmapReplacement again.
  typedef MallocHook_MunmapReplacement MunmapReplacement;
  inline static bool SetMunmapReplacement(MunmapReplacement hook) {
    return MallocHook_SetMunmapReplacement(hook);
  }
  // The MunmapHook is invoked whenever a region of memory is unmapped.
  typedef MallocHook_MunmapHook MunmapHook;
  inline static bool AddMunmapHook(MunmapHook hook) {
    return MallocHook_AddMunmapHook(hook);
  }
  // The MremapHook is invoked whenever a region of memory is remapped.
  typedef MallocHook_MremapHook MremapHook;
  inline static bool AddMremapHook(MremapHook hook) {
    return MallocHook_AddMremapHook(hook);
  }
  // actions to increase such a limit.
  typedef MallocHook_PreSbrkHook PreSbrkHook;
  inline static bool AddPreSbrkHook(PreSbrkHook hook) {
    return MallocHook_AddPreSbrkHook(hook);
  }
  // memory-allocation call.
  typedef MallocHook_SbrkHook SbrkHook;
  inline static bool AddSbrkHook(SbrkHook hook) {
    return MallocHook_AddSbrkHook(hook);
  }
  // and MunmapReplacement.
  static void* UnhookedMMap(void *start, size_t length, int prot, int flags,
                            int fd, off_t offset);
  static int UnhookedMUnmap(void *start, size_t length);

  // The following are DEPRECATED.
  inline static NewHook GetNewHook();

 private:
  // Slow path versions of Invoke*Hook.
  static void InvokeNewHookSlow(const void* p, size_t s);
  static void InvokeDeleteHookSlow(const void* p);
  static void InvokePreMmapHookSlow(const void* start,
                                    size_t size,
                                    int protection,
                                    int flags,
                                    off_t offset);
  static void InvokeMmapHookSlow(const void* result,
                                 const void* start,
                                 size_t size,
                                 int protection,
                                 off_t offset);
  static bool InvokeMmapReplacementSlow(const void* start,
                                        size_t size,
                                        int protection,
                                        int flags,
                                        void** result);
  static void InvokeMunmapHookSlow(const void* p, size_t size);
  static bool InvokeMunmapReplacementSlow(const void* p,
                                          size_t size,
                                          int* result);
  static void InvokeMremapHookSlow(const void* result,
                                   const void* old_addr,
                                   size_t old_size,
                                   size_t new_size,
                                   const void* new_addr);
  static void InvokePreSbrkHookSlow(ptrdiff_t increment);
  static void InvokeSbrkHookSlow(const void* result, ptrdiff_t increment);
};

#ifdef _MSC_VER


//========================================
//===== File: ./third-party/gperftools/src/gperftools/malloc_hook_c.h =====
//========================================

typedef void (*MallocHook_NewHook)(const void* ptr, size_t size);
PERFTOOLS_DLL_DECL
int MallocHook_AddNewHook(MallocHook_NewHook hook);
PERFTOOLS_DLL_DECL

typedef void (*MallocHook_DeleteHook)(const void* ptr);
PERFTOOLS_DLL_DECL
int MallocHook_AddDeleteHook(MallocHook_DeleteHook hook);
PERFTOOLS_DLL_DECL

typedef void (*MallocHook_PreMmapHook)(const void *start,
                                       size_t size,
                                       int protection,
                                       int flags,

typedef void (*MallocHook_MmapHook)(const void* result,
                                    const void* start,
                                    size_t size,
                                    int protection,

typedef int (*MallocHook_MmapReplacement)(const void* start,
                                          size_t size,
                                          int protection,
                                          int flags,

typedef void (*MallocHook_MunmapHook)(const void* ptr, size_t size);
PERFTOOLS_DLL_DECL
int MallocHook_AddMunmapHook(MallocHook_MunmapHook hook);
PERFTOOLS_DLL_DECL

typedef int (*MallocHook_MunmapReplacement)(const void* ptr,
                                            size_t size,
                                            int* result);
int MallocHook_SetMunmapReplacement(MallocHook_MunmapReplacement hook);

typedef void (*MallocHook_MremapHook)(const void* result,
                                      const void* old_addr,
                                      size_t old_size,
                                      size_t new_size,

typedef void (*MallocHook_PreSbrkHook)(ptrdiff_t increment);
PERFTOOLS_DLL_DECL
int MallocHook_AddPreSbrkHook(MallocHook_PreSbrkHook hook);
PERFTOOLS_DLL_DECL

typedef void (*MallocHook_SbrkHook)(const void* result, ptrdiff_t increment);
PERFTOOLS_DLL_DECL
int MallocHook_AddSbrkHook(MallocHook_SbrkHook hook);
PERFTOOLS_DLL_DECL


//========================================
//===== File: ./third-party/gperftools/src/gperftools/nallocx.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/gperftools/profiler.h =====
//========================================
 */
struct ProfilerOptions {
  /* Filter function and argument.
   *
   * If filter_in_thread is not NULL, when a profiling tick is delivered
/* Stores state about profiler's current status into "*state". */
struct ProfilerState {
  int    enabled;             /* Is profiling currently enabled? */
  time_t start_time;          /* If enabled, when was profiling started? */
  char   profile_name[1024];  /* Name of profile file being written, or '\0' */


//========================================
//===== File: ./third-party/gperftools/src/gperftools/stacktrace.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/heap-profile-stats.h =====
//========================================

struct HeapProfileStats {
  // Returns true if the two HeapProfileStats are semantically equal.
  bool Equivalent(const HeapProfileStats& other) const {
    return allocs - frees == other.allocs - other.frees &&
// Allocation and deallocation statistics per each stack trace.
struct HeapProfileBucket : public HeapProfileStats {
  // Longest stack trace we record.
  static const int kMaxStackDepth = 32;

  uintptr_t hash;           // Hash value of the stack trace.
  int depth;                // Depth of stack trace.


//========================================
//===== File: ./third-party/gperftools/src/heap-profile-table.h =====
//========================================
// TODO(maxim): add a unittest for this class.
class HeapProfileTable {
 public:

  // Extension to be used for heap pforile files.
  static const char kFileExt[];

  // Longest stack trace we record.
  static const int kMaxStackDepth = 32;

  // data types ----------------------------

  // Profile stats.
  typedef HeapProfileStats Stats;

  // Info we can return about an allocation.
  struct AllocInfo {
    size_t object_size;  // size of the allocation
    const void* const* call_stack;  // call stack that made the allocation call
    int stack_depth;  // depth of call_stack
  // of an allocation operation.
  struct AllocContextInfo : public Stats {
    int stack_depth;                // Depth of stack trace
    const void* const* call_stack;  // Stack trace
  };
  // Memory (de)allocator interface we'll use.
  typedef void* (*Allocator)(size_t size);
  typedef void  (*DeAllocator)(void* ptr);

  // interface ---------------------------

  // and the memory allocation function.
  static int GetCallerStackTrace(int skip_count, void* stack[kMaxStackDepth]);

  // Record an allocation at 'ptr' of 'bytes' bytes.  'stack_depth'
  // and 'call_stack' identifying the function that requested the
  // fully-filled AllocInfo.
  typedef void (*AllocIterator)(const void* ptr, const AllocInfo& info);

  // Iterate over the allocation profile data calling "callback"
  // for every allocation.
  // Allocation context profile data iteration callback
  typedef void (*AllocContextIterator)(const AllocContextInfo& info);

  // Iterate over the allocation context profile data calling "callback"
  // for every allocation context. Allocation contexts are ordered by the
  // Cleanup any old profile files matching prefix + ".*" + kFileExt.
  static void CleanupOldProfiles(const char* prefix);

  // Return a snapshot of the current contents of *this.
  // Caller must call ReleaseSnapshot() on result when no longer needed.
  // the snapshot is discarded by calling ReleaseSnapshot().
  class Snapshot;
  Snapshot* TakeSnapshot();

  // Release a previously taken snapshot.  snapshot must not

 private:

  // data types ----------------------------

  // for a given allocation call stack trace.
  typedef HeapProfileBucket Bucket;

  // Info stored in the address map
  struct AllocValue {
    // Access to the stack-trace bucket
    Bucket* bucket() const {
      return reinterpret_cast<Bucket*>(bucket_rep & ~uintptr_t(kMask));

   private:
    // We store a few bits in the bottom bits of bucket_rep.
    // (Alignment is at least four, so we have at least two bits.)
    static const int kLive = 1;
    static const int kIgnore = 2;
    static const int kMask = kLive | kIgnore;

    uintptr_t bucket_rep;
  };
  // helper for FindInsideAlloc
  static size_t AllocValueSize(const AllocValue& v) { return v.bytes; }

  typedef AddressMap<AllocValue> AllocationMap;

  // Arguments that need to be passed DumpBucketIterator callback below.
  struct BufferArgs {
    BufferArgs(char* buf_arg, int buflen_arg, int bufsize_arg)
        : buf(buf_arg),
          buflen(buflen_arg),
  // Arguments that need to be passed DumpNonLiveIterator callback below.
  struct DumpArgs {
    DumpArgs(RawFD fd_arg, Stats* profile_stats_arg)
        : fd(fd_arg),
          profile_stats(profile_stats_arg) {
  // bucket to indicate the type of the profile.
  static int UnparseBucket(const Bucket& b,
                           char* buf, int buflen, int bufsize,
                           const char* extra,
                           Stats* profile_stats);
  // from AllocationMap::Iterate to AllocIterator.
  static void MapArgsAllocIterator(const void* ptr, AllocValue* v,
                                   AllocIterator callback) {
    AllocInfo info;
    info.object_size = v->bytes;
  // Helper for TakeSnapshot.  Saves object to snapshot.
  static void AddToSnapshot(const void* ptr, AllocValue* v, Snapshot* s);

  // Arguments passed to AddIfNonLive
  struct AddNonLiveArgs {
    Snapshot* dest;
    Snapshot* base;
  };
  // snapshot if it is non-live.
  static void AddIfNonLive(const void* ptr, AllocValue* v,
                           AddNonLiveArgs* arg);

  // Write contents of "*allocations" as a heap profile to
  // "*allocations".
  static bool WriteProfile(const char* file_name,
                           const Bucket& total,
                           AllocationMap* allocations);


class HeapProfileTable::Snapshot {
 public:
  const Stats& total() const { return total_; }

  // Report anything in this snapshot as a leak.

 private:
  friend class HeapProfileTable;

  // Total count/size are stored in a Bucket so we can reuse UnparseBucket
  // Helpers for sorting and generating leak reports
  struct Entry;
  struct ReportState;
  static void ReportCallback(const void* ptr, AllocValue* v, ReportState*);
  static void ReportObject(const void* ptr, AllocValue* v, char*);

  DISALLOW_COPY_AND_ASSIGN(Snapshot);
};


//========================================
//===== File: ./third-party/gperftools/src/internal_logging.h =====
//========================================

namespace tcmalloc {
enum LogMode {
  kLog,                       // Just print the message
  kCrash,                     // Print the message and crash
  kCrashWithStats             // Print the message, some stats, and crash

class Logger;

// A LogItem holds any of the argument types that can be passed to Log()
class LogItem {
 public:
  LogItem()                     : tag_(kEnd)      { }
  LogItem(const char* v)        : tag_(kStr)      { u_.str = v; }
  LogItem(int v)                : tag_(kSigned)   { u_.snum = v; }
  LogItem(const void* v)        : tag_(kPtr)      { u_.ptr = v; }
 private:
  friend class Logger;
  enum Tag {
    kStr,
    kSigned,
    kUnsigned,
// Print into buffer
class TCMalloc_Printer {
 private:
  char* buf_;           // Where should we write next
  int   left_;          // Space left in buffer (including space for \0)

 public:
  // REQUIRES: "length > 0"
  TCMalloc_Printer(char* buf, int length) : buf_(buf), left_(length) {
    buf[0] = '\0';


//========================================
//===== File: ./third-party/gperftools/src/libc_override.h =====
//========================================

static void ReplaceSystemAlloc();  // defined in the .h files below

// For windows, there are two ways to get tcmalloc.  If we're
// patching, then src/windows/patch_function.cc will do the necessary
void PatchWindowsFunctions();   // in src/windows/patch_function.cc
static void ReplaceSystemAlloc() { PatchWindowsFunctions(); }

#elif defined(_WIN32) && !defined(WIN32_DO_PATCHING)
#include "libc_override_redefine.h"


//========================================
//===== File: ./third-party/gperftools/src/libc_override_gcc_and_weak.h =====
//========================================

static void delegate_sized_delete(void *p, size_t s) {
  (operator delete)(p);
}

static void delegate_sized_deletearray(void *p, size_t s) {
  (operator delete[])(p);
}


static bool sized_delete_enabled(void) {
  if (tcmalloc_sized_delete_enabled != 0) {
    return !!tcmalloc_sized_delete_enabled();
  }

static void *resolve_delete_sized(void) {
  if (sized_delete_enabled()) {
    return reinterpret_cast<void *>(tc_delete_sized);
  }

static void *resolve_deletearray_sized(void) {
  if (sized_delete_enabled()) {
    return reinterpret_cast<void *>(tc_deletearray_sized);
  }

static void delegate_sized_aligned_delete(void *p, size_t s, std::align_val_t al) {
  (operator delete)(p, al);
}

static void delegate_sized_aligned_deletearray(void *p, size_t s, std::align_val_t al) {
  (operator delete[])(p, al);
}


static void *resolve_delete_sized_aligned(void) {
  if (sized_delete_enabled()) {
    return reinterpret_cast<void *>(tc_delete_sized_aligned);
  }

static void *resolve_deletearray_sized_aligned(void) {
  if (sized_delete_enabled()) {
    return reinterpret_cast<void *>(tc_deletearray_sized_aligned);
  }
#ifdef HAVE_STRUCT_MALLINFO
  struct mallinfo mallinfo(void) __THROW          ALIAS(tc_mallinfo);
#endif
  size_t malloc_size(void* p) __THROW             ALIAS(tc_malloc_size);
#if defined(__ANDROID__)
// via overriding weak symbols (at link time).
static void ReplaceSystemAlloc() { }

#endif  // TCMALLOC_LIBC_OVERRIDE_GCC_AND_WEAK_INL_H_


//========================================
//===== File: ./third-party/gperftools/src/libc_override_glibc.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/libc_override_osx.h =====
//========================================

namespace tcmalloc {
  void CentralCacheLockAll();
  void CentralCacheUnlockAll();
}
// We need to provide wrappers around all the libc functions.
namespace {
size_t mz_size(malloc_zone_t* zone, const void* ptr) {
  if (MallocExtension::instance()->GetOwnership(ptr) != MallocExtension::kOwned)
    return 0;  // malloc_zone semantics: return 0 if we don't own the memory

static malloc_zone_t *get_default_zone() {
   malloc_zone_t **zones = NULL;
   unsigned int num_zones = 0;


static void ReplaceSystemAlloc() {
  static malloc_introspection_t tcmalloc_introspection;
  memset(&tcmalloc_introspection, 0, sizeof(tcmalloc_introspection));

  tcmalloc_introspection.enumerator = &mi_enumerator;

  static malloc_zone_t tcmalloc_zone;
  memset(&tcmalloc_zone, 0, sizeof(malloc_zone_t));

  // Start with a version 4 zone which is used for OS X 10.4 and 10.5.


//========================================
//===== File: ./third-party/gperftools/src/libc_override_redefine.h =====
//========================================
#ifdef HAVE_STRUCT_MALLINFO
  struct mallinfo mallinfo(void)                 { return tc_mallinfo();      }
#endif
  size_t malloc_size(void* p)                    { return tc_malloc_size(p); }
  size_t malloc_usable_size(void* p)             { return tc_malloc_size(p); }
// via overriding weak symbols (at link time).
static void ReplaceSystemAlloc() { }

#endif  // TCMALLOC_LIBC_OVERRIDE_REDEFINE_H_


//========================================
//===== File: ./third-party/gperftools/src/linked_list.h =====
//========================================

namespace tcmalloc {

inline void *SLL_Next(void *t) {
  return *(reinterpret_cast<void**>(t));


//========================================
//===== File: ./third-party/gperftools/src/malloc_hook_mmap_freebsd.h =====
//========================================

static inline void* do_mmap(void *start, size_t length,
                            int prot, int flags,
                            int fd, off_t offset) __THROW {
  return (void *)MALLOC_HOOK_SYSCALL(SYS_mmap,

static inline void* do_sbrk(intptr_t increment) {
  static void *(*libc_sbrk)(intptr_t);
  if (libc_sbrk == NULL)
    libc_sbrk = (void *(*)(intptr_t))dlsym(RTLD_NEXT, "sbrk");

    result = do_mmap(start, length, prot, flags, fd,
                       static_cast<size_t>(offset)); // avoid sign extension
  }
  MallocHook::InvokeMmapHook(result, start, length, prot, flags, fd, offset);
  return result;


//========================================
//===== File: ./third-party/gperftools/src/malloc_hook_mmap_linux.h =====
//========================================

static inline void* do_mmap64(void *start, size_t length,
                              int prot, int flags,
                              int fd, off64_t offset) __THROW {
  return (void*)syscall(SYS_mmap, start, length, prot, flags, fd, offset);

static inline void* do_mmap64(void *start, size_t length,
                              int prot, int flags,
                              int fd, off64_t offset) __THROW {
  void *result;
  // Try mmap2() unless it's not supported
  static bool have_mmap2 = true;
  if (have_mmap2) {
    static int pagesize = 0;
    if (!pagesize) pagesize = getpagesize();

    // Check that the offset is page aligned
    result = do_mmap64(start, length, prot, flags, fd,
                       static_cast<size_t>(offset)); // avoid sign extension
  }
  MallocHook::InvokeMmapHook(result, start, length, prot, flags, fd, offset);
  return result;


//========================================
//===== File: ./third-party/gperftools/src/malloc_hook-inl.h =====
//========================================

namespace base { namespace internal {

// Capacity of 8 means that HookList is 9 words.
static const int kHookListCapacity = 8;
// last entry is reserved for deprecated "singular" hooks. So we have
// 7 "normal" hooks per list
static const int kHookListMaxValues = 7;
static const int kHookListSingularIdx = 7;

// HookList: a class that provides synchronized insertions and removals and
// lockless traversal.  Most of the implementation is in malloc_hook.cc.
template <typename T>
struct PERFTOOLS_DLL_DECL HookList {
  COMPILE_ASSERT(sizeof(T) <= sizeof(AtomicWord), T_should_fit_in_AtomicWord);

  // Adds value to the list.  Note that duplicates are allowed.  Thread-safe and


//========================================
//===== File: ./third-party/gperftools/src/maybe_emergency_malloc.h =====
//========================================

namespace tcmalloc {
  static inline void *EmergencyMalloc(size_t size) {return NULL;}
  static inline void EmergencyFree(void *p) {}
  static inline void *EmergencyCalloc(size_t n, size_t elem_size) {return NULL;}
  static inline void *EmergencyRealloc(void *old_ptr, size_t new_size) {return NULL;}

  static inline bool IsEmergencyPtr(const void *_ptr) {
    return false;
  }
}


//========================================
//===== File: ./third-party/gperftools/src/maybe_threads.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/memory_region_map.h =====
//========================================
// see the comment at the top of our .cc file.
class MemoryRegionMap {
 private:
  // Max call stack recording depth supported by Init().  Set it to be
  // high enough for all our clients.  Note: we do not define storage
  // for this (doing that requires special handling in windows), so
  // don't take the address of it!
  static const int kMaxStackDepth = 32;

  // Size of the hash table of buckets.  A structure of the bucket table is
  // described in heap-profile-stats.h.
  static const int kHashTableSize = 179999;

 public:
  // interface ================================================================

  // Every client of MemoryRegionMap must call Init() before first use,
  // Uses Lock/Unlock inside.
  static void Init(int max_stack_depth, bool use_buckets);

  // Try to shutdown this module undoing what Init() did.
  // Returns true iff could do full shutdown (or it was not attempted).
  // the number of Init() calls.
  static bool Shutdown();

  // Return true if MemoryRegionMap is initialized and recording, i.e. when
  // then number of Init() calls are more than the number of Shutdown() calls.
  static bool IsRecordingLocked();

  // Locks to protect our internal data structures.
  // These also protect use of arena_ if our Init() has been done.
  // The lock is recursive.
  static void Lock() EXCLUSIVE_LOCK_FUNCTION(lock_);
  static void Unlock() UNLOCK_FUNCTION(lock_);

  // Returns true when the lock is held by this thread (for use in RAW_CHECK-s).
  static bool LockIsHeld();

  // Locker object that acquires the MemoryRegionMap::Lock
  // for the duration of its lifetime (a C++ scope).
  class LockHolder {
   public:
    LockHolder() { Lock(); }
    ~LockHolder() { Unlock(); }
   private:
    DISALLOW_COPY_AND_ASSIGN(LockHolder);
  };

  // exports the collected data to its clients.  Thread-compatible.
  struct Region {
    uintptr_t start_addr;  // region start address
    uintptr_t end_addr;  // region end address
    int call_stack_depth;  // number of caller stack frames that we saved

   private:  // helpers for MemoryRegionMap
    friend class MemoryRegionMap;

    // The ways we create Region-s:
  // Returns success. Uses Lock/Unlock inside.
  static bool FindRegion(uintptr_t addr, Region* result);

  // Find the region that contains stack_top, mark that region as
  // a stack region, and write its data into *result if found,
  // Returns success. Uses Lock/Unlock inside.
  static bool FindAndMarkStackRegion(uintptr_t stack_top, Region* result);

  // Iterate over the buckets which store mmap and munmap counts per stack
  // trace.  It calls "callback" for each bucket, and passes "arg" to it.
  template<class Type>
  static void IterateBuckets(void (*callback)(const HeapProfileBucket*, Type),
                             Type arg);

  // Get the bucket whose caller stack trace is "key".  The stack trace is
  // The bucket table is described in heap-profile-stats.h.
  static HeapProfileBucket* GetBucket(int depth, const void* const key[]);

 private:  // our internal types ==============================================

  // Region comparator for sorting with STL
  struct RegionCmp {
    bool operator()(const Region& x, const Region& y) const {
      return x.end_addr < y.end_addr;
    }
  // We allocate STL objects in our own arena.
  struct MyAllocator {
    static void *Allocate(size_t n) {
      return LowLevelAlloc::AllocWithArena(n, arena_);
    }
    static void Free(const void *p, size_t /* n */) {
      LowLevelAlloc::Free(const_cast<void*>(p));
    }
  };
  // Set of the memory regions
  typedef std::set<Region, RegionCmp,
              STL_Allocator<Region, MyAllocator> > RegionSet;

 public:  // more in-depth interface ==========================================

  // STL iterator with values of Region
  typedef RegionSet::const_iterator RegionIterator;

  // Return the begin/end iterators to all the regions.
  // These need Lock/Unlock protection around their whole usage (loop).
  // re-evaluated whenever the set of regions has changed.
  static RegionIterator BeginRegionLocked();
  static RegionIterator EndRegionLocked();

  // Return the accumulated sizes of mapped and unmapped regions.
  static int64 MapSize() { return map_size_; }
  static int64 UnmapSize() { return unmap_size_; }

  // Effectively private type from our .cc =================================
  // public to let us declare global objects:

 private:
  // representation ===========================================================

  // Counter of clients of this module that have called Init().
  static int client_count_;

  // Maximal number of caller stack frames to save (>= 0).
  static int max_stack_depth_;

  // Arena used for our allocations in regions_.
  static LowLevelAlloc::Arena* arena_;

  // Set of the mmap/sbrk/mremap-ed memory regions
  // To be accessed *only* when Lock() is held.
  // simply by acquiring our recursive Lock() before that.
  static RegionSet* regions_;

  // Lock to protect regions_ and buckets_ variables and the data behind.
  static SpinLock lock_;
  // Lock to protect the recursive lock itself.
  static SpinLock owner_lock_;

  // Recursion count for the recursive lock.
  static int recursion_count_;
  // The thread id of the thread that's inside the recursive lock.
  static pthread_t lock_owner_tid_;

  // Total size of all mapped pages so far
  static int64 map_size_;
  // Total size of all unmapped pages so far
  static int64 unmap_size_;

  // Bucket hash table which is described in heap-profile-stats.h.
  static HeapProfileBucket** bucket_table_ GUARDED_BY(lock_);
  static int num_buckets_ GUARDED_BY(lock_);

  // The following members are local to MemoryRegionMap::GetBucket()
  // and MemoryRegionMap::HandleSavedBucketsLocked()
  // Number of unprocessed bucket inserts.
  static int saved_buckets_count_ GUARDED_BY(lock_);

  // Unprocessed inserts (must be big enough to hold all mmaps that can be
  // caused by a GetBucket call).
  // with the any-time use of the static memory behind saved_buckets.
  static HeapProfileBucket saved_buckets_[20] GUARDED_BY(lock_);

  static const void* saved_buckets_keys_[20][kMaxStackDepth] GUARDED_BY(lock_);

  // helpers ==================================================================

  // returns the region covering 'addr' or NULL; assumes our lock_ is held.
  static const Region* DoFindRegionLocked(uintptr_t addr);

  // Verifying wrapper around regions_->insert(region)
  // To be called to do InsertRegionLocked's work only!
  // table where all buckets eventually should be.
  static void RestoreSavedBucketsLocked();

  // Initialize RegionSet regions_.
  inline static void InitRegionSetLocked();
  // (called from our mmap/mremap/sbrk hooks).
  static void RecordRegionAddition(const void* start, size_t size);
  // Record deletion of a memory region at address "start" of size "size"
  // (called from our munmap/mremap/sbrk hooks).
  static void RecordRegionRemoval(const void* start, size_t size);

  // Record deletion of a memory region of size "size" in a bucket whose
  // caller stack trace is "key".  The stack trace is used to a depth of
  // "depth" at most.
  static void RecordRegionRemovalInBucket(int depth,
                                          const void* const key[],
                                          size_t size);

  // Hooks for MallocHook
  static void MmapHook(const void* result,
                       const void* start, size_t size,
                       int prot, int flags,
                       int fd, off_t offset);
  static void MunmapHook(const void* ptr, size_t size);
  static void MremapHook(const void* result, const void* old_addr,
                         size_t old_size, size_t new_size, int flags,
                         const void* new_addr);
  static void SbrkHook(const void* result, ptrdiff_t increment);

  // Log all memory regions; Useful for debugging only.
  // Assumes Lock() is held
  static void LogAllLocked();

  DISALLOW_COPY_AND_ASSIGN(MemoryRegionMap);
};

template <class Type>
void MemoryRegionMap::IterateBuckets(
    void (*callback)(const HeapProfileBucket*, Type), Type callback_arg) {
  for (int index = 0; index < kHashTableSize; index++) {


//========================================
//===== File: ./third-party/gperftools/src/packed-cache-inl.h =====
//========================================
// comment at the top of the file.
template <int kKeybits>
class PackedCache {
 public:
  typedef uintptr_t T;
  typedef uintptr_t K;
  typedef uint32 V;
#ifdef TCMALLOC_SMALL_BUT_SLOW
  // Decrease the size map cache if running in the small memory mode.
  static const int kHashbits = 12;
#else
  static const int kHashbits = 16;
#endif
  static const int kValuebits = 7;
  // one bit after value bits
  static const int kInvalidMask = 0x80;

  explicit PackedCache() {
    COMPILE_ASSERT(kKeybits + kValuebits + 1 <= 8 * sizeof(T), use_whole_keys);
    COMPILE_ASSERT(kHashbits <= kKeybits, hash_function);
    COMPILE_ASSERT(kHashbits >= kValuebits + 1, small_values_space);

 private:
  // we just wipe all hash bits out of key. I.e. clear lower
  // kHashbits. We rely on compiler knowing value of Hash(k).
  static T KeyToUpper(K k) {
    return static_cast<T>(k) ^ Hash(k);
  }

  static T Hash(K key) {
    return static_cast<T>(key) & N_ONES_(size_t, kHashbits);
  }

  // For masking a K.
  static const K kKeyMask = N_ONES_(K, kKeybits);

  // For masking a V or a T.
  static const V kValueMask = N_ONES_(V, kValuebits);

  // array_ is the cache.  Its elements are volatile because any
  // thread can write any array element at any time.


//========================================
//===== File: ./third-party/gperftools/src/page_heap.h =====
//========================================

namespace base {
struct MallocRange;
}

namespace tcmalloc {

// -------------------------------------------------------------------------
// Map from page-id to per-page data
// Selector class -- general selector uses 3-level map
template <int BITS> class MapSelector {
 public:
  typedef TCMalloc_PageMap3<BITS-kPageShift> Type;
};

#ifndef TCMALLOC_SMALL_BUT_SLOW
// TCMALLOC_SMALL_BUT_SLOW mode.
template <> class MapSelector<48> {
 public:
  typedef TCMalloc_PageMap2<48-kPageShift> Type;
};

#endif // TCMALLOC_SMALL_BUT_SLOW
// A two-level map for 32-bit machines
template <> class MapSelector<32> {
 public:
  typedef TCMalloc_PageMap2<32-kPageShift> Type;
};

// -------------------------------------------------------------------------

class PERFTOOLS_DLL_DECL PageHeap {
 public:
  PageHeap();

  // Allocate a run of "n" pages.  Returns zero if out of memory.
  // Page heap statistics
  struct Stats {
    Stats() : system_bytes(0), free_bytes(0), unmapped_bytes(0), committed_bytes(0),
        scavenge_count(0), commit_count(0), total_commit_bytes(0),
        decommit_count(0), total_decommit_bytes(0),

  struct SmallSpanStats {
    // For each free list of small spans, the length (in spans) of the
    // normal and returned free lists for that size.
    //
  // Stats for free large spans (i.e., spans with more than kMaxPages pages).
  struct LargeSpanStats {
    int64 spans;           // Number of such spans
    int64 normal_pages;    // Combined page length of normal large spans
    int64 returned_pages;  // Combined page length of unmapped spans

 private:
  // Allocates a big block of memory for the pagemap once we reach more than
  // 128MB
  static const size_t kPageMapBigAllocationThreshold = 128 << 20;

  // Minimum number of pages to fetch from system at a time.  Must be
  // significantly bigger than kBlockSize to amortize system-call
  // REQUIRED: kMinSystemAlloc <= kMaxPages;
  static const int kMinSystemAlloc = kMaxPages;

  // Never delay scavenging for more than the following number of
  // deallocated pages.  With 4K pages, this comes to 4GB of
  // deallocation.
  static const int kMaxReleaseDelay = 1 << 20;

  // If there is nothing to release, wait for so many pages before
  // scavenging again.  With 4K pages, this comes to 1GB of memory.
  static const int kDefaultReleaseDelay = 1 << 18;

  // Pick the appropriate map and cache types based on pointer size
  typedef MapSelector<kAddressBits>::Type PageMap;
  typedef PackedCache<kAddressBits - kPageShift> PageMapCache;
  mutable PageMapCache pagemap_cache_;
  PageMap pagemap_;

  // has been returned to the system.
  struct SpanList {
    Span        normal;
    Span        returned;
  };


//========================================
//===== File: ./third-party/gperftools/src/page_heap_allocator.h =====
//========================================

namespace tcmalloc {

// Simple allocator for objects of a specified type.  External locking
// is required before accessing one of these objects.
template <class T>
class PageHeapAllocator {
 public:
  // We use an explicit Init function because these variables are statically
  // allocated and their constructors might not have run by the time some
  // other static variable tries to allocate memory.

 private:
  // How much to allocate from system at a time
  static const int kAllocIncrement = 128 << 10;

  // Free area from which to carve new objects
  char* free_area_;
// different locking tags can safely be used concurrently.
template <typename T, class LockingTag>
class STLPageHeapAllocator {
 public:
  typedef size_t     size_type;
  typedef ptrdiff_t  difference_type;
  typedef T*         pointer;
  typedef const T*   const_pointer;
  typedef T&         reference;
  typedef const T&   const_reference;
  typedef T          value_type;

  template <class T1> struct rebind {
    typedef STLPageHeapAllocator<T1, LockingTag> other;
  };

  STLPageHeapAllocator() { }
  STLPageHeapAllocator(const STLPageHeapAllocator&) { }
  template <class T1> STLPageHeapAllocator(const STLPageHeapAllocator<T1, LockingTag>&) { }
  ~STLPageHeapAllocator() { }

  pointer address(reference x) const { return &x; }

 private:
  struct Storage {
    explicit Storage(base::LinkerInitialized x) {}
    PageHeapAllocator<T> allocator;
    bool initialized;
  };
  static Storage underlying_;
};

template<typename T, class LockingTag>
typename STLPageHeapAllocator<T, LockingTag>::Storage STLPageHeapAllocator<T, LockingTag>::underlying_(base::LINKER_INITIALIZED);

}  // namespace tcmalloc


//========================================
//===== File: ./third-party/gperftools/src/pagemap.h =====
//========================================
// Single-level array
template <int BITS>
class TCMalloc_PageMap1 {
 private:
  static const int LENGTH = 1 << BITS;

  void** array_;

 public:
  typedef uintptr_t Number;

  explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) {
    array_ = reinterpret_cast<void**>((*allocator)(sizeof(void*) << BITS));
    memset(array_, 0, sizeof(void*) << BITS);
  }
// Two-level radix tree
template <int BITS>
class TCMalloc_PageMap2 {
 private:
  static const int LEAF_BITS = (BITS + 1) / 2;
  static const int LEAF_LENGTH = 1 << LEAF_BITS;

  static const int ROOT_BITS = BITS - LEAF_BITS;
  static const int ROOT_LENGTH = 1 << ROOT_BITS;

  // Leaf node
  struct Leaf {
    void* values[LEAF_LENGTH];
  };


 public:
  typedef uintptr_t Number;

  explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) {
    allocator_ = allocator;
    memset(root_, 0, sizeof(root_));
  }
// Three-level radix tree
template <int BITS>
class TCMalloc_PageMap3 {
 private:
  // How many bits should we consume at each interior level
  static const int INTERIOR_BITS = (BITS + 2) / 3; // Round-up
  static const int INTERIOR_LENGTH = 1 << INTERIOR_BITS;

  // How many bits should we consume at leaf level
  static const int LEAF_BITS = BITS - 2*INTERIOR_BITS;
  static const int LEAF_LENGTH = 1 << LEAF_BITS;

  // Interior node
  struct Node {
    Node* ptrs[INTERIOR_LENGTH];
  };

  // Leaf node
  struct Leaf {
    void* values[LEAF_LENGTH];
  };


 public:
  typedef uintptr_t Number;

  explicit TCMalloc_PageMap3(void* (*allocator)(size_t)) {
    allocator_ = allocator;
    memset(&root_, 0, sizeof(root_));
  }


//========================================
//===== File: ./third-party/gperftools/src/profiledata.h =====
//========================================
//    the first SpinLock in all cases where both are needed.)
class ProfileData {
 public:
  struct State {
    bool     enabled;             // Is profiling currently enabled?
    time_t   start_time;          // If enabled, when was profiling started?
    char     profile_name[1024];  // Name of file being written, or '\0'

  class Options {
   public:
    Options();

    // Get and set the sample frequency.

   private:
    int      frequency_;                  // Sample frequency.
  };

  static const int kMaxStackDepth = 64;  // Max stack depth stored in profile

  ProfileData();
  ~ProfileData();

 private:
  static const int kAssociativity = 4;          // For hashtable
  static const int kBuckets = 1 << 10;          // For hashtable
  static const int kBufferLength = 1 << 18;     // For eviction buffer

  // Type of slots: each slot can be either a count, or a PC value
  typedef uintptr_t Slot;

  // Hash-table/eviction-buffer entry (a.k.a. a sample)
  struct Entry {
    Slot count;                  // Number of hits
    Slot depth;                  // Stack depth
    Slot stack[kMaxStackDepth];  // Stack contents
  // Hash table bucket
  struct Bucket {
    Entry entry[kAssociativity];
  };



//========================================
//===== File: ./third-party/gperftools/src/profile-handler.h =====
//========================================
/* Forward declaration. */
struct ProfileHandlerToken;

/*
 * Callback function to be used with ProfilefHandlerRegisterCallback. This
 */
typedef void (*ProfileHandlerCallback)(int sig, siginfo_t* sig_info,
                                       void* ucontext, void* callback_arg);

/*
 */
struct ProfileHandlerState {
  int32 frequency;  /* Profiling frequency */
  int32 callback_count;  /* Number of callbacks registered */
  int64 interrupts;  /* Number of interrupts received */


//========================================
//===== File: ./third-party/gperftools/src/raw_printer.h =====
//========================================

namespace base {

class RawPrinter {
 public:
  // REQUIRES: "length > 0"
  // Will printf any data added to this into "buf[0,length-1]" and
  // will arrange to always keep buf[] null-terminated.

 private:
  // We can write into [ptr_ .. limit_-1].
  // *limit_ is also writable, but reserved for a terminating \0
  // in case we overflow.


//========================================
//===== File: ./third-party/gperftools/src/sampler.h =====
//========================================

namespace tcmalloc {

//-------------------------------------------------------------------
// Sampler to decide when to create a sample trace for an allocation

class SamplerTest;

class PERFTOOLS_DLL_DECL Sampler {
 public:
  constexpr Sampler() {}

  // Initialize this sampler.
  // Returns the current sample period
  static int GetSamplePeriod();

  // The following are public for the purposes of testing
  static uint64_t NextRandom(uint64_t rnd_);  // Returns the next prng value

  // C++03 requires that types stored in TLS be POD.  As a result, you must
  // initialize these members to {0, 0, false} before using this class!
  // DecrementFast{,Finish}, so casting to size_t is ok.
 private:
  friend class SamplerTest;
  bool RecordAllocationSlow(size_t k);



//========================================
//===== File: ./third-party/gperftools/src/span.h =====
//========================================

namespace tcmalloc {

struct SpanBestFitLess;
struct Span;

// Store a pointer to a span along with a cached copy of its length.
// These are used as set elements to improve the performance of
// the actual Span objects in most cases.
struct SpanPtrWithLength {
  explicit SpanPtrWithLength(Span* s);

  Span* span;
  Length length;
};
typedef std::set<SpanPtrWithLength, SpanBestFitLess, STLPageHeapAllocator<SpanPtrWithLength, void> > SpanSet;

// Comparator for best-fit search, with address order as a tie-breaker.
struct SpanBestFitLess {
  bool operator()(SpanPtrWithLength a, SpanPtrWithLength b) const;
};

// Information kept for a span (a contiguous run of pages).
struct Span {
  PageID        start;          // Starting page number
  Length        length;         // Number of pages in span
  Span*         next;           // Used when in link list
  // What freelist the span is on: IN_USE if on none, or normal or returned
  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };
};

#ifdef SPAN_HISTORY
inline SpanSet::iterator Span::ExtractSpanSetIterator() {
  typedef SpanSet::iterator iterator_type;

  ASSERT(has_span_iter);
  has_span_iter = 0;


//========================================
//===== File: ./third-party/gperftools/src/stack_trace_table.h =====
//========================================

namespace tcmalloc {

class PERFTOOLS_DLL_DECL StackTraceTable {
 public:
  // REQUIRES: L < pageheap_lock
  StackTraceTable();
  ~StackTraceTable();

 private:
  struct Entry {
    Entry* next;
    StackTrace trace;
  };


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_arm-inl.h =====
//========================================
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING>
static void **NextStackFrame(void **old_sp) {
  void **new_sp = (void**) old_sp[-1];

  // Check that the transition from frame pointer old_sp to frame
//   void* ucp: a ucontext_t* (GetStack{Trace,Frames}WithContext only)
static int GET_STACK_TRACE_OR_FRAMES {
#ifdef __GNUC__
  void **sp = reinterpret_cast<void**>(__builtin_frame_address(0));
#else


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_generic-inl.h =====
//========================================
//   void* ucp: a ucontext_t* (GetStack{Trace,Frames}WithContext only)
static int GET_STACK_TRACE_OR_FRAMES {
  static const int kStackLength = 64;
  void * stack[kStackLength];
  int size;



//========================================
//===== File: ./third-party/gperftools/src/stacktrace_impl_setup-inl.h =====
//========================================

static GetStackImplementation SIS_CONCAT(impl__,GST_SUFFIX) = {
  SIS_CONCAT(GetStackFrames_, GST_SUFFIX),
  SIS_CONCAT(GetStackFramesWithContext_, GST_SUFFIX),
  SIS_CONCAT(GetStackTrace_, GST_SUFFIX),


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_instrument-inl.h =====
//========================================

typedef struct {
  int   stack_depth;
  void* frame[MAX_DEPTH];
}BACK_TRACE;

static BACK_TRACE thread_back_trace[MAX_THREAD];
extern "C" {
void __cyg_profile_func_enter(void *func_address,
                              void *call_site) ATTRIBUTE_NOINSTRUMENT;

static int cyg_backtrace(void **buffer, int size) {
  BACK_TRACE* backtrace = thread_back_trace + gettid();
  int stack_depth = backtrace->stack_depth;
  if ( stack_depth >= MAX_DEPTH ) {
//   void* ucp: a ucontext_t* (GetStack{Trace,Frames}WithContext only)
static int GET_STACK_TRACE_OR_FRAMES {
  static const int kStackLength = 64;
  void * stack[kStackLength];
  int size;
  memset(stack, 0, sizeof(stack));


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_libgcc-inl.h =====
//========================================

struct libgcc_backtrace_data {
  void **array;
  int skip;
  int pos;

static _Unwind_Reason_Code libgcc_backtrace_helper(struct _Unwind_Context *ctx,
                                                   void *_data) {
  libgcc_backtrace_data *data =
    reinterpret_cast<libgcc_backtrace_data *>(_data);
//   void* ucp: a ucontext_t* (GetStack{Trace,Frames}WithContext only)
static int GET_STACK_TRACE_OR_FRAMES {
  libgcc_backtrace_data data;
  data.array = result;
  // we're also skipping current and parent's frame


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_libunwind-inl.h =====
//========================================
// cases, we return 0 to indicate the situation.
static __thread int recursive ATTR_INITIAL_EXEC;

#if defined(TCMALLOC_ENABLE_UNWIND_FROM_UCONTEXT) && (defined(__i386__) || defined(__x86_64__)) && defined(__GNU_LIBRARY__)
#define BASE_STACKTRACE_UNW_CONTEXT_IS_UCONTEXT 1
//   void* ucp: a ucontext_t* (GetStack{Trace,Frames}WithContext only)
static int GET_STACK_TRACE_OR_FRAMES {
  void *ip;
  int n = 0;
  unw_cursor_t cursor;


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_powerpc-darwin-inl.h =====
//========================================
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING>
static void **NextStackFrame(void **old_sp) {
  void **new_sp = (void **) *old_sp;

  // Check that the transition from frame pointer old_sp to frame


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_powerpc-inl.h =====
//========================================

struct layout_ppc {
  struct layout_ppc *next;
#if defined(__APPLE__) || (defined(__linux) && defined(__PPC64__))
  long condition_register;
#endif
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING>
static layout_ppc *NextStackFrame(layout_ppc *current) {
  uintptr_t old_sp = (uintptr_t)(current);
  uintptr_t new_sp = (uintptr_t)(current->next);

//   void* ucp: a ucontext_t* (GetStack{Trace,Frames}WithContext only)
static int GET_STACK_TRACE_OR_FRAMES {
  layout_ppc *current;
  int n;



//========================================
//===== File: ./third-party/gperftools/src/stacktrace_powerpc-linux-inl.h =====
//========================================
// and LR save area, so no need to adjust the reading struct.
struct layout_ppc {
  struct layout_ppc *next;
#ifdef __PPC64__
  long condition_register;
#endif
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING>
static layout_ppc *NextStackFrame(layout_ppc *current) {
  uintptr_t old_sp = (uintptr_t)(current);
  uintptr_t new_sp = (uintptr_t)(current->next);

//   void* ucp: a ucontext_t* (GetStack{Trace,Frames}WithContext only)
static int GET_STACK_TRACE_OR_FRAMES {
  layout_ppc *current;
  int n;

      if (sigtramp64_vdso && (sigtramp64_vdso == current->return_addr)) {
        struct signal_frame_64 {
          char dummy[128];
          ucontext_t uc;
        // We don't care about the rest, since the IP value is at 'uc' field.
      if (sigtramp32_vdso && (sigtramp32_vdso == current->return_addr)) {
        struct signal_frame_32 {
          char dummy[64];
          struct sigcontext sctx;
          mcontext_t mctx;
          // We don't care about the rest, since IP value is at 'mctx' field.
        } *sigframe = reinterpret_cast<signal_frame_32*>(current);
      } else if (sigtramp32_rt_vdso && (sigtramp32_rt_vdso == current->return_addr)) {
        struct rt_signal_frame_32 {
          char dummy[64 + 16];
          siginfo_t info;
          ucontext_t uc;


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_win32-inl.h =====
//========================================

typedef USHORT NTAPI RtlCaptureStackBackTrace_Function(
    IN ULONG frames_to_skip,
    IN ULONG frames_to_capture,
    OUT PVOID *backtrace,
// to worry about someone else holding the loader's lock.
static RtlCaptureStackBackTrace_Function* const RtlCaptureStackBackTrace_fn =
   (RtlCaptureStackBackTrace_Function*)
   GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlCaptureStackBackTrace");

static int GetStackTrace_win32(void** result, int max_depth,
                               int skip_count) {
  if (!RtlCaptureStackBackTrace_fn) {
    // TODO(csilvers): should we log an error here?

static int not_implemented(void) {
  assert(0 == "Not yet implemented");
  return 0;
}

static int GetStackFrames_win32(void** /* pcs */,
                                int* /* sizes */,
                                int /* max_depth */,
                                int /* skip_count */) {

static int GetStackFramesWithContext_win32(void** result, int* sizes, int max_depth,
                                           int skip_count, const void *uc) {
  return not_implemented();
}

static int GetStackTraceWithContext_win32(void** result, int max_depth,
                                          int skip_count, const void *uc) {
  return not_implemented();
}


//========================================
//===== File: ./third-party/gperftools/src/stacktrace_x86-inl.h =====
//========================================
#include <cygwin/signal.h>
typedef ucontext ucontext_t;
#endif
#ifdef HAVE_STDINT_H
#include <stdint.h>   // for uintptr_t
//
static const int kMaxBytes = 10;

// We use assert()s instead of DCHECK()s -- this is too low level
// for DCHECK().

static int CountPushInstructions(const unsigned char *const addr) {
  int result = 0;
  for (int i = 0; i < kMaxBytes; ++i) {
    if (addr[i] == 0x89) {
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING, bool WITH_CONTEXT>
static void **NextStackFrame(void **old_sp, const void *uc) {
  void **new_sp = (void **) *old_sp;

#if defined(__linux__) && defined(__i386__) && defined(HAVE_VDSO_SUPPORT)
    // it only once.
    static int num_push_instructions = -1;  // Sentinel: not computed yet.
    // Initialize with sentinel value: __kernel_rt_sigreturn can not possibly
    // be there.
    static const unsigned char *kernel_rt_sigreturn_address = NULL;
    static const unsigned char *kernel_vsyscall_address = NULL;
    if (num_push_instructions == -1) {
      base::VDSOSupport vdso;
      if (vdso.IsPresent()) {
          // that GCC would otherwise insert (__cxa_guard_acquire etc).
          static int page_size;
          if (page_size == 0) {
            // First time through.
            page_size = getpagesize();
    //       is already on its last leg, so it's ok to be slow here.
    static int page_size = getpagesize();
    void *new_sp_aligned = (void *)((uintptr_t)new_sp & ~(page_size - 1));
    if (msync(new_sp_aligned, page_size, MS_ASYNC) == -1)
      return NULL;

static int GET_STACK_TRACE_OR_FRAMES {
  void **sp;
#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2) || __llvm__
  // __builtin_frame_address(0) can return the wrong address on gcc-4.1.0-k8.


//========================================
//===== File: ./third-party/gperftools/src/static_vars.h =====
//========================================

namespace tcmalloc {

class Static {
 public:
  // Linker initialized, so this lock can be accessed at any time.
  static SpinLock* pageheap_lock() { return &pageheap_lock_; }

  // Must be called before calling any of the accessors below.
  static void InitStaticVars();
  static void InitLateMaybeRecursive();

  // Central cache -- an array of free-lists, one per size-class.
  // We have a separate lock per free-list to reduce contention.
  static CentralFreeListPadded* central_cache() { return central_cache_; }

  static SizeMap* sizemap() { return &sizemap_; }

  static unsigned num_size_classes() { return sizemap_.num_size_classes; }

  //////////////////////////////////////////////////////////////////////
  // In addition to the explicit initialization comment, the variables below
  // Page-level allocator.
  static PageHeap* pageheap() { return reinterpret_cast<PageHeap *>(&pageheap_.memory); }

  static PageHeapAllocator<Span>* span_allocator() { return &span_allocator_; }

  static PageHeapAllocator<StackTrace>* stacktrace_allocator() {
    return &stacktrace_allocator_;
  }

  static StackTrace* growth_stacks() { return growth_stacks_; }
  static void set_growth_stacks(StackTrace* s) { growth_stacks_ = s; }

  // State kept for sampled allocations (/pprof/heap support)
  static Span* sampled_objects() { return &sampled_objects_; }

  // Check if InitStaticVars() has been run.
  static bool IsInited() { return inited_; }

 private:
  // some unit tests depend on this and link to static vars
  // imperfectly. Thus we keep those unhidden for now. Thankfully
  // they're not performance-critical.


//========================================
//===== File: ./third-party/gperftools/src/symbolize.h =====
//========================================
// to get the symbol names for pretty-printing the stack traces.
class SymbolTable {
 public:
  SymbolTable()
    : symbol_buffer_(NULL) {}
  ~SymbolTable() {

 private:
  typedef map<const void*, const char*> SymbolMap;

  // An average size of memory allocated for a stack trace symbol.
  static const int kSymbolSize = 1024;

  // Map from addresses to symbol names.
  SymbolMap symbolization_table_;


//========================================
//===== File: ./third-party/gperftools/src/system-alloc.h =====
//========================================

class SysAllocator;

// REQUIRES: "alignment" is a power of two or "0" to indicate default alignment
//


//========================================
//===== File: ./third-party/gperftools/src/tcmalloc.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/tcmalloc_guard.h =====
//========================================

class TCMallocGuard {
 public:
  TCMallocGuard();
  ~TCMallocGuard();
};


//========================================
//===== File: ./third-party/gperftools/src/third_party/valgrind.h =====
//========================================

typedef
   struct { 
      unsigned int nraddr; /* where's the code? */
   }
   OrigFn;

typedef
   struct { 
      unsigned long long int nraddr; /* where's the code? */
   }
   OrigFn;

typedef
   struct { 
      unsigned int nraddr; /* where's the code? */
   }
   OrigFn;

typedef
   struct { 
      unsigned long long int nraddr; /* where's the code? */
      unsigned long long int r2;  /* what tocptr do we need? */
   }

typedef
   struct { 
      unsigned int nraddr; /* where's the code? */
      unsigned int r2;  /* what tocptr do we need? */
   }

typedef
   struct { 
      unsigned long long int nraddr; /* where's the code? */
      unsigned long long int r2;  /* what tocptr do we need? */
   }
   ENTRIES, NOR DELETE ANY -- add new ones at the end. */
typedef
   enum { VG_USERREQ__RUNNING_ON_VALGRIND  = 0x1001,
          VG_USERREQ__DISCARD_TRANSLATIONS = 0x1002,

          /* These allow any function to be called from the simulated
   and unused attribute will shut down warnings about it.  */
static int VALGRIND_PRINTF(const char *format, ...)
   __attribute__((format(__printf__, 1, 2), __unused__));
static int
VALGRIND_PRINTF(const char *format, ...)
{
   unsigned long _qzz_res;

static int VALGRIND_PRINTF_BACKTRACE(const char *format, ...)
   __attribute__((format(__printf__, 1, 2), __unused__));
static int
VALGRIND_PRINTF_BACKTRACE(const char *format, ...)
{
   unsigned long _qzz_res;


//========================================
//===== File: ./third-party/gperftools/src/thread_cache.h =====
//========================================

namespace tcmalloc {

//-------------------------------------------------------------------
// Data kept per thread

class ThreadCache {
 public:
#ifdef HAVE_TLS
  enum { have_tls = true };
#else
  enum { have_tls = false };
#endif

  void Init(pthread_t tid);

  static void         InitModule();
  static void         InitTSD();
  static ThreadCache* GetThreadHeap();
  static ThreadCache* GetCache();
  static ThreadCache* GetCacheIfPresent();
  static ThreadCache* GetFastPathCache();
  static ThreadCache* GetCacheWhichMustBePresent();
  static ThreadCache* CreateCacheIfNecessary();
  static void         BecomeIdle();
  static void         BecomeTemporarilyIdle();
  static void         SetUseEmergencyMalloc();
  static void         ResetUseEmergencyMalloc();
  static bool         IsUseEmergencyMalloc();

  // Return the number of thread heaps in use.
  static inline int HeapsInUse();

  // Adds to *total_bytes the total number of bytes used by all thread heaps.
  // Also, if class_count is not NULL, it must be an array of size kNumClasses,
  // REQUIRES: Static::pageheap_lock is held.
  static void GetThreadStats(uint64_t* total_bytes, uint64_t* class_count);

  // Sets the total thread cache size to new_size, recomputing the
  // individual thread cache sizes as necessary.
  // REQUIRES: Static::pageheap lock is held.
  static void set_overall_thread_cache_size(size_t new_size);
  static size_t overall_thread_cache_size() {
    return overall_thread_cache_size_;
  }

 private:
  class FreeList {
   private:
    void*    list_;       // Linked list of nodes

#ifdef _LP64

   public:
    void Init(size_t size) {
      list_ = NULL;
      length_ = 0;
#ifdef HAVE_TLS
  struct ThreadLocalData {
    ThreadCache* fast_path_heap;
    ThreadCache* heap;
    bool use_emergency_malloc;
  };
  static __thread ThreadLocalData threadlocal_data_
    CACHELINE_ALIGNED ATTR_INITIAL_EXEC;

#endif
  // Until then, we use a slow path to get the heap object.
  static ATTRIBUTE_HIDDEN bool tsd_inited_;
  static pthread_key_t heap_key_;

  // Linked list of heap objects.  Protected by Static::pageheap_lock.
  static ThreadCache* thread_heaps_;
  static int thread_heap_count_;

  // A pointer to one of the objects in thread_heaps_.  Represents
  // the next ThreadCache from which a thread over its max_size_ should
  // thread_heaps_.  Protected by Static::pageheap_lock.
  static ThreadCache* next_memory_steal_;

  // Overall thread cache size.  Protected by Static::pageheap_lock.
  static size_t overall_thread_cache_size_;

  // Global per-thread cache size.  Writes are protected by
  // Static::pageheap_lock.  Reads are done without any locking, which should be
  // invariants between this variable and other pieces of state.
  static volatile size_t per_thread_cache_size_;

  // Represents overall_thread_cache_size_ minus the sum of max_size_
  // across all ThreadCaches.  Protected by Static::pageheap_lock.
  static ssize_t unclaimed_cache_space_;

  // This class is laid out with the most frequently used fields
  // first so that hot elements are placed on the same cache line.
  // Allocate a new heap. REQUIRES: Static::pageheap_lock is held.
  static ThreadCache* NewHeap(pthread_t tid);

  // Use only as pthread thread-specific destructor function.
  static void DestroyThreadCache(void* ptr);

  static void DeleteCache(ThreadCache* heap);
  static void RecomputePerThreadCacheSize();

public:

  // All ThreadCache objects are kept in a linked list (for stats collection)
  ThreadCache* next_;


//========================================
//===== File: ./third-party/gperftools/src/windows/config.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/windows/google/tcmalloc.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/windows/gperftools/tcmalloc.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/windows/mingw.h =====
//========================================


//========================================
//===== File: ./third-party/gperftools/src/windows/mini_disassembler.h =====
//========================================

namespace sidestep {

// This small disassembler is very limited
// in its functionality, and in fact does only the bare minimum required by the
// etc.
class PERFTOOLS_DLL_DECL MiniDisassembler {
 public:

  // Creates a new instance and sets defaults.
  //

 private:

  // Makes the disassembler ready for reuse.
  void Initialize();
  // in Ia32OpcodeMap.cc
  static const OpcodeTable s_ia32_opcode_map_[];

  // Somewhat smaller table to help with decoding ModR/M bytes
  // when 16-bit addressing mode is being used.  Defined in
  // Ia32ModrmMap.cc
  static const ModrmEntry s_ia16_modrm_map_[];

  // Somewhat smaller table to help with decoding ModR/M bytes
  // when 32-bit addressing mode is being used.  Defined in
  // Ia32ModrmMap.cc
  static const ModrmEntry s_ia32_modrm_map_[];

  // Indicators of whether we got certain prefixes that certain
  // silly Intel instructions depend on in nonstandard ways for


//========================================
//===== File: ./third-party/gperftools/src/windows/mini_disassembler_types.h =====
//========================================

namespace sidestep {

// Categories of instructions that we care about
enum InstructionType {
  // This opcode is not used
  IT_UNUSED,
  // This disassembler does not recognize this opcode (error)
// Lists IA-32 operand sizes in multiples of 8 bits
enum OperandSize {
  OS_ZERO = 0,
  OS_BYTE = 1,
  OS_WORD = 2,
// on the operand in a single integer.
enum AddressingMethod {
  AM_NOT_USED = 0,        // This operand is not used for this instruction
  AM_MASK = 0x00FF0000,  // Mask for the rest of the values in this enumeration
  AM_A = 0x00010000,    // A addressing type
// on the operand in a single integer.
enum OperandType {
  OT_MASK = 0xFF000000,
  OT_A = 0x01000000,
  OT_B = 0x02000000,
// defines MOV as the only instruction supporting a 64-bit immediate operand.
enum ImmediateOperandSize {
  IOS_MASK = 0x0000F000,
  IOS_DEFAULT = 0x0,
  IOS_64 = 0x00001000
// alternative opcode structs for different prefixes.
struct SpecificOpcode {
  // Index to continuation table, or 0 if this is the last
  // byte in the opcode.
  int table_index_;
// valid instructions recognized by the IA-32 architecture.
struct Opcode {
  // Index to continuation table, or 0 if this is the last
  // byte in the opcode.
  int table_index_;
// Information about each table entry.
struct OpcodeTable {
  // Table of instruction entries
  const Opcode* table_;
  // How many bytes left to shift ModR/M byte <b>before</b> applying mask
// Information about each entry in table used to decode ModR/M byte.
struct ModrmEntry {
  // Is the operand encoded as bytes in the instruction (rather than
  // if it's e.g. a register in which case it's just encoded in the
  // ModR/M byte)


//========================================
//===== File: ./third-party/gperftools/src/windows/port.h =====
//========================================

typedef __int8 int8_t;
typedef __int16 int16_t;
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int8 uint8_t;
typedef unsigned __int16 uint16_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#endif  /* #ifndef HAVE_STDINT_H */

/* I guess MSVC's <types.h> doesn't include ssize_t by default? */
#ifdef _MSC_VER
typedef intptr_t ssize_t;
#endif

/* ----------------------------------- THREADS */
#ifndef HAVE_PTHREAD   /* not true for MSVC, but may be true for MSYS */
typedef DWORD pthread_t;
typedef DWORD pthread_key_t;
typedef LONG pthread_once_t;
enum { PTHREAD_ONCE_INIT = 0 };   /* important that this be 0! for SpinLock */

inline pthread_t pthread_self(void) {
  return GetCurrentThreadId();
#ifdef __cplusplus
class SpinLock {
 public:
  SpinLock() : initialize_token_(PTHREAD_ONCE_INIT) {}
  // Used for global SpinLock vars (see base/spinlock.h for more details).
  enum StaticInitializer { LINKER_INITIALIZED };
  explicit SpinLock(StaticInitializer) : initialize_token_(PTHREAD_ONCE_INIT) {
    perftools_pthread_once(&initialize_token_, InitializeMutex);
  }

  }
 private:
  void InitializeMutex() { InitializeCriticalSection(&mutex_); }

  pthread_once_t initialize_token_;

class SpinLockHolder {  // Acquires a spinlock for as long as the scope lasts
 private:
  SpinLock* lock_;
 public:
  inline explicit SpinLockHolder(SpinLock* l) : lock_(l) { l->Lock(); }
  inline ~SpinLockHolder() { lock_->Unlock(); }
};
#if __STDC__ && !defined(__MINGW32__)
typedef _off_t off_t;
#endif

/* VirtualAlloc only replaces for mmap when certain invariants are kept. */
#ifndef __MINGW32__
enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };
#endif
#ifndef O_RDONLY
#define O_RDONLY  _O_RDONLY
#ifndef HAVE_PID_T
typedef int pid_t;
#endif

#if __STDC__ && !defined(__MINGW32__)
#ifndef _TIMESPEC_DEFINED
struct timespec {
  int tv_sec;
  int tv_nsec;
};


//========================================
//===== File: ./third-party/gperftools/src/windows/preamble_patcher.h =====
//========================================
#ifdef _M_X64
static const bool kIs64BitBinary = true;
#else
static const bool kIs64BitBinary = false;
#endif

namespace sidestep {

// Possible results of patching/unpatching
enum SideStepError {
  SIDESTEP_SUCCESS = 0,
  SIDESTEP_INVALID_PARAMETER,
  SIDESTEP_INSUFFICIENT_BUFFER,

class DeleteUnsignedCharArray;

// Implements a patching mechanism that overwrites the first few bytes of
// a function preamble with a jump to our hook function, which is then
// invoked.  See preamble_patcher_test.cc for an example.
class PERFTOOLS_DLL_DECL PreamblePatcher {
 public:

  // This is a typesafe version of RawPatch(), identical in all other
  // ways than it takes a template parameter indicating the type of the
  // @endcode
  template <class T>
  static SideStepError Patch(T target_function,
                             T replacement_function,
                             T* original_function_stub) {
    // NOTE: casting from a function to a pointer is contra the C++
  // indicates success.
  template <class T>
  static SideStepError Patch(LPCTSTR module_name,
                             LPCSTR function_name,
                             T replacement_function,
                             T* original_function_stub) {
  // know only one thread is running, e.g. unit tests.
  static SideStepError RawPatch(void* target_function,
                                void* replacement_function,
                                void** original_function_stub);

  // indicates success.
  static SideStepError Unpatch(void* target_function,
                               void* replacement_function,
                               void* original_function_stub);

  // of a chain of JMPs).
  template <class T>
  static T ResolveTarget(T target_function) {
    return (T)ResolveTargetImpl((unsigned char*)target_function, NULL);
  }

  //          be used to store a function preamble block.
  static unsigned char* AllocPreambleBlockNear(void* target);

  // Frees a block allocated by AllocPreambleBlockNear.
  //
  // @param block     Block that was returned by AllocPreambleBlockNear.
  static void FreePreambleBlock(unsigned char* block);

 private:
  friend class DeleteUnsignedCharArray;

   // Used to store data allocated for preamble stubs
  struct PreamblePage {
    unsigned int magic_;
    PreamblePage* next_;
    // This member points to a linked list of free blocks within the page
  // 2GB of the target.
  static PreamblePage* preamble_pages_;
  
  // Page granularity
  static long granularity_;

  // Page size
  static long pagesize_;

  // Determines if the patcher has been initialized.
  static bool initialized_;

  // Used to initialize static members.
  static void Initialize();

  // Patches a function by overwriting its first few bytes with
  // a jump to a different function.  This is similar to the RawPatch
  // @return An error code indicating the result of patching.
  static SideStepError RawPatchWithStubAndProtections(
      void* target_function,
      void* replacement_function,
      unsigned char* preamble_stub,
  // @return An error code indicating the result of patching.
  static SideStepError RawPatchWithStub(void* target_function,
                                        void* replacement_function,
                                        unsigned char* preamble_stub,
                                        unsigned long stub_size,
  // of a chain of JMPs).
  static void* ResolveTargetImpl(unsigned char* target_function,
                                 unsigned char* stop_before,
                                 bool stop_before_trampoline = false);

  // @return   Returns an address that is within 2GB of target.
  static void* AllocPageNear(void* target);

  // Helper routine that determines if a target instruction is a short
  // conditional jump.
  // @return  Returns true if the instruction is a short conditional jump.
  static bool IsShortConditionalJump(unsigned char* target,
                                     unsigned int instruction_size);

  static bool IsShortJump(unsigned char *target, unsigned int instruction_size);

  // Helper routine that determines if a target instruction is a near
  // conditional jump.
  // @return  Returns true if the instruction is a near conditional jump.
  static bool IsNearConditionalJump(unsigned char* target,
                                    unsigned int instruction_size);

  // Helper routine that determines if a target instruction is a near
  // @return  Returns true if the instruction is a near absolute jump.
  static bool IsNearRelativeJump(unsigned char* target,
                                 unsigned int instruction_size);

  // Helper routine that determines if a target instruction is a near 
  // @return  Returns true if the instruction is a near absolute call.
  static bool IsNearAbsoluteCall(unsigned char* target,
                                 unsigned int instruction_size);

  // Helper routine that determines if a target instruction is a near 
  // @return  Returns true if the instruction is a near absolute call.
  static bool IsNearRelativeCall(unsigned char* target,
                                 unsigned int instruction_size);

  // Helper routine that determines if a target instruction is a 64-bit MOV
  // @return  Returns true if the instruction is a MOV with displacement.
  static bool IsMovWithDisplacement(unsigned char* target,
                                    unsigned int instruction_size);

  // Helper routine that converts a short conditional jump instruction
  // @return  Returns SIDESTEP_SUCCESS if successful, otherwise an error.
  static SideStepError PatchShortConditionalJump(unsigned char* source,
                                                 unsigned int instruction_size,
                                                 unsigned char* target,
                                                 unsigned int* target_bytes,

  static SideStepError PatchShortJump(unsigned char* source,
                                      unsigned int instruction_size,
                                      unsigned char* target,
                                      unsigned int* target_bytes,
  // @return  Returns SIDESTEP_SUCCESS if successful, otherwise an error.
  static SideStepError PatchNearJumpOrCall(unsigned char* source,
                                           unsigned int instruction_size,
                                           unsigned char* target,
                                           unsigned int* target_bytes,
  // @return  Returns SIDESTEP_SUCCESS if successful, otherwise an error.
  static SideStepError PatchMovWithDisplacement(unsigned char* source,
                                                unsigned int instruction_size,
                                                unsigned char* target,
                                                unsigned int* target_bytes,
